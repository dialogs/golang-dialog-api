// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: media_and_files.proto

package dialog

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Colors int32

const (
	COLORS_UNKNOWN Colors = 0
	COLORS_RED     Colors = 1
	COLORS_YELLOW  Colors = 2
	COLORS_GREEN   Colors = 3
)

var Colors_name = map[int32]string{
	0: "COLORS_UNKNOWN",
	1: "COLORS_RED",
	2: "COLORS_YELLOW",
	3: "COLORS_GREEN",
}

var Colors_value = map[string]int32{
	"COLORS_UNKNOWN": 0,
	"COLORS_RED":     1,
	"COLORS_YELLOW":  2,
	"COLORS_GREEN":   3,
}

func (Colors) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{0}
}

type FileUrlError_ErrorTag int32

const (
	FILEURLERROR_UNKNOWN                 FileUrlError_ErrorTag = 0
	FILEURLERROR_STORAGE_ERROR           FileUrlError_ErrorTag = 1
	FILEURLERROR_STORAGE_FORBIDDEN_ERROR FileUrlError_ErrorTag = 2
)

var FileUrlError_ErrorTag_name = map[int32]string{
	0: "FILEURLERROR_UNKNOWN",
	1: "FILEURLERROR_STORAGE_ERROR",
	2: "FILEURLERROR_STORAGE_FORBIDDEN_ERROR",
}

var FileUrlError_ErrorTag_value = map[string]int32{
	"FILEURLERROR_UNKNOWN":                 0,
	"FILEURLERROR_STORAGE_ERROR":           1,
	"FILEURLERROR_STORAGE_FORBIDDEN_ERROR": 2,
}

func (FileUrlError_ErrorTag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{11, 0}
}

// Location of file on server
type FileLocation struct {
	FileId     int64 `protobuf:"varint,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	AccessHash int64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
}

func (m *FileLocation) Reset()      { *m = FileLocation{} }
func (*FileLocation) ProtoMessage() {}
func (*FileLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{0}
}
func (m *FileLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileLocation.Merge(m, src)
}
func (m *FileLocation) XXX_Size() int {
	return m.Size()
}
func (m *FileLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_FileLocation.DiscardUnknown(m)
}

var xxx_messageInfo_FileLocation proto.InternalMessageInfo

func (m *FileLocation) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *FileLocation) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

// Image location
type ImageLocation struct {
	FileLocation *FileLocation `protobuf:"bytes,1,opt,name=file_location,json=fileLocation,proto3" json:"file_location,omitempty"`
	Width        int32         `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height       int32         `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	FileSize     int32         `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *ImageLocation) Reset()      { *m = ImageLocation{} }
func (*ImageLocation) ProtoMessage() {}
func (*ImageLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{1}
}
func (m *ImageLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ImageLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ImageLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ImageLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ImageLocation.Merge(m, src)
}
func (m *ImageLocation) XXX_Size() int {
	return m.Size()
}
func (m *ImageLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ImageLocation.DiscardUnknown(m)
}

var xxx_messageInfo_ImageLocation proto.InternalMessageInfo

func (m *ImageLocation) GetFileLocation() *FileLocation {
	if m != nil {
		return m.FileLocation
	}
	return nil
}

func (m *ImageLocation) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *ImageLocation) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ImageLocation) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// Audio location
type AudioLocation struct {
	FileLocation *FileLocation `protobuf:"bytes,1,opt,name=file_location,json=fileLocation,proto3" json:"file_location,omitempty"`
	Duration     int32         `protobuf:"varint,2,opt,name=duration,proto3" json:"duration,omitempty"`
	MimeType     string        `protobuf:"bytes,3,opt,name=mime_type,json=mimeType,proto3" json:"mime_type,omitempty"`
	FileSize     int32         `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *AudioLocation) Reset()      { *m = AudioLocation{} }
func (*AudioLocation) ProtoMessage() {}
func (*AudioLocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{2}
}
func (m *AudioLocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AudioLocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AudioLocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AudioLocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AudioLocation.Merge(m, src)
}
func (m *AudioLocation) XXX_Size() int {
	return m.Size()
}
func (m *AudioLocation) XXX_DiscardUnknown() {
	xxx_messageInfo_AudioLocation.DiscardUnknown(m)
}

var xxx_messageInfo_AudioLocation proto.InternalMessageInfo

func (m *AudioLocation) GetFileLocation() *FileLocation {
	if m != nil {
		return m.FileLocation
	}
	return nil
}

func (m *AudioLocation) GetDuration() int32 {
	if m != nil {
		return m.Duration
	}
	return 0
}

func (m *AudioLocation) GetMimeType() string {
	if m != nil {
		return m.MimeType
	}
	return ""
}

func (m *AudioLocation) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// Avatar Image
type AvatarImage struct {
	FileLocation *FileLocation `protobuf:"bytes,1,opt,name=file_location,json=fileLocation,proto3" json:"file_location,omitempty"`
	Width        int32         `protobuf:"varint,2,opt,name=width,proto3" json:"width,omitempty"`
	Height       int32         `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
	FileSize     int32         `protobuf:"varint,4,opt,name=file_size,json=fileSize,proto3" json:"file_size,omitempty"`
}

func (m *AvatarImage) Reset()      { *m = AvatarImage{} }
func (*AvatarImage) ProtoMessage() {}
func (*AvatarImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{3}
}
func (m *AvatarImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AvatarImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AvatarImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AvatarImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AvatarImage.Merge(m, src)
}
func (m *AvatarImage) XXX_Size() int {
	return m.Size()
}
func (m *AvatarImage) XXX_DiscardUnknown() {
	xxx_messageInfo_AvatarImage.DiscardUnknown(m)
}

var xxx_messageInfo_AvatarImage proto.InternalMessageInfo

func (m *AvatarImage) GetFileLocation() *FileLocation {
	if m != nil {
		return m.FileLocation
	}
	return nil
}

func (m *AvatarImage) GetWidth() int32 {
	if m != nil {
		return m.Width
	}
	return 0
}

func (m *AvatarImage) GetHeight() int32 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *AvatarImage) GetFileSize() int32 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// Avatar of User or Group
type Avatar struct {
	/// Optional small image of avatar box in 100x100
	SmallImage *AvatarImage `protobuf:"bytes,1,opt,name=small_image,json=smallImage,proto3" json:"small_image,omitempty"`
	/// Optional large image of avatar box in 200x200
	LargeImage *AvatarImage `protobuf:"bytes,2,opt,name=large_image,json=largeImage,proto3" json:"large_image,omitempty"`
	/// Optional full screen image of avatar
	FullImage *AvatarImage `protobuf:"bytes,3,opt,name=full_image,json=fullImage,proto3" json:"full_image,omitempty"`
}

func (m *Avatar) Reset()      { *m = Avatar{} }
func (*Avatar) ProtoMessage() {}
func (*Avatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{4}
}
func (m *Avatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Avatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Avatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Avatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Avatar.Merge(m, src)
}
func (m *Avatar) XXX_Size() int {
	return m.Size()
}
func (m *Avatar) XXX_DiscardUnknown() {
	xxx_messageInfo_Avatar.DiscardUnknown(m)
}

var xxx_messageInfo_Avatar proto.InternalMessageInfo

func (m *Avatar) GetSmallImage() *AvatarImage {
	if m != nil {
		return m.SmallImage
	}
	return nil
}

func (m *Avatar) GetLargeImage() *AvatarImage {
	if m != nil {
		return m.LargeImage
	}
	return nil
}

func (m *Avatar) GetFullImage() *AvatarImage {
	if m != nil {
		return m.FullImage
	}
	return nil
}

// Fast thumb of media messages. Less than 90x90 and compressed by JPEG with low quality
type FastThumb struct {
	W     int32  `protobuf:"varint,1,opt,name=w,proto3" json:"w,omitempty"`
	H     int32  `protobuf:"varint,2,opt,name=h,proto3" json:"h,omitempty"`
	Thumb []byte `protobuf:"bytes,3,opt,name=thumb,proto3" json:"thumb,omitempty"`
}

func (m *FastThumb) Reset()      { *m = FastThumb{} }
func (*FastThumb) ProtoMessage() {}
func (*FastThumb) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{5}
}
func (m *FastThumb) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FastThumb) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FastThumb.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FastThumb) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FastThumb.Merge(m, src)
}
func (m *FastThumb) XXX_Size() int {
	return m.Size()
}
func (m *FastThumb) XXX_DiscardUnknown() {
	xxx_messageInfo_FastThumb.DiscardUnknown(m)
}

var xxx_messageInfo_FastThumb proto.InternalMessageInfo

func (m *FastThumb) GetW() int32 {
	if m != nil {
		return m.W
	}
	return 0
}

func (m *FastThumb) GetH() int32 {
	if m != nil {
		return m.H
	}
	return 0
}

func (m *FastThumb) GetThumb() []byte {
	if m != nil {
		return m.Thumb
	}
	return nil
}

type Color struct {
	// Types that are valid to be assigned to Body:
	//	*Color_Rgb
	//	*Color_Predefined
	Body isColor_Body `protobuf_oneof:"body"`
}

func (m *Color) Reset()      { *m = Color{} }
func (*Color) ProtoMessage() {}
func (*Color) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{6}
}
func (m *Color) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Color) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Color.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Color) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Color.Merge(m, src)
}
func (m *Color) XXX_Size() int {
	return m.Size()
}
func (m *Color) XXX_DiscardUnknown() {
	xxx_messageInfo_Color.DiscardUnknown(m)
}

var xxx_messageInfo_Color proto.InternalMessageInfo

type isColor_Body interface {
	isColor_Body()
	Equal(interface{}) bool
	MarshalTo([]byte) (int, error)
	Size() int
}

type Color_Rgb struct {
	Rgb *RgbColor `protobuf:"bytes,1,opt,name=rgb,proto3,oneof" json:"rgb,omitempty"`
}
type Color_Predefined struct {
	Predefined *PredefinedColor `protobuf:"bytes,2,opt,name=predefined,proto3,oneof" json:"predefined,omitempty"`
}

func (*Color_Rgb) isColor_Body()        {}
func (*Color_Predefined) isColor_Body() {}

func (m *Color) GetBody() isColor_Body {
	if m != nil {
		return m.Body
	}
	return nil
}

func (m *Color) GetRgb() *RgbColor {
	if x, ok := m.GetBody().(*Color_Rgb); ok {
		return x.Rgb
	}
	return nil
}

func (m *Color) GetPredefined() *PredefinedColor {
	if x, ok := m.GetBody().(*Color_Predefined); ok {
		return x.Predefined
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Color) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Color_Rgb)(nil),
		(*Color_Predefined)(nil),
	}
}

// RGB Color
type RgbColor struct {
	Rgb int32 `protobuf:"varint,1,opt,name=rgb,proto3" json:"rgb,omitempty"`
}

func (m *RgbColor) Reset()      { *m = RgbColor{} }
func (*RgbColor) ProtoMessage() {}
func (*RgbColor) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{7}
}
func (m *RgbColor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RgbColor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RgbColor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RgbColor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RgbColor.Merge(m, src)
}
func (m *RgbColor) XXX_Size() int {
	return m.Size()
}
func (m *RgbColor) XXX_DiscardUnknown() {
	xxx_messageInfo_RgbColor.DiscardUnknown(m)
}

var xxx_messageInfo_RgbColor proto.InternalMessageInfo

func (m *RgbColor) GetRgb() int32 {
	if m != nil {
		return m.Rgb
	}
	return 0
}

// Predefined color
type PredefinedColor struct {
	Color Colors `protobuf:"varint,1,opt,name=color,proto3,enum=dialog.Colors" json:"color,omitempty"`
}

func (m *PredefinedColor) Reset()      { *m = PredefinedColor{} }
func (*PredefinedColor) ProtoMessage() {}
func (*PredefinedColor) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{8}
}
func (m *PredefinedColor) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PredefinedColor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PredefinedColor.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PredefinedColor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PredefinedColor.Merge(m, src)
}
func (m *PredefinedColor) XXX_Size() int {
	return m.Size()
}
func (m *PredefinedColor) XXX_DiscardUnknown() {
	xxx_messageInfo_PredefinedColor.DiscardUnknown(m)
}

var xxx_messageInfo_PredefinedColor proto.InternalMessageInfo

func (m *PredefinedColor) GetColor() Colors {
	if m != nil {
		return m.Color
	}
	return COLORS_UNKNOWN
}

// HTTP Header record
type HTTPHeader struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *HTTPHeader) Reset()      { *m = HTTPHeader{} }
func (*HTTPHeader) ProtoMessage() {}
func (*HTTPHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{9}
}
func (m *HTTPHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HTTPHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HTTPHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HTTPHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HTTPHeader.Merge(m, src)
}
func (m *HTTPHeader) XXX_Size() int {
	return m.Size()
}
func (m *HTTPHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_HTTPHeader.DiscardUnknown(m)
}

var xxx_messageInfo_HTTPHeader proto.InternalMessageInfo

func (m *HTTPHeader) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *HTTPHeader) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// File url description
type FileUrlDescription struct {
	FileId  int64  `protobuf:"varint,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Url     string `protobuf:"bytes,2,opt,name=url,proto3" json:"url,omitempty"`
	Timeout int32  `protobuf:"varint,3,opt,name=timeout,proto3" json:"timeout,omitempty"`
	/// Unsigned URL (used to honor web caches)
	UnsignedUrl *types.StringValue `protobuf:"bytes,4,opt,name=unsigned_url,json=unsignedUrl,proto3" json:"unsigned_url,omitempty"`
	/// Headers that is required to download files with unsigned url
	UnsignedUrlHeaders []*HTTPHeader `protobuf:"bytes,5,rep,name=unsigned_url_headers,json=unsignedUrlHeaders,proto3" json:"unsigned_url_headers,omitempty"`
}

func (m *FileUrlDescription) Reset()      { *m = FileUrlDescription{} }
func (*FileUrlDescription) ProtoMessage() {}
func (*FileUrlDescription) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{10}
}
func (m *FileUrlDescription) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileUrlDescription) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileUrlDescription.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileUrlDescription) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUrlDescription.Merge(m, src)
}
func (m *FileUrlDescription) XXX_Size() int {
	return m.Size()
}
func (m *FileUrlDescription) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUrlDescription.DiscardUnknown(m)
}

var xxx_messageInfo_FileUrlDescription proto.InternalMessageInfo

func (m *FileUrlDescription) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *FileUrlDescription) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *FileUrlDescription) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *FileUrlDescription) GetUnsignedUrl() *types.StringValue {
	if m != nil {
		return m.UnsignedUrl
	}
	return nil
}

func (m *FileUrlDescription) GetUnsignedUrlHeaders() []*HTTPHeader {
	if m != nil {
		return m.UnsignedUrlHeaders
	}
	return nil
}

// Error, that describes failure of specific file
type FileUrlError struct {
	FileId    int64                 `protobuf:"varint,1,opt,name=file_id,json=fileId,proto3" json:"file_id,omitempty"`
	Tag       FileUrlError_ErrorTag `protobuf:"varint,2,opt,name=tag,proto3,enum=dialog.FileUrlError_ErrorTag" json:"tag,omitempty"`
	Reason    string                `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	Retryable bool                  `protobuf:"varint,4,opt,name=retryable,proto3" json:"retryable,omitempty"`
}

func (m *FileUrlError) Reset()      { *m = FileUrlError{} }
func (*FileUrlError) ProtoMessage() {}
func (*FileUrlError) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{11}
}
func (m *FileUrlError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FileUrlError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FileUrlError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FileUrlError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FileUrlError.Merge(m, src)
}
func (m *FileUrlError) XXX_Size() int {
	return m.Size()
}
func (m *FileUrlError) XXX_DiscardUnknown() {
	xxx_messageInfo_FileUrlError.DiscardUnknown(m)
}

var xxx_messageInfo_FileUrlError proto.InternalMessageInfo

func (m *FileUrlError) GetFileId() int64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *FileUrlError) GetTag() FileUrlError_ErrorTag {
	if m != nil {
		return m.Tag
	}
	return FILEURLERROR_UNKNOWN
}

func (m *FileUrlError) GetReason() string {
	if m != nil {
		return m.Reason
	}
	return ""
}

func (m *FileUrlError) GetRetryable() bool {
	if m != nil {
		return m.Retryable
	}
	return false
}

// Requesting file URL for downloading
type RequestGetFileUrl struct {
	File *FileLocation `protobuf:"bytes,1,opt,name=file,proto3" json:"file,omitempty"`
}

func (m *RequestGetFileUrl) Reset()      { *m = RequestGetFileUrl{} }
func (*RequestGetFileUrl) ProtoMessage() {}
func (*RequestGetFileUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{12}
}
func (m *RequestGetFileUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetFileUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetFileUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetFileUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetFileUrl.Merge(m, src)
}
func (m *RequestGetFileUrl) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetFileUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetFileUrl.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetFileUrl proto.InternalMessageInfo

func (m *RequestGetFileUrl) GetFile() *FileLocation {
	if m != nil {
		return m.File
	}
	return nil
}

type ResponseGetFileUrl struct {
	Url                string             `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	Timeout            int32              `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	UnsignedUrl        *types.StringValue `protobuf:"bytes,3,opt,name=unsigned_url,json=unsignedUrl,proto3" json:"unsigned_url,omitempty"`
	UnsignedUrlHeaders []*HTTPHeader      `protobuf:"bytes,4,rep,name=unsigned_url_headers,json=unsignedUrlHeaders,proto3" json:"unsigned_url_headers,omitempty"`
}

func (m *ResponseGetFileUrl) Reset()      { *m = ResponseGetFileUrl{} }
func (*ResponseGetFileUrl) ProtoMessage() {}
func (*ResponseGetFileUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{13}
}
func (m *ResponseGetFileUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetFileUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetFileUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetFileUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetFileUrl.Merge(m, src)
}
func (m *ResponseGetFileUrl) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetFileUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetFileUrl.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetFileUrl proto.InternalMessageInfo

func (m *ResponseGetFileUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ResponseGetFileUrl) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

func (m *ResponseGetFileUrl) GetUnsignedUrl() *types.StringValue {
	if m != nil {
		return m.UnsignedUrl
	}
	return nil
}

func (m *ResponseGetFileUrl) GetUnsignedUrlHeaders() []*HTTPHeader {
	if m != nil {
		return m.UnsignedUrlHeaders
	}
	return nil
}

// Requesting multiple fle URL for downloading
type RequestGetFileUrls struct {
	Files []*FileLocation `protobuf:"bytes,1,rep,name=files,proto3" json:"files,omitempty"`
}

func (m *RequestGetFileUrls) Reset()      { *m = RequestGetFileUrls{} }
func (*RequestGetFileUrls) ProtoMessage() {}
func (*RequestGetFileUrls) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{14}
}
func (m *RequestGetFileUrls) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetFileUrls) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetFileUrls.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetFileUrls) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetFileUrls.Merge(m, src)
}
func (m *RequestGetFileUrls) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetFileUrls) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetFileUrls.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetFileUrls proto.InternalMessageInfo

func (m *RequestGetFileUrls) GetFiles() []*FileLocation {
	if m != nil {
		return m.Files
	}
	return nil
}

type ResponseGetFileUrls struct {
	FileUrls []*FileUrlDescription `protobuf:"bytes,1,rep,name=file_urls,json=fileUrls,proto3" json:"file_urls,omitempty"`
	Errors   []*FileUrlError       `protobuf:"bytes,2,rep,name=errors,proto3" json:"errors,omitempty"`
}

func (m *ResponseGetFileUrls) Reset()      { *m = ResponseGetFileUrls{} }
func (*ResponseGetFileUrls) ProtoMessage() {}
func (*ResponseGetFileUrls) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{15}
}
func (m *ResponseGetFileUrls) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetFileUrls) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetFileUrls.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetFileUrls) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetFileUrls.Merge(m, src)
}
func (m *ResponseGetFileUrls) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetFileUrls) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetFileUrls.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetFileUrls proto.InternalMessageInfo

func (m *ResponseGetFileUrls) GetFileUrls() []*FileUrlDescription {
	if m != nil {
		return m.FileUrls
	}
	return nil
}

func (m *ResponseGetFileUrls) GetErrors() []*FileUrlError {
	if m != nil {
		return m.Errors
	}
	return nil
}

// Get File URL Builder that allows to build file urls from client side
type RequestGetFileUrlBuilder struct {
	SupportedSignatureAlgorithms []string `protobuf:"bytes,1,rep,name=supported_signature_algorithms,json=supportedSignatureAlgorithms,proto3" json:"supported_signature_algorithms,omitempty"`
}

func (m *RequestGetFileUrlBuilder) Reset()      { *m = RequestGetFileUrlBuilder{} }
func (*RequestGetFileUrlBuilder) ProtoMessage() {}
func (*RequestGetFileUrlBuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{16}
}
func (m *RequestGetFileUrlBuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetFileUrlBuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetFileUrlBuilder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetFileUrlBuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetFileUrlBuilder.Merge(m, src)
}
func (m *RequestGetFileUrlBuilder) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetFileUrlBuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetFileUrlBuilder.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetFileUrlBuilder proto.InternalMessageInfo

func (m *RequestGetFileUrlBuilder) GetSupportedSignatureAlgorithms() []string {
	if m != nil {
		return m.SupportedSignatureAlgorithms
	}
	return nil
}

type ResponseGetFileUrlBuilder struct {
	BaseUrl         string `protobuf:"bytes,1,opt,name=base_url,json=baseUrl,proto3" json:"base_url,omitempty"`
	Algo            string `protobuf:"bytes,2,opt,name=algo,proto3" json:"algo,omitempty"`
	Seed            string `protobuf:"bytes,5,opt,name=seed,proto3" json:"seed,omitempty"`
	SignatureSecret []byte `protobuf:"bytes,3,opt,name=signature_secret,json=signatureSecret,proto3" json:"signature_secret,omitempty"`
	Timeout         int32  `protobuf:"varint,4,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *ResponseGetFileUrlBuilder) Reset()      { *m = ResponseGetFileUrlBuilder{} }
func (*ResponseGetFileUrlBuilder) ProtoMessage() {}
func (*ResponseGetFileUrlBuilder) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{17}
}
func (m *ResponseGetFileUrlBuilder) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetFileUrlBuilder) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetFileUrlBuilder.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetFileUrlBuilder) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetFileUrlBuilder.Merge(m, src)
}
func (m *ResponseGetFileUrlBuilder) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetFileUrlBuilder) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetFileUrlBuilder.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetFileUrlBuilder proto.InternalMessageInfo

func (m *ResponseGetFileUrlBuilder) GetBaseUrl() string {
	if m != nil {
		return m.BaseUrl
	}
	return ""
}

func (m *ResponseGetFileUrlBuilder) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *ResponseGetFileUrlBuilder) GetSeed() string {
	if m != nil {
		return m.Seed
	}
	return ""
}

func (m *ResponseGetFileUrlBuilder) GetSignatureSecret() []byte {
	if m != nil {
		return m.SignatureSecret
	}
	return nil
}

func (m *ResponseGetFileUrlBuilder) GetTimeout() int32 {
	if m != nil {
		return m.Timeout
	}
	return 0
}

// Requesting pload url
type RequestGetFileUploadUrl struct {
	ExpectedSize int32 `protobuf:"varint,1,opt,name=expected_size,json=expectedSize,proto3" json:"expected_size,omitempty"`
}

func (m *RequestGetFileUploadUrl) Reset()      { *m = RequestGetFileUploadUrl{} }
func (*RequestGetFileUploadUrl) ProtoMessage() {}
func (*RequestGetFileUploadUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{18}
}
func (m *RequestGetFileUploadUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetFileUploadUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetFileUploadUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetFileUploadUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetFileUploadUrl.Merge(m, src)
}
func (m *RequestGetFileUploadUrl) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetFileUploadUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetFileUploadUrl.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetFileUploadUrl proto.InternalMessageInfo

func (m *RequestGetFileUploadUrl) GetExpectedSize() int32 {
	if m != nil {
		return m.ExpectedSize
	}
	return 0
}

type ResponseGetFileUploadUrl struct {
	Url       string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
	UploadKey []byte `protobuf:"bytes,2,opt,name=upload_key,json=uploadKey,proto3" json:"upload_key,omitempty"`
}

func (m *ResponseGetFileUploadUrl) Reset()      { *m = ResponseGetFileUploadUrl{} }
func (*ResponseGetFileUploadUrl) ProtoMessage() {}
func (*ResponseGetFileUploadUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{19}
}
func (m *ResponseGetFileUploadUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetFileUploadUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetFileUploadUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetFileUploadUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetFileUploadUrl.Merge(m, src)
}
func (m *ResponseGetFileUploadUrl) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetFileUploadUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetFileUploadUrl.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetFileUploadUrl proto.InternalMessageInfo

func (m *ResponseGetFileUploadUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *ResponseGetFileUploadUrl) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

// Comminting uploaded file to storage
type RequestCommitFileUpload struct {
	UploadKey []byte `protobuf:"bytes,1,opt,name=upload_key,json=uploadKey,proto3" json:"upload_key,omitempty"`
	FileName  string `protobuf:"bytes,2,opt,name=file_name,json=fileName,proto3" json:"file_name,omitempty"`
}

func (m *RequestCommitFileUpload) Reset()      { *m = RequestCommitFileUpload{} }
func (*RequestCommitFileUpload) ProtoMessage() {}
func (*RequestCommitFileUpload) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{20}
}
func (m *RequestCommitFileUpload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCommitFileUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCommitFileUpload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCommitFileUpload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCommitFileUpload.Merge(m, src)
}
func (m *RequestCommitFileUpload) XXX_Size() int {
	return m.Size()
}
func (m *RequestCommitFileUpload) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCommitFileUpload.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCommitFileUpload proto.InternalMessageInfo

func (m *RequestCommitFileUpload) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

func (m *RequestCommitFileUpload) GetFileName() string {
	if m != nil {
		return m.FileName
	}
	return ""
}

type ResponseCommitFileUpload struct {
	UploadedFileLocation *FileLocation `protobuf:"bytes,1,opt,name=uploaded_file_location,json=uploadedFileLocation,proto3" json:"uploaded_file_location,omitempty"`
}

func (m *ResponseCommitFileUpload) Reset()      { *m = ResponseCommitFileUpload{} }
func (*ResponseCommitFileUpload) ProtoMessage() {}
func (*ResponseCommitFileUpload) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{21}
}
func (m *ResponseCommitFileUpload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseCommitFileUpload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseCommitFileUpload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseCommitFileUpload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseCommitFileUpload.Merge(m, src)
}
func (m *ResponseCommitFileUpload) XXX_Size() int {
	return m.Size()
}
func (m *ResponseCommitFileUpload) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseCommitFileUpload.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseCommitFileUpload proto.InternalMessageInfo

func (m *ResponseCommitFileUpload) GetUploadedFileLocation() *FileLocation {
	if m != nil {
		return m.UploadedFileLocation
	}
	return nil
}

// Upload file part
type RequestGetFileUploadPartUrl struct {
	PartNumber int32  `protobuf:"varint,1,opt,name=part_number,json=partNumber,proto3" json:"part_number,omitempty"`
	PartSize   int32  `protobuf:"varint,2,opt,name=part_size,json=partSize,proto3" json:"part_size,omitempty"`
	UploadKey  []byte `protobuf:"bytes,3,opt,name=upload_key,json=uploadKey,proto3" json:"upload_key,omitempty"`
}

func (m *RequestGetFileUploadPartUrl) Reset()      { *m = RequestGetFileUploadPartUrl{} }
func (*RequestGetFileUploadPartUrl) ProtoMessage() {}
func (*RequestGetFileUploadPartUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{22}
}
func (m *RequestGetFileUploadPartUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetFileUploadPartUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetFileUploadPartUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetFileUploadPartUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetFileUploadPartUrl.Merge(m, src)
}
func (m *RequestGetFileUploadPartUrl) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetFileUploadPartUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetFileUploadPartUrl.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetFileUploadPartUrl proto.InternalMessageInfo

func (m *RequestGetFileUploadPartUrl) GetPartNumber() int32 {
	if m != nil {
		return m.PartNumber
	}
	return 0
}

func (m *RequestGetFileUploadPartUrl) GetPartSize() int32 {
	if m != nil {
		return m.PartSize
	}
	return 0
}

func (m *RequestGetFileUploadPartUrl) GetUploadKey() []byte {
	if m != nil {
		return m.UploadKey
	}
	return nil
}

type ResponseGetFileUploadPartUrl struct {
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ResponseGetFileUploadPartUrl) Reset()      { *m = ResponseGetFileUploadPartUrl{} }
func (*ResponseGetFileUploadPartUrl) ProtoMessage() {}
func (*ResponseGetFileUploadPartUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_da878b320292c477, []int{23}
}
func (m *ResponseGetFileUploadPartUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetFileUploadPartUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetFileUploadPartUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetFileUploadPartUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetFileUploadPartUrl.Merge(m, src)
}
func (m *ResponseGetFileUploadPartUrl) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetFileUploadPartUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetFileUploadPartUrl.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetFileUploadPartUrl proto.InternalMessageInfo

func (m *ResponseGetFileUploadPartUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func init() {
	proto.RegisterEnum("dialog.Colors", Colors_name, Colors_value)
	proto.RegisterEnum("dialog.FileUrlError_ErrorTag", FileUrlError_ErrorTag_name, FileUrlError_ErrorTag_value)
	proto.RegisterType((*FileLocation)(nil), "dialog.FileLocation")
	proto.RegisterType((*ImageLocation)(nil), "dialog.ImageLocation")
	proto.RegisterType((*AudioLocation)(nil), "dialog.AudioLocation")
	proto.RegisterType((*AvatarImage)(nil), "dialog.AvatarImage")
	proto.RegisterType((*Avatar)(nil), "dialog.Avatar")
	proto.RegisterType((*FastThumb)(nil), "dialog.FastThumb")
	proto.RegisterType((*Color)(nil), "dialog.Color")
	proto.RegisterType((*RgbColor)(nil), "dialog.RgbColor")
	proto.RegisterType((*PredefinedColor)(nil), "dialog.PredefinedColor")
	proto.RegisterType((*HTTPHeader)(nil), "dialog.HTTPHeader")
	proto.RegisterType((*FileUrlDescription)(nil), "dialog.FileUrlDescription")
	proto.RegisterType((*FileUrlError)(nil), "dialog.FileUrlError")
	proto.RegisterType((*RequestGetFileUrl)(nil), "dialog.RequestGetFileUrl")
	proto.RegisterType((*ResponseGetFileUrl)(nil), "dialog.ResponseGetFileUrl")
	proto.RegisterType((*RequestGetFileUrls)(nil), "dialog.RequestGetFileUrls")
	proto.RegisterType((*ResponseGetFileUrls)(nil), "dialog.ResponseGetFileUrls")
	proto.RegisterType((*RequestGetFileUrlBuilder)(nil), "dialog.RequestGetFileUrlBuilder")
	proto.RegisterType((*ResponseGetFileUrlBuilder)(nil), "dialog.ResponseGetFileUrlBuilder")
	proto.RegisterType((*RequestGetFileUploadUrl)(nil), "dialog.RequestGetFileUploadUrl")
	proto.RegisterType((*ResponseGetFileUploadUrl)(nil), "dialog.ResponseGetFileUploadUrl")
	proto.RegisterType((*RequestCommitFileUpload)(nil), "dialog.RequestCommitFileUpload")
	proto.RegisterType((*ResponseCommitFileUpload)(nil), "dialog.ResponseCommitFileUpload")
	proto.RegisterType((*RequestGetFileUploadPartUrl)(nil), "dialog.RequestGetFileUploadPartUrl")
	proto.RegisterType((*ResponseGetFileUploadPartUrl)(nil), "dialog.ResponseGetFileUploadPartUrl")
}

func init() { proto.RegisterFile("media_and_files.proto", fileDescriptor_da878b320292c477) }

var fileDescriptor_da878b320292c477 = []byte{
	// 1640 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0x92, 0x22, 0x4d, 0x3e, 0x52, 0x0a, 0x3d, 0x51, 0x62, 0x9a, 0x96, 0xd7, 0xce, 0xc6,
	0x8d, 0x1d, 0xff, 0x21, 0x5d, 0x06, 0x68, 0x5a, 0x1d, 0x2a, 0xe8, 0x0f, 0xf5, 0xa7, 0x51, 0x44,
	0x77, 0x25, 0x35, 0x68, 0x2f, 0xc4, 0x90, 0x3b, 0x5a, 0xae, 0xb3, 0xdc, 0xdd, 0xcc, 0xec, 0x4a,
	0x95, 0x4f, 0x45, 0x81, 0x1e, 0x1a, 0xb4, 0x40, 0x81, 0x9e, 0x8a, 0x7e, 0x80, 0xb6, 0x5f, 0xa1,
	0x40, 0x2f, 0x3d, 0xf5, 0x56, 0x17, 0x45, 0x81, 0x1c, 0x7a, 0xa8, 0xe9, 0xa2, 0x28, 0x72, 0xca,
	0x47, 0x28, 0x66, 0x66, 0x97, 0x5c, 0xed, 0x92, 0xa6, 0x7c, 0xe8, 0x25, 0x17, 0x9b, 0x9c, 0xf7,
	0x7b, 0xef, 0xfd, 0xde, 0x6f, 0xde, 0xbc, 0x19, 0x0a, 0xde, 0x1a, 0x12, 0xc3, 0xc2, 0x5d, 0xec,
	0x18, 0xdd, 0x13, 0xcb, 0x26, 0xac, 0xe1, 0x51, 0xd7, 0x77, 0x51, 0xc1, 0xb0, 0xb0, 0xed, 0x9a,
	0x75, 0xd5, 0x74, 0x5d, 0xd3, 0x26, 0x4d, 0xb1, 0xda, 0x0b, 0x4e, 0x9a, 0x67, 0x14, 0x7b, 0x1e,
	0xa1, 0x21, 0xae, 0xbe, 0x12, 0xda, 0xb1, 0x67, 0x35, 0xb1, 0xe3, 0xb8, 0x3e, 0xf6, 0x2d, 0xd7,
	0x89, 0xac, 0x57, 0x0d, 0x72, 0x62, 0x39, 0x56, 0x7c, 0xe9, 0x2d, 0xd6, 0xc7, 0x36, 0xf6, 0x7a,
	0xcd, 0xf0, 0x7f, 0xb9, 0xac, 0x11, 0xa8, 0x6c, 0x5b, 0x36, 0xd9, 0x77, 0xfb, 0x22, 0x00, 0x7a,
	0x0f, 0xae, 0x70, 0x3a, 0x5d, 0xcb, 0xa8, 0x29, 0xb7, 0x95, 0x7b, 0xb9, 0x8d, 0xc5, 0xcf, 0xbf,
	0x7c, 0x5c, 0x82, 0x2b, 0xa7, 0x16, 0xb3, 0x7a, 0x36, 0xd1, 0x0b, 0xdc, 0xba, 0x67, 0xa0, 0x47,
	0x50, 0xc6, 0xfd, 0x3e, 0x61, 0xac, 0x3b, 0xc0, 0x6c, 0x50, 0xcb, 0x0a, 0x6c, 0xe5, 0xf3, 0x2f,
	0x1f, 0x17, 0xa1, 0x60, 0x60, 0xc7, 0x24, 0x54, 0x07, 0x09, 0xd8, 0xc5, 0x6c, 0xa0, 0xfd, 0x4d,
	0x81, 0xc5, 0xbd, 0x21, 0x36, 0x27, 0x89, 0x76, 0x61, 0x51, 0x24, 0xb2, 0xc3, 0x05, 0x91, 0xae,
	0xdc, 0x5a, 0x6e, 0x48, 0x01, 0x1a, 0x71, 0x56, 0x49, 0x12, 0x95, 0x93, 0x38, 0xe5, 0x77, 0x21,
	0x7f, 0x66, 0x19, 0xbe, 0x24, 0x91, 0x4f, 0x62, 0xa5, 0x0d, 0x7d, 0x03, 0x0a, 0x03, 0x62, 0x99,
	0x03, 0xbf, 0x96, 0x9b, 0x86, 0x0a, 0x8d, 0xe8, 0x3e, 0x94, 0x04, 0x2b, 0x66, 0x3d, 0x23, 0xb5,
	0x85, 0x69, 0xc8, 0x22, 0xb7, 0x1f, 0x5a, 0xcf, 0x88, 0xf6, 0x4f, 0x05, 0x16, 0xd7, 0x03, 0xc3,
	0x72, 0xff, 0x0f, 0x35, 0xbd, 0x0f, 0x45, 0x23, 0xa0, 0x32, 0xc8, 0xd4, 0xb2, 0xc6, 0x66, 0x4e,
	0x79, 0x68, 0x0d, 0x49, 0xd7, 0x3f, 0xf7, 0x88, 0x28, 0xae, 0x94, 0xc2, 0x72, 0xfb, 0xd1, 0xb9,
	0x47, 0x5e, 0xab, 0xbc, 0xbf, 0x2a, 0x50, 0x5e, 0x3f, 0xc5, 0x3e, 0xa6, 0x62, 0xe3, 0xbe, 0x06,
	0x1b, 0xf6, 0x0f, 0x05, 0x0a, 0xb2, 0x22, 0xb4, 0x09, 0x65, 0x36, 0xc4, 0xb6, 0xdd, 0xb5, 0x78,
	0x6d, 0x61, 0x29, 0x6f, 0x46, 0xa5, 0xc4, 0xca, 0x8e, 0xa2, 0xf5, 0xdd, 0xa1, 0x87, 0xfb, 0xbe,
	0x0e, 0xc2, 0x4d, 0x2a, 0xb2, 0x09, 0x65, 0x1b, 0x53, 0x93, 0x84, 0x41, 0xb2, 0x97, 0x0f, 0x22,
	0xdc, 0x64, 0x90, 0x75, 0x80, 0x93, 0x60, 0x4c, 0x24, 0x77, 0xe9, 0x18, 0x25, 0xee, 0x25, 0x2c,
	0xda, 0x53, 0x28, 0x6d, 0x63, 0xe6, 0x1f, 0x0d, 0x82, 0x61, 0x0f, 0xdd, 0x00, 0xe5, 0x4c, 0xd4,
	0x93, 0x12, 0x42, 0x39, 0xe3, 0xc6, 0x19, 0xaa, 0x2b, 0x03, 0xbe, 0x2d, 0x3e, 0x0f, 0x21, 0x48,
	0x54, 0x92, 0xf9, 0xa4, 0x4d, 0xf3, 0x20, 0xbf, 0xe9, 0xda, 0x2e, 0x45, 0x77, 0x20, 0x47, 0xcd,
	0x5e, 0xa8, 0x5c, 0x35, 0x22, 0xac, 0x9b, 0x3d, 0x61, 0xde, 0xcd, 0xe8, 0xdc, 0x8c, 0xbe, 0x03,
	0xe0, 0x51, 0x22, 0xa6, 0x11, 0x31, 0x42, 0x85, 0xae, 0x45, 0xe0, 0x27, 0x63, 0x4b, 0xe4, 0x13,
	0x03, 0x6f, 0x14, 0x60, 0xa1, 0xe7, 0x1a, 0xe7, 0xda, 0x03, 0x28, 0x46, 0x51, 0xd1, 0xad, 0x49,
	0xd2, 0x54, 0x05, 0xdc, 0xa2, 0xb5, 0xe1, 0x8d, 0x44, 0x54, 0xd4, 0x82, 0x7c, 0x9f, 0x7f, 0x10,
	0x5e, 0x4b, 0xad, 0xa5, 0x28, 0xbb, 0xb0, 0xb2, 0x68, 0x66, 0x0d, 0x2c, 0xc3, 0x20, 0x8e, 0x2e,
	0xa1, 0x9a, 0x0e, 0xb0, 0x7b, 0x74, 0xf4, 0x64, 0x97, 0x60, 0x83, 0x88, 0xac, 0x9f, 0x92, 0x73,
	0xe1, 0x9f, 0x3a, 0x5b, 0xdc, 0xc2, 0x95, 0x3b, 0xc5, 0x76, 0x20, 0x5b, 0x20, 0x05, 0x91, 0x36,
	0xed, 0x0f, 0x59, 0x40, 0xfc, 0x8c, 0x1c, 0x53, 0x7b, 0x8b, 0xb0, 0x3e, 0xb5, 0xbc, 0xd7, 0x1a,
	0xb8, 0xb7, 0x20, 0x17, 0x50, 0x7b, 0x7a, 0x06, 0x6e, 0x41, 0x77, 0xe1, 0x8a, 0x6f, 0x0d, 0x89,
	0x1b, 0xcc, 0x38, 0x31, 0x91, 0x15, 0x7d, 0x0c, 0x95, 0xc0, 0x61, 0x96, 0xe9, 0x10, 0xa3, 0xcb,
	0x43, 0x2e, 0x88, 0x5d, 0x59, 0x69, 0xc8, 0x1b, 0xa5, 0x11, 0xdd, 0x38, 0x8d, 0x43, 0x9f, 0x5a,
	0x8e, 0xf9, 0x03, 0x4e, 0x3e, 0xa1, 0x52, 0x39, 0xf2, 0x3f, 0xa6, 0x36, 0xd2, 0x61, 0x39, 0x1e,
	0xae, 0x3b, 0x10, 0xa2, 0xb1, 0x5a, 0xfe, 0x76, 0xee, 0x5e, 0xb9, 0x85, 0x22, 0xb9, 0x27, 0x7a,
	0x26, 0x82, 0xa1, 0x58, 0x30, 0x09, 0x60, 0xda, 0x1f, 0xb3, 0xf2, 0x5a, 0x3a, 0xa6, 0x76, 0x9b,
	0x52, 0x97, 0x5e, 0x5a, 0xa5, 0xef, 0x42, 0xce, 0xc7, 0xa6, 0x50, 0x69, 0xa9, 0x75, 0x33, 0x3e,
	0x9a, 0xa2, 0x50, 0x0d, 0xf1, 0xef, 0x11, 0x36, 0x53, 0x22, 0xfa, 0xd8, 0xe4, 0x53, 0x87, 0x12,
	0xcc, 0x5c, 0x67, 0xfa, 0x24, 0x0d, 0x8d, 0xe8, 0x01, 0x94, 0x28, 0xf1, 0xe9, 0x39, 0xee, 0xd9,
	0x72, 0xea, 0x14, 0x93, 0xc8, 0x89, 0x5d, 0x73, 0xa0, 0x18, 0xe5, 0x44, 0x35, 0x58, 0xde, 0xde,
	0xdb, 0x6f, 0x1f, 0xeb, 0xfb, 0x6d, 0x5d, 0xef, 0xe8, 0xdd, 0xe3, 0x83, 0x8f, 0x0e, 0x3a, 0x9f,
	0x1c, 0x54, 0x33, 0x48, 0x85, 0xfa, 0x05, 0xcb, 0xe1, 0x51, 0x47, 0x5f, 0xdf, 0x69, 0x77, 0xc5,
	0xb7, 0xaa, 0x82, 0xee, 0xc1, 0x9d, 0xa9, 0xf6, 0xed, 0x8e, 0xbe, 0xb1, 0xb7, 0xb5, 0xd5, 0x3e,
	0x08, 0x91, 0x59, 0xed, 0x29, 0x5c, 0xd5, 0xc9, 0x67, 0x01, 0x61, 0xfe, 0x0e, 0xf1, 0xc3, 0xd2,
	0xd1, 0x87, 0xb0, 0xc0, 0x25, 0x7a, 0x9d, 0xa1, 0x2d, 0x1c, 0x56, 0x57, 0x46, 0x6b, 0xd7, 0xe1,
	0x9a, 0x35, 0x6c, 0x18, 0xb6, 0xd9, 0x30, 0xa9, 0xd7, 0x6f, 0xec, 0x50, 0xaf, 0x1f, 0x26, 0xd0,
	0xfe, 0xa3, 0x00, 0xd2, 0x09, 0xf3, 0x5c, 0x87, 0x91, 0x58, 0xb6, 0xaa, 0x6c, 0x56, 0x71, 0x62,
	0x64, 0x77, 0xd6, 0x26, 0xdd, 0x29, 0xe6, 0xcf, 0xa4, 0x1d, 0xd7, 0x12, 0xed, 0x98, 0x9b, 0xdf,
	0x8e, 0x17, 0x1b, 0x70, 0x6b, 0x46, 0x03, 0x2e, 0xcc, 0x6a, 0xc0, 0x69, 0x2d, 0xb7, 0x7a, 0x73,
	0xb4, 0x56, 0x87, 0x5a, 0xba, 0x4e, 0x59, 0x9b, 0x66, 0xf3, 0x3a, 0x13, 0xa2, 0x32, 0xf4, 0x6d,
	0xc8, 0x8b, 0xc7, 0x5b, 0x4d, 0x11, 0xb9, 0xa6, 0xcb, 0x9a, 0x98, 0x30, 0xc2, 0x61, 0x8e, 0xac,
	0xbf, 0x55, 0xe0, 0xcd, 0xb4, 0xac, 0x0c, 0x7d, 0x18, 0xde, 0x76, 0x01, 0xb5, 0xa3, 0x9c, 0xf5,
	0x44, 0x93, 0xc7, 0x66, 0x8b, 0xbc, 0xfa, 0x84, 0xe3, 0x43, 0x28, 0x10, 0xde, 0x83, 0xac, 0x96,
	0x4d, 0x33, 0x8d, 0x8e, 0x86, 0x1e, 0x62, 0xe6, 0x69, 0xf1, 0x0b, 0x05, 0x6a, 0x29, 0x31, 0x36,
	0x02, 0xcb, 0xe6, 0xc3, 0x52, 0x07, 0x95, 0x05, 0x9e, 0xe7, 0x52, 0x9f, 0x18, 0x5d, 0xae, 0x32,
	0xf6, 0x03, 0x4a, 0xba, 0xd8, 0x36, 0x5d, 0x6a, 0xf9, 0x83, 0xa1, 0xe4, 0x5d, 0x4a, 0xa8, 0xb2,
	0x32, 0xf6, 0x39, 0x8c, 0x5c, 0xd6, 0xc7, 0x1e, 0x73, 0xc4, 0xfa, 0xb3, 0x02, 0xd7, 0xd3, 0x62,
	0x45, 0x7c, 0xae, 0x43, 0xb1, 0x87, 0x99, 0x90, 0x2c, 0xec, 0xc7, 0x2b, 0xfc, 0x3b, 0x6f, 0x1c,
	0x04, 0x0b, 0x9c, 0x96, 0x9c, 0xa9, 0xba, 0xf8, 0xcc, 0xd7, 0x18, 0x21, 0x46, 0x2d, 0x2f, 0xd7,
	0xf8, 0x67, 0xf4, 0x3e, 0x54, 0x27, 0x85, 0x30, 0xd2, 0xa7, 0x44, 0x8e, 0xd8, 0x8a, 0xfe, 0xc6,
	0x78, 0xfd, 0x50, 0x2c, 0xc7, 0xdb, 0x7c, 0xe1, 0x42, 0x9b, 0xcf, 0xd3, 0xf4, 0x53, 0xb8, 0x96,
	0x90, 0xd4, 0xb3, 0x5d, 0x2c, 0xfa, 0xbb, 0x05, 0x8b, 0xe4, 0xc7, 0x1e, 0xe9, 0x4b, 0x41, 0x9f,
	0x91, 0xe9, 0xd7, 0x5f, 0x25, 0xc2, 0xf0, 0xa7, 0xce, 0x1c, 0xc5, 0x9e, 0xf2, 0xfd, 0xbb, 0x28,
	0xd8, 0x38, 0x5b, 0xfa, 0xe8, 0xde, 0x04, 0x08, 0x84, 0xb9, 0xcb, 0x6f, 0xc1, 0xac, 0x28, 0xbc,
	0x24, 0x57, 0x3e, 0x22, 0xe7, 0xf3, 0x0a, 0x63, 0xe3, 0xc2, 0x36, 0xdd, 0xe1, 0xd0, 0x8a, 0x65,
	0x4b, 0x04, 0x56, 0x12, 0x81, 0xd1, 0x8d, 0xb0, 0xd9, 0x1d, 0x3c, 0x0c, 0x6f, 0x56, 0xd9, 0xd0,
	0x07, 0x78, 0x38, 0xaf, 0xc0, 0x9f, 0x29, 0x93, 0x0a, 0x53, 0x69, 0xbf, 0x07, 0x6f, 0xcb, 0x24,
	0x44, 0xfe, 0xf4, 0xba, 0xd4, 0x8b, 0x56, 0x5f, 0x8e, 0x7c, 0xe2, 0xab, 0xf3, 0x8a, 0xff, 0x9d,
	0x02, 0x37, 0xa6, 0x6d, 0xeb, 0x13, 0x4c, 0x7d, 0x2e, 0xf6, 0x2d, 0x28, 0x7b, 0x98, 0xfa, 0x5d,
	0x27, 0x18, 0xf6, 0x88, 0x7c, 0xa1, 0xe4, 0x75, 0xe0, 0x4b, 0x07, 0x62, 0x85, 0x6b, 0x20, 0x00,
	0x62, 0xdf, 0xe5, 0xe0, 0x2c, 0xf2, 0x05, 0xbe, 0xc9, 0xe8, 0xe1, 0x05, 0xfd, 0xa6, 0xbe, 0xda,
	0x62, 0xfb, 0xf4, 0x6a, 0xc5, 0x3a, 0xb0, 0x32, 0xb5, 0x25, 0x22, 0xa6, 0xa9, 0xb6, 0x98, 0x53,
	0xfa, 0xfd, 0xef, 0x43, 0x41, 0xbe, 0xb0, 0x10, 0x82, 0xa5, 0xcd, 0xce, 0x7e, 0x47, 0x3f, 0x8c,
	0xdd, 0x76, 0x4b, 0x00, 0xe1, 0x9a, 0xde, 0xde, 0xaa, 0x2a, 0xe8, 0x2a, 0x2c, 0x86, 0xdf, 0x7f,
	0xd8, 0xde, 0xdf, 0xef, 0x7c, 0x52, 0xcd, 0xa2, 0x2a, 0x54, 0xc2, 0xa5, 0x1d, 0xbd, 0xdd, 0x3e,
	0xa8, 0xe6, 0x5a, 0x7f, 0x2a, 0xc0, 0xe2, 0xc7, 0xfc, 0x57, 0xf3, 0xba, 0x23, 0x76, 0x81, 0xa1,
	0xcf, 0x00, 0x62, 0xb7, 0xce, 0xf5, 0xf1, 0x2b, 0x34, 0x39, 0x9c, 0xea, 0xf5, 0x89, 0x29, 0x39,
	0x28, 0xb4, 0x87, 0x3f, 0xfd, 0xfb, 0xbf, 0x7f, 0x9d, 0x7d, 0x4f, 0x7b, 0xa7, 0x79, 0xfa, 0xcd,
	0x26, 0x2f, 0xa4, 0x79, 0x21, 0x49, 0x73, 0x02, 0x5d, 0x55, 0xee, 0xa3, 0x00, 0xca, 0xf1, 0x89,
	0x5c, 0x9f, 0x99, 0x93, 0xd5, 0x6f, 0xcc, 0x4e, 0xca, 0xb4, 0x47, 0x22, 0xeb, 0x5d, 0x4d, 0x9b,
	0x9b, 0x95, 0xf1, 0xb4, 0xbf, 0x54, 0xe0, 0x6a, 0x7a, 0xb8, 0xdd, 0x9e, 0x99, 0x3d, 0x44, 0xd4,
	0xdf, 0x99, 0xcd, 0x21, 0x84, 0x68, 0x1f, 0x08, 0x26, 0x8f, 0xb4, 0x7b, 0x73, 0x99, 0x84, 0x1e,
	0x9c, 0xcf, 0xcf, 0x15, 0xa8, 0xa6, 0x66, 0xc7, 0xad, 0x19, 0x74, 0x22, 0x40, 0xfd, 0xf6, 0x2c,
	0x36, 0x11, 0x42, 0x6b, 0x09, 0x32, 0x0f, 0xb5, 0xbb, 0x73, 0xc8, 0x44, 0x0e, 0x11, 0x97, 0xd4,
	0x29, 0x4f, 0x72, 0x49, 0x02, 0xd2, 0x5c, 0x92, 0x88, 0xb9, 0x5c, 0x92, 0x0e, 0x9c, 0xcb, 0x6f,
	0x14, 0x58, 0x9e, 0x7a, 0x80, 0xde, 0x7d, 0x95, 0x36, 0x21, 0xa8, 0x7e, 0xe7, 0x95, 0xfa, 0x84,
	0x28, 0xed, 0x5b, 0x82, 0xd7, 0x63, 0xed, 0xc1, 0x65, 0x34, 0x0a, 0x9d, 0x56, 0x95, 0xfb, 0x1b,
	0xc7, 0xa3, 0xb5, 0xb7, 0x61, 0x39, 0x7e, 0x62, 0x19, 0xa1, 0xa7, 0x56, 0x9f, 0xb0, 0xe7, 0x2f,
	0xd4, 0xcc, 0x17, 0x2f, 0xd4, 0xcc, 0x57, 0x2f, 0x54, 0xe5, 0x27, 0x23, 0x55, 0xf9, 0xfd, 0x48,
	0x55, 0xfe, 0x32, 0x52, 0x95, 0xe7, 0x23, 0x55, 0xf9, 0xd7, 0x48, 0x55, 0xfe, 0x3b, 0x52, 0x33,
	0x5f, 0x8d, 0x54, 0xe5, 0x57, 0x2f, 0xd5, 0xcc, 0xf3, 0x97, 0x6a, 0xe6, 0x8b, 0x97, 0x6a, 0xe6,
	0x47, 0xe1, 0x9f, 0xaa, 0x7a, 0x05, 0xf1, 0x44, 0xfb, 0xe0, 0x7f, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x3c, 0x85, 0xda, 0x81, 0xd2, 0x12, 0x00, 0x00,
}

func (x Colors) String() string {
	s, ok := Colors_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x FileUrlError_ErrorTag) String() string {
	s, ok := FileUrlError_ErrorTag_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *FileLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileLocation)
	if !ok {
		that2, ok := that.(FileLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileId != that1.FileId {
		return false
	}
	if this.AccessHash != that1.AccessHash {
		return false
	}
	return true
}
func (this *ImageLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ImageLocation)
	if !ok {
		that2, ok := that.(ImageLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileLocation.Equal(that1.FileLocation) {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.FileSize != that1.FileSize {
		return false
	}
	return true
}
func (this *AudioLocation) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AudioLocation)
	if !ok {
		that2, ok := that.(AudioLocation)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileLocation.Equal(that1.FileLocation) {
		return false
	}
	if this.Duration != that1.Duration {
		return false
	}
	if this.MimeType != that1.MimeType {
		return false
	}
	if this.FileSize != that1.FileSize {
		return false
	}
	return true
}
func (this *AvatarImage) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AvatarImage)
	if !ok {
		that2, ok := that.(AvatarImage)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.FileLocation.Equal(that1.FileLocation) {
		return false
	}
	if this.Width != that1.Width {
		return false
	}
	if this.Height != that1.Height {
		return false
	}
	if this.FileSize != that1.FileSize {
		return false
	}
	return true
}
func (this *Avatar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Avatar)
	if !ok {
		that2, ok := that.(Avatar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SmallImage.Equal(that1.SmallImage) {
		return false
	}
	if !this.LargeImage.Equal(that1.LargeImage) {
		return false
	}
	if !this.FullImage.Equal(that1.FullImage) {
		return false
	}
	return true
}
func (this *FastThumb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FastThumb)
	if !ok {
		that2, ok := that.(FastThumb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.W != that1.W {
		return false
	}
	if this.H != that1.H {
		return false
	}
	if !bytes.Equal(this.Thumb, that1.Thumb) {
		return false
	}
	return true
}
func (this *Color) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Color)
	if !ok {
		that2, ok := that.(Color)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if that1.Body == nil {
		if this.Body != nil {
			return false
		}
	} else if this.Body == nil {
		return false
	} else if !this.Body.Equal(that1.Body) {
		return false
	}
	return true
}
func (this *Color_Rgb) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Color_Rgb)
	if !ok {
		that2, ok := that.(Color_Rgb)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Rgb.Equal(that1.Rgb) {
		return false
	}
	return true
}
func (this *Color_Predefined) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Color_Predefined)
	if !ok {
		that2, ok := that.(Color_Predefined)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Predefined.Equal(that1.Predefined) {
		return false
	}
	return true
}
func (this *RgbColor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RgbColor)
	if !ok {
		that2, ok := that.(RgbColor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rgb != that1.Rgb {
		return false
	}
	return true
}
func (this *PredefinedColor) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*PredefinedColor)
	if !ok {
		that2, ok := that.(PredefinedColor)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Color != that1.Color {
		return false
	}
	return true
}
func (this *HTTPHeader) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*HTTPHeader)
	if !ok {
		that2, ok := that.(HTTPHeader)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Key != that1.Key {
		return false
	}
	if this.Value != that1.Value {
		return false
	}
	return true
}
func (this *FileUrlDescription) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileUrlDescription)
	if !ok {
		that2, ok := that.(FileUrlDescription)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileId != that1.FileId {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.UnsignedUrl.Equal(that1.UnsignedUrl) {
		return false
	}
	if len(this.UnsignedUrlHeaders) != len(that1.UnsignedUrlHeaders) {
		return false
	}
	for i := range this.UnsignedUrlHeaders {
		if !this.UnsignedUrlHeaders[i].Equal(that1.UnsignedUrlHeaders[i]) {
			return false
		}
	}
	return true
}
func (this *FileUrlError) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*FileUrlError)
	if !ok {
		that2, ok := that.(FileUrlError)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.FileId != that1.FileId {
		return false
	}
	if this.Tag != that1.Tag {
		return false
	}
	if this.Reason != that1.Reason {
		return false
	}
	if this.Retryable != that1.Retryable {
		return false
	}
	return true
}
func (this *RequestGetFileUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetFileUrl)
	if !ok {
		that2, ok := that.(RequestGetFileUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.File.Equal(that1.File) {
		return false
	}
	return true
}
func (this *ResponseGetFileUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetFileUrl)
	if !ok {
		that2, ok := that.(ResponseGetFileUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	if !this.UnsignedUrl.Equal(that1.UnsignedUrl) {
		return false
	}
	if len(this.UnsignedUrlHeaders) != len(that1.UnsignedUrlHeaders) {
		return false
	}
	for i := range this.UnsignedUrlHeaders {
		if !this.UnsignedUrlHeaders[i].Equal(that1.UnsignedUrlHeaders[i]) {
			return false
		}
	}
	return true
}
func (this *RequestGetFileUrls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetFileUrls)
	if !ok {
		that2, ok := that.(RequestGetFileUrls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Files) != len(that1.Files) {
		return false
	}
	for i := range this.Files {
		if !this.Files[i].Equal(that1.Files[i]) {
			return false
		}
	}
	return true
}
func (this *ResponseGetFileUrls) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetFileUrls)
	if !ok {
		that2, ok := that.(ResponseGetFileUrls)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.FileUrls) != len(that1.FileUrls) {
		return false
	}
	for i := range this.FileUrls {
		if !this.FileUrls[i].Equal(that1.FileUrls[i]) {
			return false
		}
	}
	if len(this.Errors) != len(that1.Errors) {
		return false
	}
	for i := range this.Errors {
		if !this.Errors[i].Equal(that1.Errors[i]) {
			return false
		}
	}
	return true
}
func (this *RequestGetFileUrlBuilder) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetFileUrlBuilder)
	if !ok {
		that2, ok := that.(RequestGetFileUrlBuilder)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.SupportedSignatureAlgorithms) != len(that1.SupportedSignatureAlgorithms) {
		return false
	}
	for i := range this.SupportedSignatureAlgorithms {
		if this.SupportedSignatureAlgorithms[i] != that1.SupportedSignatureAlgorithms[i] {
			return false
		}
	}
	return true
}
func (this *ResponseGetFileUrlBuilder) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetFileUrlBuilder)
	if !ok {
		that2, ok := that.(ResponseGetFileUrlBuilder)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.BaseUrl != that1.BaseUrl {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if this.Seed != that1.Seed {
		return false
	}
	if !bytes.Equal(this.SignatureSecret, that1.SignatureSecret) {
		return false
	}
	if this.Timeout != that1.Timeout {
		return false
	}
	return true
}
func (this *RequestGetFileUploadUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetFileUploadUrl)
	if !ok {
		that2, ok := that.(RequestGetFileUploadUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.ExpectedSize != that1.ExpectedSize {
		return false
	}
	return true
}
func (this *ResponseGetFileUploadUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetFileUploadUrl)
	if !ok {
		that2, ok := that.(ResponseGetFileUploadUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	if !bytes.Equal(this.UploadKey, that1.UploadKey) {
		return false
	}
	return true
}
func (this *RequestCommitFileUpload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestCommitFileUpload)
	if !ok {
		that2, ok := that.(RequestCommitFileUpload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !bytes.Equal(this.UploadKey, that1.UploadKey) {
		return false
	}
	if this.FileName != that1.FileName {
		return false
	}
	return true
}
func (this *ResponseCommitFileUpload) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCommitFileUpload)
	if !ok {
		that2, ok := that.(ResponseCommitFileUpload)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.UploadedFileLocation.Equal(that1.UploadedFileLocation) {
		return false
	}
	return true
}
func (this *RequestGetFileUploadPartUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetFileUploadPartUrl)
	if !ok {
		that2, ok := that.(RequestGetFileUploadPartUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.PartNumber != that1.PartNumber {
		return false
	}
	if this.PartSize != that1.PartSize {
		return false
	}
	if !bytes.Equal(this.UploadKey, that1.UploadKey) {
		return false
	}
	return true
}
func (this *ResponseGetFileUploadPartUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetFileUploadPartUrl)
	if !ok {
		that2, ok := that.(ResponseGetFileUploadPartUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *FileLocation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.FileLocation{")
	s = append(s, "FileId: "+fmt.Sprintf("%#v", this.FileId)+",\n")
	s = append(s, "AccessHash: "+fmt.Sprintf("%#v", this.AccessHash)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ImageLocation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.ImageLocation{")
	if this.FileLocation != nil {
		s = append(s, "FileLocation: "+fmt.Sprintf("%#v", this.FileLocation)+",\n")
	}
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "FileSize: "+fmt.Sprintf("%#v", this.FileSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AudioLocation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.AudioLocation{")
	if this.FileLocation != nil {
		s = append(s, "FileLocation: "+fmt.Sprintf("%#v", this.FileLocation)+",\n")
	}
	s = append(s, "Duration: "+fmt.Sprintf("%#v", this.Duration)+",\n")
	s = append(s, "MimeType: "+fmt.Sprintf("%#v", this.MimeType)+",\n")
	s = append(s, "FileSize: "+fmt.Sprintf("%#v", this.FileSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AvatarImage) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.AvatarImage{")
	if this.FileLocation != nil {
		s = append(s, "FileLocation: "+fmt.Sprintf("%#v", this.FileLocation)+",\n")
	}
	s = append(s, "Width: "+fmt.Sprintf("%#v", this.Width)+",\n")
	s = append(s, "Height: "+fmt.Sprintf("%#v", this.Height)+",\n")
	s = append(s, "FileSize: "+fmt.Sprintf("%#v", this.FileSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Avatar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.Avatar{")
	if this.SmallImage != nil {
		s = append(s, "SmallImage: "+fmt.Sprintf("%#v", this.SmallImage)+",\n")
	}
	if this.LargeImage != nil {
		s = append(s, "LargeImage: "+fmt.Sprintf("%#v", this.LargeImage)+",\n")
	}
	if this.FullImage != nil {
		s = append(s, "FullImage: "+fmt.Sprintf("%#v", this.FullImage)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FastThumb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.FastThumb{")
	s = append(s, "W: "+fmt.Sprintf("%#v", this.W)+",\n")
	s = append(s, "H: "+fmt.Sprintf("%#v", this.H)+",\n")
	s = append(s, "Thumb: "+fmt.Sprintf("%#v", this.Thumb)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Color) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.Color{")
	if this.Body != nil {
		s = append(s, "Body: "+fmt.Sprintf("%#v", this.Body)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Color_Rgb) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dialog.Color_Rgb{` +
		`Rgb:` + fmt.Sprintf("%#v", this.Rgb) + `}`}, ", ")
	return s
}
func (this *Color_Predefined) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&dialog.Color_Predefined{` +
		`Predefined:` + fmt.Sprintf("%#v", this.Predefined) + `}`}, ", ")
	return s
}
func (this *RgbColor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RgbColor{")
	s = append(s, "Rgb: "+fmt.Sprintf("%#v", this.Rgb)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *PredefinedColor) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.PredefinedColor{")
	s = append(s, "Color: "+fmt.Sprintf("%#v", this.Color)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *HTTPHeader) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.HTTPHeader{")
	s = append(s, "Key: "+fmt.Sprintf("%#v", this.Key)+",\n")
	s = append(s, "Value: "+fmt.Sprintf("%#v", this.Value)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileUrlDescription) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.FileUrlDescription{")
	s = append(s, "FileId: "+fmt.Sprintf("%#v", this.FileId)+",\n")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.UnsignedUrl != nil {
		s = append(s, "UnsignedUrl: "+fmt.Sprintf("%#v", this.UnsignedUrl)+",\n")
	}
	if this.UnsignedUrlHeaders != nil {
		s = append(s, "UnsignedUrlHeaders: "+fmt.Sprintf("%#v", this.UnsignedUrlHeaders)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *FileUrlError) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.FileUrlError{")
	s = append(s, "FileId: "+fmt.Sprintf("%#v", this.FileId)+",\n")
	s = append(s, "Tag: "+fmt.Sprintf("%#v", this.Tag)+",\n")
	s = append(s, "Reason: "+fmt.Sprintf("%#v", this.Reason)+",\n")
	s = append(s, "Retryable: "+fmt.Sprintf("%#v", this.Retryable)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetFileUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestGetFileUrl{")
	if this.File != nil {
		s = append(s, "File: "+fmt.Sprintf("%#v", this.File)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetFileUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.ResponseGetFileUrl{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	if this.UnsignedUrl != nil {
		s = append(s, "UnsignedUrl: "+fmt.Sprintf("%#v", this.UnsignedUrl)+",\n")
	}
	if this.UnsignedUrlHeaders != nil {
		s = append(s, "UnsignedUrlHeaders: "+fmt.Sprintf("%#v", this.UnsignedUrlHeaders)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetFileUrls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestGetFileUrls{")
	if this.Files != nil {
		s = append(s, "Files: "+fmt.Sprintf("%#v", this.Files)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetFileUrls) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.ResponseGetFileUrls{")
	if this.FileUrls != nil {
		s = append(s, "FileUrls: "+fmt.Sprintf("%#v", this.FileUrls)+",\n")
	}
	if this.Errors != nil {
		s = append(s, "Errors: "+fmt.Sprintf("%#v", this.Errors)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetFileUrlBuilder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestGetFileUrlBuilder{")
	s = append(s, "SupportedSignatureAlgorithms: "+fmt.Sprintf("%#v", this.SupportedSignatureAlgorithms)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetFileUrlBuilder) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.ResponseGetFileUrlBuilder{")
	s = append(s, "BaseUrl: "+fmt.Sprintf("%#v", this.BaseUrl)+",\n")
	s = append(s, "Algo: "+fmt.Sprintf("%#v", this.Algo)+",\n")
	s = append(s, "Seed: "+fmt.Sprintf("%#v", this.Seed)+",\n")
	s = append(s, "SignatureSecret: "+fmt.Sprintf("%#v", this.SignatureSecret)+",\n")
	s = append(s, "Timeout: "+fmt.Sprintf("%#v", this.Timeout)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetFileUploadUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestGetFileUploadUrl{")
	s = append(s, "ExpectedSize: "+fmt.Sprintf("%#v", this.ExpectedSize)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetFileUploadUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.ResponseGetFileUploadUrl{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "UploadKey: "+fmt.Sprintf("%#v", this.UploadKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestCommitFileUpload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestCommitFileUpload{")
	s = append(s, "UploadKey: "+fmt.Sprintf("%#v", this.UploadKey)+",\n")
	s = append(s, "FileName: "+fmt.Sprintf("%#v", this.FileName)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseCommitFileUpload) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseCommitFileUpload{")
	if this.UploadedFileLocation != nil {
		s = append(s, "UploadedFileLocation: "+fmt.Sprintf("%#v", this.UploadedFileLocation)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetFileUploadPartUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.RequestGetFileUploadPartUrl{")
	s = append(s, "PartNumber: "+fmt.Sprintf("%#v", this.PartNumber)+",\n")
	s = append(s, "PartSize: "+fmt.Sprintf("%#v", this.PartSize)+",\n")
	s = append(s, "UploadKey: "+fmt.Sprintf("%#v", this.UploadKey)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetFileUploadPartUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseGetFileUploadPartUrl{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringMediaAndFiles(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// MediaAndFilesClient is the client API for MediaAndFiles service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type MediaAndFilesClient interface {
	/// Get link to file for downloading
	GetFileUrl(ctx context.Context, in *RequestGetFileUrl, opts ...grpc.CallOption) (*ResponseGetFileUrl, error)
	/// Get link to files for downloading
	GetFileUrls(ctx context.Context, in *RequestGetFileUrls, opts ...grpc.CallOption) (*ResponseGetFileUrls, error)
	/// Create builder for file url
	GetFileUrlBuilder(ctx context.Context, in *RequestGetFileUrlBuilder, opts ...grpc.CallOption) (*ResponseGetFileUrlBuilder, error)
	/// Get url for uploading
	GetFileUploadUrl(ctx context.Context, in *RequestGetFileUploadUrl, opts ...grpc.CallOption) (*ResponseGetFileUploadUrl, error)
	/// Finish uploading a file
	CommitFileUpload(ctx context.Context, in *RequestCommitFileUpload, opts ...grpc.CallOption) (*ResponseCommitFileUpload, error)
	/// Get url for uploading chunk of file
	GetFileUploadPartUrl(ctx context.Context, in *RequestGetFileUploadPartUrl, opts ...grpc.CallOption) (*ResponseGetFileUploadPartUrl, error)
}

type mediaAndFilesClient struct {
	cc *grpc.ClientConn
}

func NewMediaAndFilesClient(cc *grpc.ClientConn) MediaAndFilesClient {
	return &mediaAndFilesClient{cc}
}

func (c *mediaAndFilesClient) GetFileUrl(ctx context.Context, in *RequestGetFileUrl, opts ...grpc.CallOption) (*ResponseGetFileUrl, error) {
	out := new(ResponseGetFileUrl)
	err := c.cc.Invoke(ctx, "/dialog.MediaAndFiles/GetFileUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaAndFilesClient) GetFileUrls(ctx context.Context, in *RequestGetFileUrls, opts ...grpc.CallOption) (*ResponseGetFileUrls, error) {
	out := new(ResponseGetFileUrls)
	err := c.cc.Invoke(ctx, "/dialog.MediaAndFiles/GetFileUrls", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaAndFilesClient) GetFileUrlBuilder(ctx context.Context, in *RequestGetFileUrlBuilder, opts ...grpc.CallOption) (*ResponseGetFileUrlBuilder, error) {
	out := new(ResponseGetFileUrlBuilder)
	err := c.cc.Invoke(ctx, "/dialog.MediaAndFiles/GetFileUrlBuilder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaAndFilesClient) GetFileUploadUrl(ctx context.Context, in *RequestGetFileUploadUrl, opts ...grpc.CallOption) (*ResponseGetFileUploadUrl, error) {
	out := new(ResponseGetFileUploadUrl)
	err := c.cc.Invoke(ctx, "/dialog.MediaAndFiles/GetFileUploadUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaAndFilesClient) CommitFileUpload(ctx context.Context, in *RequestCommitFileUpload, opts ...grpc.CallOption) (*ResponseCommitFileUpload, error) {
	out := new(ResponseCommitFileUpload)
	err := c.cc.Invoke(ctx, "/dialog.MediaAndFiles/CommitFileUpload", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *mediaAndFilesClient) GetFileUploadPartUrl(ctx context.Context, in *RequestGetFileUploadPartUrl, opts ...grpc.CallOption) (*ResponseGetFileUploadPartUrl, error) {
	out := new(ResponseGetFileUploadPartUrl)
	err := c.cc.Invoke(ctx, "/dialog.MediaAndFiles/GetFileUploadPartUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MediaAndFilesServer is the server API for MediaAndFiles service.
type MediaAndFilesServer interface {
	/// Get link to file for downloading
	GetFileUrl(context.Context, *RequestGetFileUrl) (*ResponseGetFileUrl, error)
	/// Get link to files for downloading
	GetFileUrls(context.Context, *RequestGetFileUrls) (*ResponseGetFileUrls, error)
	/// Create builder for file url
	GetFileUrlBuilder(context.Context, *RequestGetFileUrlBuilder) (*ResponseGetFileUrlBuilder, error)
	/// Get url for uploading
	GetFileUploadUrl(context.Context, *RequestGetFileUploadUrl) (*ResponseGetFileUploadUrl, error)
	/// Finish uploading a file
	CommitFileUpload(context.Context, *RequestCommitFileUpload) (*ResponseCommitFileUpload, error)
	/// Get url for uploading chunk of file
	GetFileUploadPartUrl(context.Context, *RequestGetFileUploadPartUrl) (*ResponseGetFileUploadPartUrl, error)
}

// UnimplementedMediaAndFilesServer can be embedded to have forward compatible implementations.
type UnimplementedMediaAndFilesServer struct {
}

func (*UnimplementedMediaAndFilesServer) GetFileUrl(ctx context.Context, req *RequestGetFileUrl) (*ResponseGetFileUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileUrl not implemented")
}
func (*UnimplementedMediaAndFilesServer) GetFileUrls(ctx context.Context, req *RequestGetFileUrls) (*ResponseGetFileUrls, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileUrls not implemented")
}
func (*UnimplementedMediaAndFilesServer) GetFileUrlBuilder(ctx context.Context, req *RequestGetFileUrlBuilder) (*ResponseGetFileUrlBuilder, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileUrlBuilder not implemented")
}
func (*UnimplementedMediaAndFilesServer) GetFileUploadUrl(ctx context.Context, req *RequestGetFileUploadUrl) (*ResponseGetFileUploadUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileUploadUrl not implemented")
}
func (*UnimplementedMediaAndFilesServer) CommitFileUpload(ctx context.Context, req *RequestCommitFileUpload) (*ResponseCommitFileUpload, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CommitFileUpload not implemented")
}
func (*UnimplementedMediaAndFilesServer) GetFileUploadPartUrl(ctx context.Context, req *RequestGetFileUploadPartUrl) (*ResponseGetFileUploadPartUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileUploadPartUrl not implemented")
}

func RegisterMediaAndFilesServer(s *grpc.Server, srv MediaAndFilesServer) {
	s.RegisterService(&_MediaAndFiles_serviceDesc, srv)
}

func _MediaAndFiles_GetFileUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetFileUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaAndFilesServer).GetFileUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.MediaAndFiles/GetFileUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaAndFilesServer).GetFileUrl(ctx, req.(*RequestGetFileUrl))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaAndFiles_GetFileUrls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetFileUrls)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaAndFilesServer).GetFileUrls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.MediaAndFiles/GetFileUrls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaAndFilesServer).GetFileUrls(ctx, req.(*RequestGetFileUrls))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaAndFiles_GetFileUrlBuilder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetFileUrlBuilder)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaAndFilesServer).GetFileUrlBuilder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.MediaAndFiles/GetFileUrlBuilder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaAndFilesServer).GetFileUrlBuilder(ctx, req.(*RequestGetFileUrlBuilder))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaAndFiles_GetFileUploadUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetFileUploadUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaAndFilesServer).GetFileUploadUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.MediaAndFiles/GetFileUploadUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaAndFilesServer).GetFileUploadUrl(ctx, req.(*RequestGetFileUploadUrl))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaAndFiles_CommitFileUpload_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCommitFileUpload)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaAndFilesServer).CommitFileUpload(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.MediaAndFiles/CommitFileUpload",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaAndFilesServer).CommitFileUpload(ctx, req.(*RequestCommitFileUpload))
	}
	return interceptor(ctx, in, info, handler)
}

func _MediaAndFiles_GetFileUploadPartUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetFileUploadPartUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MediaAndFilesServer).GetFileUploadPartUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.MediaAndFiles/GetFileUploadPartUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MediaAndFilesServer).GetFileUploadPartUrl(ctx, req.(*RequestGetFileUploadPartUrl))
	}
	return interceptor(ctx, in, info, handler)
}

var _MediaAndFiles_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dialog.MediaAndFiles",
	HandlerType: (*MediaAndFilesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetFileUrl",
			Handler:    _MediaAndFiles_GetFileUrl_Handler,
		},
		{
			MethodName: "GetFileUrls",
			Handler:    _MediaAndFiles_GetFileUrls_Handler,
		},
		{
			MethodName: "GetFileUrlBuilder",
			Handler:    _MediaAndFiles_GetFileUrlBuilder_Handler,
		},
		{
			MethodName: "GetFileUploadUrl",
			Handler:    _MediaAndFiles_GetFileUploadUrl_Handler,
		},
		{
			MethodName: "CommitFileUpload",
			Handler:    _MediaAndFiles_CommitFileUpload_Handler,
		},
		{
			MethodName: "GetFileUploadPartUrl",
			Handler:    _MediaAndFiles_GetFileUploadPartUrl_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "media_and_files.proto",
}

func (m *FileLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AccessHash != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.FileId != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ImageLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ImageLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ImageLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileSize != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if m.Width != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x10
	}
	if m.FileLocation != nil {
		{
			size, err := m.FileLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AudioLocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AudioLocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AudioLocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileSize != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x20
	}
	if len(m.MimeType) > 0 {
		i -= len(m.MimeType)
		copy(dAtA[i:], m.MimeType)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.MimeType)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Duration != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Duration))
		i--
		dAtA[i] = 0x10
	}
	if m.FileLocation != nil {
		{
			size, err := m.FileLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AvatarImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AvatarImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AvatarImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FileSize != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.FileSize))
		i--
		dAtA[i] = 0x20
	}
	if m.Height != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if m.Width != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Width))
		i--
		dAtA[i] = 0x10
	}
	if m.FileLocation != nil {
		{
			size, err := m.FileLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Avatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Avatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Avatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.FullImage != nil {
		{
			size, err := m.FullImage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.LargeImage != nil {
		{
			size, err := m.LargeImage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.SmallImage != nil {
		{
			size, err := m.SmallImage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FastThumb) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FastThumb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FastThumb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Thumb) > 0 {
		i -= len(m.Thumb)
		copy(dAtA[i:], m.Thumb)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Thumb)))
		i--
		dAtA[i] = 0x1a
	}
	if m.H != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.H))
		i--
		dAtA[i] = 0x10
	}
	if m.W != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.W))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Color) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Color) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Color) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Body != nil {
		{
			size := m.Body.Size()
			i -= size
			if _, err := m.Body.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Color_Rgb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Color_Rgb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Rgb != nil {
		{
			size, err := m.Rgb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Color_Predefined) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Color_Predefined) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Predefined != nil {
		{
			size, err := m.Predefined.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *RgbColor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RgbColor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RgbColor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rgb != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Rgb))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PredefinedColor) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PredefinedColor) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PredefinedColor) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Color != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Color))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HTTPHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HTTPHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HTTPHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *FileUrlDescription) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileUrlDescription) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileUrlDescription) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnsignedUrlHeaders) > 0 {
		for iNdEx := len(m.UnsignedUrlHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnsignedUrlHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.UnsignedUrl != nil {
		{
			size, err := m.UnsignedUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Timeout != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0x12
	}
	if m.FileId != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FileUrlError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FileUrlError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FileUrlError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Retryable {
		i--
		if m.Retryable {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Tag != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Tag))
		i--
		dAtA[i] = 0x10
	}
	if m.FileId != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.FileId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetFileUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetFileUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetFileUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGetFileUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetFileUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetFileUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnsignedUrlHeaders) > 0 {
		for iNdEx := len(m.UnsignedUrlHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnsignedUrlHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.UnsignedUrl != nil {
		{
			size, err := m.UnsignedUrl.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Timeout != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetFileUrls) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetFileUrls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetFileUrls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for iNdEx := len(m.Files) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Files[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGetFileUrls) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetFileUrls) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetFileUrls) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Errors) > 0 {
		for iNdEx := len(m.Errors) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Errors[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FileUrls) > 0 {
		for iNdEx := len(m.FileUrls) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.FileUrls[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetFileUrlBuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetFileUrlBuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetFileUrlBuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SupportedSignatureAlgorithms) > 0 {
		for iNdEx := len(m.SupportedSignatureAlgorithms) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.SupportedSignatureAlgorithms[iNdEx])
			copy(dAtA[i:], m.SupportedSignatureAlgorithms[iNdEx])
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.SupportedSignatureAlgorithms[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGetFileUrlBuilder) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetFileUrlBuilder) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetFileUrlBuilder) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Seed) > 0 {
		i -= len(m.Seed)
		copy(dAtA[i:], m.Seed)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Seed)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Timeout != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x20
	}
	if len(m.SignatureSecret) > 0 {
		i -= len(m.SignatureSecret)
		copy(dAtA[i:], m.SignatureSecret)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.SignatureSecret)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Algo) > 0 {
		i -= len(m.Algo)
		copy(dAtA[i:], m.Algo)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Algo)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BaseUrl) > 0 {
		i -= len(m.BaseUrl)
		copy(dAtA[i:], m.BaseUrl)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.BaseUrl)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetFileUploadUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetFileUploadUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetFileUploadUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpectedSize != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.ExpectedSize))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGetFileUploadUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetFileUploadUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetFileUploadUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestCommitFileUpload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCommitFileUpload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCommitFileUpload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.FileName) > 0 {
		i -= len(m.FileName)
		copy(dAtA[i:], m.FileName)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.FileName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseCommitFileUpload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseCommitFileUpload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCommitFileUpload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UploadedFileLocation != nil {
		{
			size, err := m.UploadedFileLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMediaAndFiles(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetFileUploadPartUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetFileUploadPartUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetFileUploadPartUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UploadKey) > 0 {
		i -= len(m.UploadKey)
		copy(dAtA[i:], m.UploadKey)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.UploadKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.PartSize != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.PartSize))
		i--
		dAtA[i] = 0x10
	}
	if m.PartNumber != 0 {
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(m.PartNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGetFileUploadPartUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetFileUploadPartUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetFileUploadPartUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintMediaAndFiles(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintMediaAndFiles(dAtA []byte, offset int, v uint64) int {
	offset -= sovMediaAndFiles(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *FileLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.FileId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.AccessHash))
	}
	return n
}

func (m *ImageLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileLocation != nil {
		l = m.FileLocation.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Height))
	}
	if m.FileSize != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.FileSize))
	}
	return n
}

func (m *AudioLocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileLocation != nil {
		l = m.FileLocation.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Duration != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Duration))
	}
	l = len(m.MimeType)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.FileSize))
	}
	return n
}

func (m *AvatarImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileLocation != nil {
		l = m.FileLocation.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Width != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Width))
	}
	if m.Height != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Height))
	}
	if m.FileSize != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.FileSize))
	}
	return n
}

func (m *Avatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SmallImage != nil {
		l = m.SmallImage.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.LargeImage != nil {
		l = m.LargeImage.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.FullImage != nil {
		l = m.FullImage.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *FastThumb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.W != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.W))
	}
	if m.H != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.H))
	}
	l = len(m.Thumb)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *Color) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Body != nil {
		n += m.Body.Size()
	}
	return n
}

func (m *Color_Rgb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rgb != nil {
		l = m.Rgb.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}
func (m *Color_Predefined) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Predefined != nil {
		l = m.Predefined.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}
func (m *RgbColor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rgb != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Rgb))
	}
	return n
}

func (m *PredefinedColor) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Color != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Color))
	}
	return n
}

func (m *HTTPHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *FileUrlDescription) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.FileId))
	}
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Timeout))
	}
	if m.UnsignedUrl != nil {
		l = m.UnsignedUrl.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if len(m.UnsignedUrlHeaders) > 0 {
		for _, e := range m.UnsignedUrlHeaders {
			l = e.Size()
			n += 1 + l + sovMediaAndFiles(uint64(l))
		}
	}
	return n
}

func (m *FileUrlError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FileId != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.FileId))
	}
	if m.Tag != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Tag))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Retryable {
		n += 2
	}
	return n
}

func (m *RequestGetFileUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *ResponseGetFileUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Timeout))
	}
	if m.UnsignedUrl != nil {
		l = m.UnsignedUrl.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if len(m.UnsignedUrlHeaders) > 0 {
		for _, e := range m.UnsignedUrlHeaders {
			l = e.Size()
			n += 1 + l + sovMediaAndFiles(uint64(l))
		}
	}
	return n
}

func (m *RequestGetFileUrls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovMediaAndFiles(uint64(l))
		}
	}
	return n
}

func (m *ResponseGetFileUrls) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.FileUrls) > 0 {
		for _, e := range m.FileUrls {
			l = e.Size()
			n += 1 + l + sovMediaAndFiles(uint64(l))
		}
	}
	if len(m.Errors) > 0 {
		for _, e := range m.Errors {
			l = e.Size()
			n += 1 + l + sovMediaAndFiles(uint64(l))
		}
	}
	return n
}

func (m *RequestGetFileUrlBuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SupportedSignatureAlgorithms) > 0 {
		for _, s := range m.SupportedSignatureAlgorithms {
			l = len(s)
			n += 1 + l + sovMediaAndFiles(uint64(l))
		}
	}
	return n
}

func (m *ResponseGetFileUrlBuilder) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BaseUrl)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	l = len(m.Algo)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	l = len(m.SignatureSecret)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	if m.Timeout != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.Timeout))
	}
	l = len(m.Seed)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *RequestGetFileUploadUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ExpectedSize != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.ExpectedSize))
	}
	return n
}

func (m *ResponseGetFileUploadUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *RequestCommitFileUpload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.UploadKey)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	l = len(m.FileName)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *ResponseCommitFileUpload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UploadedFileLocation != nil {
		l = m.UploadedFileLocation.Size()
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *RequestGetFileUploadPartUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PartNumber != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.PartNumber))
	}
	if m.PartSize != 0 {
		n += 1 + sovMediaAndFiles(uint64(m.PartSize))
	}
	l = len(m.UploadKey)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func (m *ResponseGetFileUploadPartUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovMediaAndFiles(uint64(l))
	}
	return n
}

func sovMediaAndFiles(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMediaAndFiles(x uint64) (n int) {
	return sovMediaAndFiles(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *FileLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileLocation{`,
		`FileId:` + fmt.Sprintf("%v", this.FileId) + `,`,
		`AccessHash:` + fmt.Sprintf("%v", this.AccessHash) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ImageLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ImageLocation{`,
		`FileLocation:` + strings.Replace(this.FileLocation.String(), "FileLocation", "FileLocation", 1) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AudioLocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AudioLocation{`,
		`FileLocation:` + strings.Replace(this.FileLocation.String(), "FileLocation", "FileLocation", 1) + `,`,
		`Duration:` + fmt.Sprintf("%v", this.Duration) + `,`,
		`MimeType:` + fmt.Sprintf("%v", this.MimeType) + `,`,
		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AvatarImage) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AvatarImage{`,
		`FileLocation:` + strings.Replace(this.FileLocation.String(), "FileLocation", "FileLocation", 1) + `,`,
		`Width:` + fmt.Sprintf("%v", this.Width) + `,`,
		`Height:` + fmt.Sprintf("%v", this.Height) + `,`,
		`FileSize:` + fmt.Sprintf("%v", this.FileSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Avatar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Avatar{`,
		`SmallImage:` + strings.Replace(this.SmallImage.String(), "AvatarImage", "AvatarImage", 1) + `,`,
		`LargeImage:` + strings.Replace(this.LargeImage.String(), "AvatarImage", "AvatarImage", 1) + `,`,
		`FullImage:` + strings.Replace(this.FullImage.String(), "AvatarImage", "AvatarImage", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FastThumb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FastThumb{`,
		`W:` + fmt.Sprintf("%v", this.W) + `,`,
		`H:` + fmt.Sprintf("%v", this.H) + `,`,
		`Thumb:` + fmt.Sprintf("%v", this.Thumb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Color) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Color{`,
		`Body:` + fmt.Sprintf("%v", this.Body) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Color_Rgb) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Color_Rgb{`,
		`Rgb:` + strings.Replace(fmt.Sprintf("%v", this.Rgb), "RgbColor", "RgbColor", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Color_Predefined) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Color_Predefined{`,
		`Predefined:` + strings.Replace(fmt.Sprintf("%v", this.Predefined), "PredefinedColor", "PredefinedColor", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RgbColor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RgbColor{`,
		`Rgb:` + fmt.Sprintf("%v", this.Rgb) + `,`,
		`}`,
	}, "")
	return s
}
func (this *PredefinedColor) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&PredefinedColor{`,
		`Color:` + fmt.Sprintf("%v", this.Color) + `,`,
		`}`,
	}, "")
	return s
}
func (this *HTTPHeader) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&HTTPHeader{`,
		`Key:` + fmt.Sprintf("%v", this.Key) + `,`,
		`Value:` + fmt.Sprintf("%v", this.Value) + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileUrlDescription) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUnsignedUrlHeaders := "[]*HTTPHeader{"
	for _, f := range this.UnsignedUrlHeaders {
		repeatedStringForUnsignedUrlHeaders += strings.Replace(f.String(), "HTTPHeader", "HTTPHeader", 1) + ","
	}
	repeatedStringForUnsignedUrlHeaders += "}"
	s := strings.Join([]string{`&FileUrlDescription{`,
		`FileId:` + fmt.Sprintf("%v", this.FileId) + `,`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`UnsignedUrl:` + strings.Replace(fmt.Sprintf("%v", this.UnsignedUrl), "StringValue", "types.StringValue", 1) + `,`,
		`UnsignedUrlHeaders:` + repeatedStringForUnsignedUrlHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *FileUrlError) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&FileUrlError{`,
		`FileId:` + fmt.Sprintf("%v", this.FileId) + `,`,
		`Tag:` + fmt.Sprintf("%v", this.Tag) + `,`,
		`Reason:` + fmt.Sprintf("%v", this.Reason) + `,`,
		`Retryable:` + fmt.Sprintf("%v", this.Retryable) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetFileUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetFileUrl{`,
		`File:` + strings.Replace(this.File.String(), "FileLocation", "FileLocation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetFileUrl) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUnsignedUrlHeaders := "[]*HTTPHeader{"
	for _, f := range this.UnsignedUrlHeaders {
		repeatedStringForUnsignedUrlHeaders += strings.Replace(f.String(), "HTTPHeader", "HTTPHeader", 1) + ","
	}
	repeatedStringForUnsignedUrlHeaders += "}"
	s := strings.Join([]string{`&ResponseGetFileUrl{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`UnsignedUrl:` + strings.Replace(fmt.Sprintf("%v", this.UnsignedUrl), "StringValue", "types.StringValue", 1) + `,`,
		`UnsignedUrlHeaders:` + repeatedStringForUnsignedUrlHeaders + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetFileUrls) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFiles := "[]*FileLocation{"
	for _, f := range this.Files {
		repeatedStringForFiles += strings.Replace(f.String(), "FileLocation", "FileLocation", 1) + ","
	}
	repeatedStringForFiles += "}"
	s := strings.Join([]string{`&RequestGetFileUrls{`,
		`Files:` + repeatedStringForFiles + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetFileUrls) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForFileUrls := "[]*FileUrlDescription{"
	for _, f := range this.FileUrls {
		repeatedStringForFileUrls += strings.Replace(f.String(), "FileUrlDescription", "FileUrlDescription", 1) + ","
	}
	repeatedStringForFileUrls += "}"
	repeatedStringForErrors := "[]*FileUrlError{"
	for _, f := range this.Errors {
		repeatedStringForErrors += strings.Replace(f.String(), "FileUrlError", "FileUrlError", 1) + ","
	}
	repeatedStringForErrors += "}"
	s := strings.Join([]string{`&ResponseGetFileUrls{`,
		`FileUrls:` + repeatedStringForFileUrls + `,`,
		`Errors:` + repeatedStringForErrors + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetFileUrlBuilder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetFileUrlBuilder{`,
		`SupportedSignatureAlgorithms:` + fmt.Sprintf("%v", this.SupportedSignatureAlgorithms) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetFileUrlBuilder) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseGetFileUrlBuilder{`,
		`BaseUrl:` + fmt.Sprintf("%v", this.BaseUrl) + `,`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`SignatureSecret:` + fmt.Sprintf("%v", this.SignatureSecret) + `,`,
		`Timeout:` + fmt.Sprintf("%v", this.Timeout) + `,`,
		`Seed:` + fmt.Sprintf("%v", this.Seed) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetFileUploadUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetFileUploadUrl{`,
		`ExpectedSize:` + fmt.Sprintf("%v", this.ExpectedSize) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetFileUploadUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseGetFileUploadUrl{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`UploadKey:` + fmt.Sprintf("%v", this.UploadKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestCommitFileUpload) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestCommitFileUpload{`,
		`UploadKey:` + fmt.Sprintf("%v", this.UploadKey) + `,`,
		`FileName:` + fmt.Sprintf("%v", this.FileName) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCommitFileUpload) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseCommitFileUpload{`,
		`UploadedFileLocation:` + strings.Replace(this.UploadedFileLocation.String(), "FileLocation", "FileLocation", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetFileUploadPartUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetFileUploadPartUrl{`,
		`PartNumber:` + fmt.Sprintf("%v", this.PartNumber) + `,`,
		`PartSize:` + fmt.Sprintf("%v", this.PartSize) + `,`,
		`UploadKey:` + fmt.Sprintf("%v", this.UploadKey) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetFileUploadPartUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseGetFileUploadPartUrl{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringMediaAndFiles(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *FileLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ImageLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ImageLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ImageLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileLocation == nil {
				m.FileLocation = &FileLocation{}
			}
			if err := m.FileLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AudioLocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AudioLocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AudioLocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileLocation == nil {
				m.FileLocation = &FileLocation{}
			}
			if err := m.FileLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Duration", wireType)
			}
			m.Duration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Duration |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MimeType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MimeType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AvatarImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AvatarImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AvatarImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileLocation == nil {
				m.FileLocation = &FileLocation{}
			}
			if err := m.FileLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Width", wireType)
			}
			m.Width = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Width |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Avatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Avatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Avatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SmallImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SmallImage == nil {
				m.SmallImage = &AvatarImage{}
			}
			if err := m.SmallImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LargeImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LargeImage == nil {
				m.LargeImage = &AvatarImage{}
			}
			if err := m.LargeImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FullImage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FullImage == nil {
				m.FullImage = &AvatarImage{}
			}
			if err := m.FullImage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FastThumb) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FastThumb: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FastThumb: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field W", wireType)
			}
			m.W = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.W |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field H", wireType)
			}
			m.H = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.H |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Thumb", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Thumb = append(m.Thumb[:0], dAtA[iNdEx:postIndex]...)
			if m.Thumb == nil {
				m.Thumb = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Color) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Color: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Color: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rgb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RgbColor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Color_Rgb{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Predefined", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PredefinedColor{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Body = &Color_Predefined{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RgbColor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RgbColor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RgbColor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rgb", wireType)
			}
			m.Rgb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rgb |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PredefinedColor) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PredefinedColor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PredefinedColor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Color", wireType)
			}
			m.Color = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Color |= Colors(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HTTPHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HTTPHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HTTPHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileUrlDescription) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileUrlDescription: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileUrlDescription: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnsignedUrl == nil {
				m.UnsignedUrl = &types.StringValue{}
			}
			if err := m.UnsignedUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedUrlHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnsignedUrlHeaders = append(m.UnsignedUrlHeaders, &HTTPHeader{})
			if err := m.UnsignedUrlHeaders[len(m.UnsignedUrlHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileUrlError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileUrlError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileUrlError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tag", wireType)
			}
			m.Tag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tag |= FileUrlError_ErrorTag(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retryable", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Retryable = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetFileUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetFileUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetFileUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &FileLocation{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetFileUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetFileUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetFileUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedUrl", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UnsignedUrl == nil {
				m.UnsignedUrl = &types.StringValue{}
			}
			if err := m.UnsignedUrl.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnsignedUrlHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnsignedUrlHeaders = append(m.UnsignedUrlHeaders, &HTTPHeader{})
			if err := m.UnsignedUrlHeaders[len(m.UnsignedUrlHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetFileUrls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetFileUrls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetFileUrls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &FileLocation{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetFileUrls) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetFileUrls: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetFileUrls: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileUrls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileUrls = append(m.FileUrls, &FileUrlDescription{})
			if err := m.FileUrls[len(m.FileUrls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Errors", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Errors = append(m.Errors, &FileUrlError{})
			if err := m.Errors[len(m.Errors)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetFileUrlBuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetFileUrlBuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetFileUrlBuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SupportedSignatureAlgorithms", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SupportedSignatureAlgorithms = append(m.SupportedSignatureAlgorithms, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetFileUrlBuilder) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetFileUrlBuilder: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetFileUrlBuilder: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BaseUrl", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BaseUrl = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignatureSecret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SignatureSecret = append(m.SignatureSecret[:0], dAtA[iNdEx:postIndex]...)
			if m.SignatureSecret == nil {
				m.SignatureSecret = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Seed = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetFileUploadUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetFileUploadUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetFileUploadUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedSize", wireType)
			}
			m.ExpectedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpectedSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetFileUploadUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetFileUploadUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetFileUploadUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCommitFileUpload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCommitFileUpload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCommitFileUpload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseCommitFileUpload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseCommitFileUpload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseCommitFileUpload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadedFileLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UploadedFileLocation == nil {
				m.UploadedFileLocation = &FileLocation{}
			}
			if err := m.UploadedFileLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetFileUploadPartUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetFileUploadPartUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetFileUploadPartUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartNumber", wireType)
			}
			m.PartNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartNumber |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartSize", wireType)
			}
			m.PartSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartSize |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UploadKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UploadKey = append(m.UploadKey[:0], dAtA[iNdEx:postIndex]...)
			if m.UploadKey == nil {
				m.UploadKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetFileUploadPartUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetFileUploadPartUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetFileUploadPartUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMediaAndFiles(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMediaAndFiles
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMediaAndFiles(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMediaAndFiles
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMediaAndFiles
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMediaAndFiles
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMediaAndFiles
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMediaAndFiles
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMediaAndFiles        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMediaAndFiles          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMediaAndFiles = fmt.Errorf("proto: unexpected end of group")
)
