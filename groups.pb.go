// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: groups.proto

package dialog

import (
	bytes "bytes"
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type GroupType int32

const (
	GROUPTYPE_UNKNOWN GroupType = 0
	GROUPTYPE_GROUP   GroupType = 1
	GROUPTYPE_CHANNEL GroupType = 2
	GROUPTYPE_THREAD  GroupType = 4
)

var GroupType_name = map[int32]string{
	0: "GROUPTYPE_UNKNOWN",
	1: "GROUPTYPE_GROUP",
	2: "GROUPTYPE_CHANNEL",
	4: "GROUPTYPE_THREAD",
}

var GroupType_value = map[string]int32{
	"GROUPTYPE_UNKNOWN": 0,
	"GROUPTYPE_GROUP":   1,
	"GROUPTYPE_CHANNEL": 2,
	"GROUPTYPE_THREAD":  4,
}

func (GroupType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{0}
}

/// Possible permissions on a group
type GroupAdminPermission int32

const (
	GROUPADMINPERMISSION_UNKNOWN             GroupAdminPermission = 0
	GROUPADMINPERMISSION_EDITSHORTNAME       GroupAdminPermission = 1
	GROUPADMINPERMISSION_INVITE              GroupAdminPermission = 2
	GROUPADMINPERMISSION_KICK                GroupAdminPermission = 3
	GROUPADMINPERMISSION_UPDATEINFO          GroupAdminPermission = 4
	GROUPADMINPERMISSION_SETPERMISSIONS      GroupAdminPermission = 5
	GROUPADMINPERMISSION_EDITMESSAGE         GroupAdminPermission = 6
	GROUPADMINPERMISSION_DELETEMESSAGE       GroupAdminPermission = 7
	GROUPADMINPERMISSION_GETINTEGRATIONTOKEN GroupAdminPermission = 8
	GROUPADMINPERMISSION_SENDMESSAGE         GroupAdminPermission = 9
	GROUPADMINPERMISSION_PINMESSAGE          GroupAdminPermission = 10
	GROUPADMINPERMISSION_VIEWMEMBERS         GroupAdminPermission = 11
	GROUPADMINPERMISSION_LEAVE               GroupAdminPermission = 12
	GROUPADMINPERMISSION_TARGETING           GroupAdminPermission = 13
	GROUPADMINPERMISSION_DELETE              GroupAdminPermission = 14
)

var GroupAdminPermission_name = map[int32]string{
	0:  "GROUPADMINPERMISSION_UNKNOWN",
	1:  "GROUPADMINPERMISSION_EDITSHORTNAME",
	2:  "GROUPADMINPERMISSION_INVITE",
	3:  "GROUPADMINPERMISSION_KICK",
	4:  "GROUPADMINPERMISSION_UPDATEINFO",
	5:  "GROUPADMINPERMISSION_SETPERMISSIONS",
	6:  "GROUPADMINPERMISSION_EDITMESSAGE",
	7:  "GROUPADMINPERMISSION_DELETEMESSAGE",
	8:  "GROUPADMINPERMISSION_GETINTEGRATIONTOKEN",
	9:  "GROUPADMINPERMISSION_SENDMESSAGE",
	10: "GROUPADMINPERMISSION_PINMESSAGE",
	11: "GROUPADMINPERMISSION_VIEWMEMBERS",
	12: "GROUPADMINPERMISSION_LEAVE",
	13: "GROUPADMINPERMISSION_TARGETING",
	14: "GROUPADMINPERMISSION_DELETE",
}

var GroupAdminPermission_value = map[string]int32{
	"GROUPADMINPERMISSION_UNKNOWN":             0,
	"GROUPADMINPERMISSION_EDITSHORTNAME":       1,
	"GROUPADMINPERMISSION_INVITE":              2,
	"GROUPADMINPERMISSION_KICK":                3,
	"GROUPADMINPERMISSION_UPDATEINFO":          4,
	"GROUPADMINPERMISSION_SETPERMISSIONS":      5,
	"GROUPADMINPERMISSION_EDITMESSAGE":         6,
	"GROUPADMINPERMISSION_DELETEMESSAGE":       7,
	"GROUPADMINPERMISSION_GETINTEGRATIONTOKEN": 8,
	"GROUPADMINPERMISSION_SENDMESSAGE":         9,
	"GROUPADMINPERMISSION_PINMESSAGE":          10,
	"GROUPADMINPERMISSION_VIEWMEMBERS":         11,
	"GROUPADMINPERMISSION_LEAVE":               12,
	"GROUPADMINPERMISSION_TARGETING":           13,
	"GROUPADMINPERMISSION_DELETE":              14,
}

func (GroupAdminPermission) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{1}
}

// Member information
type Member struct {
	Uid         int32                  `protobuf:"varint,1,opt,name=uid,proto3" json:"uid,omitempty"`
	InvitedAt   int64                  `protobuf:"varint,3,opt,name=invited_at,json=invitedAt,proto3" json:"invited_at,omitempty"`
	Permissions []GroupAdminPermission `protobuf:"varint,5,rep,packed,name=permissions,proto3,enum=dialog.GroupAdminPermission" json:"permissions,omitempty"`
	Clock       int64                  `protobuf:"varint,6,opt,name=clock,proto3" json:"clock,omitempty"`
	DeletedAt   *types.Timestamp       `protobuf:"bytes,7,opt,name=deleted_at,json=deletedAt,proto3" json:"deleted_at,omitempty"`
}

func (m *Member) Reset()      { *m = Member{} }
func (*Member) ProtoMessage() {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{0}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *Member) GetInvitedAt() int64 {
	if m != nil {
		return m.InvitedAt
	}
	return 0
}

func (m *Member) GetPermissions() []GroupAdminPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

func (m *Member) GetClock() int64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *Member) GetDeletedAt() *types.Timestamp {
	if m != nil {
		return m.DeletedAt
	}
	return nil
}

// Group information
type Group struct {
	Id         int32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash int64      `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Data       *GroupData `protobuf:"bytes,29,opt,name=data,proto3" json:"data,omitempty"`
	SelfMember *Member    `protobuf:"bytes,30,opt,name=self_member,json=selfMember,proto3" json:"self_member,omitempty"`
	// For old bot sdk compatibility
	Title string `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	/// Group Type. Used only for displaying information. Default is GROUP.
	GroupType GroupType `protobuf:"varint,25,opt,name=group_type,json=groupType,proto3,enum=dialog.GroupType" json:"group_type,omitempty"`
	/// Group short name
	Shortname *types.StringValue `protobuf:"bytes,19,opt,name=shortname,proto3" json:"shortname,omitempty"`
}

func (m *Group) Reset()      { *m = Group{} }
func (*Group) ProtoMessage() {}
func (*Group) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{1}
}
func (m *Group) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Group) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Group.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Group) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Group.Merge(m, src)
}
func (m *Group) XXX_Size() int {
	return m.Size()
}
func (m *Group) XXX_DiscardUnknown() {
	xxx_messageInfo_Group.DiscardUnknown(m)
}

var xxx_messageInfo_Group proto.InternalMessageInfo

func (m *Group) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Group) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *Group) GetData() *GroupData {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Group) GetSelfMember() *Member {
	if m != nil {
		return m.SelfMember
	}
	return nil
}

func (m *Group) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *Group) GetGroupType() GroupType {
	if m != nil {
		return m.GroupType
	}
	return GROUPTYPE_UNKNOWN
}

func (m *Group) GetShortname() *types.StringValue {
	if m != nil {
		return m.Shortname
	}
	return nil
}

type GroupData struct {
	SpaceId *UUIDValue `protobuf:"bytes,1,opt,name=space_id,json=spaceId,proto3" json:"space_id,omitempty"`
	Title   string     `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Avatar  *Avatar    `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	/// Number of members
	MembersAmount int32 `protobuf:"varint,4,opt,name=members_amount,json=membersAmount,proto3" json:"members_amount,omitempty"`
	/// Group Type. Used only for displaying information. Default is GROUP.
	GroupType   GroupType        `protobuf:"varint,5,opt,name=group_type,json=groupType,proto3,enum=dialog.GroupType" json:"group_type,omitempty"`
	OwnerUserId int32            `protobuf:"varint,6,opt,name=owner_user_id,json=ownerUserId,proto3" json:"owner_user_id,omitempty"`
	CreatedAt   *types.Timestamp `protobuf:"bytes,7,opt,name=created_at,json=createdAt,proto3" json:"created_at,omitempty"`
	/// About of group
	About *types.StringValue `protobuf:"bytes,8,opt,name=about,proto3" json:"about,omitempty"`
	/// Group short name
	Shortname       *types.StringValue     `protobuf:"bytes,9,opt,name=shortname,proto3" json:"shortname,omitempty"`
	BasePermissions []GroupAdminPermission `protobuf:"varint,10,rep,packed,name=base_permissions,json=basePermissions,proto3,enum=dialog.GroupAdminPermission" json:"base_permissions,omitempty"`
	Clock           int64                  `protobuf:"varint,11,opt,name=clock,proto3" json:"clock,omitempty"`
	PinnedAt        *types.Int64Value      `protobuf:"bytes,12,opt,name=pinned_at,json=pinnedAt,proto3" json:"pinned_at,omitempty"`
}

func (m *GroupData) Reset()      { *m = GroupData{} }
func (*GroupData) ProtoMessage() {}
func (*GroupData) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{2}
}
func (m *GroupData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupData.Merge(m, src)
}
func (m *GroupData) XXX_Size() int {
	return m.Size()
}
func (m *GroupData) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupData.DiscardUnknown(m)
}

var xxx_messageInfo_GroupData proto.InternalMessageInfo

func (m *GroupData) GetSpaceId() *UUIDValue {
	if m != nil {
		return m.SpaceId
	}
	return nil
}

func (m *GroupData) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *GroupData) GetAvatar() *Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *GroupData) GetMembersAmount() int32 {
	if m != nil {
		return m.MembersAmount
	}
	return 0
}

func (m *GroupData) GetGroupType() GroupType {
	if m != nil {
		return m.GroupType
	}
	return GROUPTYPE_UNKNOWN
}

func (m *GroupData) GetOwnerUserId() int32 {
	if m != nil {
		return m.OwnerUserId
	}
	return 0
}

func (m *GroupData) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *GroupData) GetAbout() *types.StringValue {
	if m != nil {
		return m.About
	}
	return nil
}

func (m *GroupData) GetShortname() *types.StringValue {
	if m != nil {
		return m.Shortname
	}
	return nil
}

func (m *GroupData) GetBasePermissions() []GroupAdminPermission {
	if m != nil {
		return m.BasePermissions
	}
	return nil
}

func (m *GroupData) GetClock() int64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *GroupData) GetPinnedAt() *types.Int64Value {
	if m != nil {
		return m.PinnedAt
	}
	return nil
}

type GroupPartialInfo struct {
	Id         int32              `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash int64              `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Clock      int64              `protobuf:"varint,3,opt,name=clock,proto3" json:"clock,omitempty"`
	Type       GroupType          `protobuf:"varint,4,opt,name=type,proto3,enum=dialog.GroupType" json:"type,omitempty"`
	Title      string             `protobuf:"bytes,5,opt,name=title,proto3" json:"title,omitempty"`
	Shortname  *types.StringValue `protobuf:"bytes,6,opt,name=shortname,proto3" json:"shortname,omitempty"`
	Avatar     *Avatar            `protobuf:"bytes,7,opt,name=avatar,proto3" json:"avatar,omitempty"`
	SelfMember *Member            `protobuf:"bytes,8,opt,name=self_member,json=selfMember,proto3" json:"self_member,omitempty"`
	PinnedAt   *types.Int64Value  `protobuf:"bytes,9,opt,name=pinned_at,json=pinnedAt,proto3" json:"pinned_at,omitempty"`
}

func (m *GroupPartialInfo) Reset()      { *m = GroupPartialInfo{} }
func (*GroupPartialInfo) ProtoMessage() {}
func (*GroupPartialInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{3}
}
func (m *GroupPartialInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupPartialInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupPartialInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupPartialInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupPartialInfo.Merge(m, src)
}
func (m *GroupPartialInfo) XXX_Size() int {
	return m.Size()
}
func (m *GroupPartialInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupPartialInfo.DiscardUnknown(m)
}

var xxx_messageInfo_GroupPartialInfo proto.InternalMessageInfo

func (m *GroupPartialInfo) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *GroupPartialInfo) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GroupPartialInfo) GetClock() int64 {
	if m != nil {
		return m.Clock
	}
	return 0
}

func (m *GroupPartialInfo) GetType() GroupType {
	if m != nil {
		return m.Type
	}
	return GROUPTYPE_UNKNOWN
}

func (m *GroupPartialInfo) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *GroupPartialInfo) GetShortname() *types.StringValue {
	if m != nil {
		return m.Shortname
	}
	return nil
}

func (m *GroupPartialInfo) GetAvatar() *Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *GroupPartialInfo) GetSelfMember() *Member {
	if m != nil {
		return m.SelfMember
	}
	return nil
}

func (m *GroupPartialInfo) GetPinnedAt() *types.Int64Value {
	if m != nil {
		return m.PinnedAt
	}
	return nil
}

// Update about group data changed
type UpdateGroup struct {
	Id   int32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Data *GroupData `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *UpdateGroup) Reset()      { *m = UpdateGroup{} }
func (*UpdateGroup) ProtoMessage() {}
func (*UpdateGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{4}
}
func (m *UpdateGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroup.Merge(m, src)
}
func (m *UpdateGroup) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroup.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroup proto.InternalMessageInfo

func (m *UpdateGroup) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *UpdateGroup) GetData() *GroupData {
	if m != nil {
		return m.Data
	}
	return nil
}

// Loading group members
type RequestLoadMembers struct {
	Group *GroupOutPeer     `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	Limit int32             `protobuf:"varint,2,opt,name=limit,proto3" json:"limit,omitempty"`
	Next  *types.BytesValue `protobuf:"bytes,3,opt,name=next,proto3" json:"next,omitempty"`
}

func (m *RequestLoadMembers) Reset()      { *m = RequestLoadMembers{} }
func (*RequestLoadMembers) ProtoMessage() {}
func (*RequestLoadMembers) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{5}
}
func (m *RequestLoadMembers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestLoadMembers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestLoadMembers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestLoadMembers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestLoadMembers.Merge(m, src)
}
func (m *RequestLoadMembers) XXX_Size() int {
	return m.Size()
}
func (m *RequestLoadMembers) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestLoadMembers.DiscardUnknown(m)
}

var xxx_messageInfo_RequestLoadMembers proto.InternalMessageInfo

func (m *RequestLoadMembers) GetGroup() *GroupOutPeer {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *RequestLoadMembers) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *RequestLoadMembers) GetNext() *types.BytesValue {
	if m != nil {
		return m.Next
	}
	return nil
}

type ResponseLoadMembers struct {
	Cursor  *types.BytesValue `protobuf:"bytes,2,opt,name=cursor,proto3" json:"cursor,omitempty"`
	Members []*Member         `protobuf:"bytes,3,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *ResponseLoadMembers) Reset()      { *m = ResponseLoadMembers{} }
func (*ResponseLoadMembers) ProtoMessage() {}
func (*ResponseLoadMembers) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{6}
}
func (m *ResponseLoadMembers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseLoadMembers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseLoadMembers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseLoadMembers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseLoadMembers.Merge(m, src)
}
func (m *ResponseLoadMembers) XXX_Size() int {
	return m.Size()
}
func (m *ResponseLoadMembers) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseLoadMembers.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseLoadMembers proto.InternalMessageInfo

func (m *ResponseLoadMembers) GetCursor() *types.BytesValue {
	if m != nil {
		return m.Cursor
	}
	return nil
}

func (m *ResponseLoadMembers) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

// Update about title changed
type UpdateGroupTitleChanged struct {
	GroupId int32  `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Title   string `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
}

func (m *UpdateGroupTitleChanged) Reset()      { *m = UpdateGroupTitleChanged{} }
func (*UpdateGroupTitleChanged) ProtoMessage() {}
func (*UpdateGroupTitleChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{7}
}
func (m *UpdateGroupTitleChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupTitleChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupTitleChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupTitleChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupTitleChanged.Merge(m, src)
}
func (m *UpdateGroupTitleChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupTitleChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupTitleChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupTitleChanged proto.InternalMessageInfo

func (m *UpdateGroupTitleChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupTitleChanged) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

// Update about avatar changed
type UpdateGroupAvatarChanged struct {
	GroupId int32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Avatar  *Avatar `protobuf:"bytes,2,opt,name=avatar,proto3" json:"avatar,omitempty"`
}

func (m *UpdateGroupAvatarChanged) Reset()      { *m = UpdateGroupAvatarChanged{} }
func (*UpdateGroupAvatarChanged) ProtoMessage() {}
func (*UpdateGroupAvatarChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{8}
}
func (m *UpdateGroupAvatarChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupAvatarChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupAvatarChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupAvatarChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupAvatarChanged.Merge(m, src)
}
func (m *UpdateGroupAvatarChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupAvatarChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupAvatarChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupAvatarChanged proto.InternalMessageInfo

func (m *UpdateGroupAvatarChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupAvatarChanged) GetAvatar() *Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

// Update about about changed
type UpdateGroupAboutChanged struct {
	GroupId int32              `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	About   *types.StringValue `protobuf:"bytes,2,opt,name=about,proto3" json:"about,omitempty"`
}

func (m *UpdateGroupAboutChanged) Reset()      { *m = UpdateGroupAboutChanged{} }
func (*UpdateGroupAboutChanged) ProtoMessage() {}
func (*UpdateGroupAboutChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{9}
}
func (m *UpdateGroupAboutChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupAboutChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupAboutChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupAboutChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupAboutChanged.Merge(m, src)
}
func (m *UpdateGroupAboutChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupAboutChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupAboutChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupAboutChanged proto.InternalMessageInfo

func (m *UpdateGroupAboutChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupAboutChanged) GetAbout() *types.StringValue {
	if m != nil {
		return m.About
	}
	return nil
}

// Update about owner changed
type UpdateGroupOwnerChanged struct {
	GroupId int32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	UserId  int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *UpdateGroupOwnerChanged) Reset()      { *m = UpdateGroupOwnerChanged{} }
func (*UpdateGroupOwnerChanged) ProtoMessage() {}
func (*UpdateGroupOwnerChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{10}
}
func (m *UpdateGroupOwnerChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupOwnerChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupOwnerChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupOwnerChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupOwnerChanged.Merge(m, src)
}
func (m *UpdateGroupOwnerChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupOwnerChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupOwnerChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupOwnerChanged proto.InternalMessageInfo

func (m *UpdateGroupOwnerChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupOwnerChanged) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

// Update about base group permissions changed
type UpdateGroupBasePermissionsChanged struct {
	GroupId int32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	/// new base permissions
	BasePermissions []GroupAdminPermission `protobuf:"varint,2,rep,packed,name=base_permissions,json=basePermissions,proto3,enum=dialog.GroupAdminPermission" json:"base_permissions,omitempty"`
}

func (m *UpdateGroupBasePermissionsChanged) Reset()      { *m = UpdateGroupBasePermissionsChanged{} }
func (*UpdateGroupBasePermissionsChanged) ProtoMessage() {}
func (*UpdateGroupBasePermissionsChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{11}
}
func (m *UpdateGroupBasePermissionsChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupBasePermissionsChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupBasePermissionsChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupBasePermissionsChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupBasePermissionsChanged.Merge(m, src)
}
func (m *UpdateGroupBasePermissionsChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupBasePermissionsChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupBasePermissionsChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupBasePermissionsChanged proto.InternalMessageInfo

func (m *UpdateGroupBasePermissionsChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupBasePermissionsChanged) GetBasePermissions() []GroupAdminPermission {
	if m != nil {
		return m.BasePermissions
	}
	return nil
}

// Update about members updated
type UpdateGroupMembersUpdated struct {
	GroupId int32     `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Members []*Member `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *UpdateGroupMembersUpdated) Reset()      { *m = UpdateGroupMembersUpdated{} }
func (*UpdateGroupMembersUpdated) ProtoMessage() {}
func (*UpdateGroupMembersUpdated) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{12}
}
func (m *UpdateGroupMembersUpdated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupMembersUpdated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupMembersUpdated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupMembersUpdated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupMembersUpdated.Merge(m, src)
}
func (m *UpdateGroupMembersUpdated) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupMembersUpdated) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupMembersUpdated.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupMembersUpdated proto.InternalMessageInfo

func (m *UpdateGroupMembersUpdated) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupMembersUpdated) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

// Update about members changed
type UpdateGroupMemberDiff struct {
	RemovedUsers []int32   `protobuf:"varint,1,rep,packed,name=removed_users,json=removedUsers,proto3" json:"removed_users,omitempty"`
	AddedMembers []*Member `protobuf:"bytes,2,rep,name=added_members,json=addedMembers,proto3" json:"added_members,omitempty"`
	MembersCount int32     `protobuf:"varint,3,opt,name=members_count,json=membersCount,proto3" json:"members_count,omitempty"`
}

func (m *UpdateGroupMemberDiff) Reset()      { *m = UpdateGroupMemberDiff{} }
func (*UpdateGroupMemberDiff) ProtoMessage() {}
func (*UpdateGroupMemberDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{13}
}
func (m *UpdateGroupMemberDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupMemberDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupMemberDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupMemberDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupMemberDiff.Merge(m, src)
}
func (m *UpdateGroupMemberDiff) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupMemberDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupMemberDiff.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupMemberDiff proto.InternalMessageInfo

func (m *UpdateGroupMemberDiff) GetRemovedUsers() []int32 {
	if m != nil {
		return m.RemovedUsers
	}
	return nil
}

func (m *UpdateGroupMemberDiff) GetAddedMembers() []*Member {
	if m != nil {
		return m.AddedMembers
	}
	return nil
}

func (m *UpdateGroupMemberDiff) GetMembersCount() int32 {
	if m != nil {
		return m.MembersCount
	}
	return 0
}

// Update about members count changed
type UpdateGroupMembersCountChanged struct {
	GroupId      int32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	MembersCount int32 `protobuf:"varint,2,opt,name=members_count,json=membersCount,proto3" json:"members_count,omitempty"`
}

func (m *UpdateGroupMembersCountChanged) Reset()      { *m = UpdateGroupMembersCountChanged{} }
func (*UpdateGroupMembersCountChanged) ProtoMessage() {}
func (*UpdateGroupMembersCountChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{14}
}
func (m *UpdateGroupMembersCountChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupMembersCountChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupMembersCountChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupMembersCountChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupMembersCountChanged.Merge(m, src)
}
func (m *UpdateGroupMembersCountChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupMembersCountChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupMembersCountChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupMembersCountChanged proto.InternalMessageInfo

func (m *UpdateGroupMembersCountChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupMembersCountChanged) GetMembersCount() int32 {
	if m != nil {
		return m.MembersCount
	}
	return 0
}

// Creating group chat
type RequestCreateGroup struct {
	Rid       int64          `protobuf:"varint,1,opt,name=rid,proto3" json:"rid,omitempty"`
	SpaceId   *UUIDValue     `protobuf:"bytes,9,opt,name=space_id,json=spaceId,proto3" json:"space_id,omitempty"`
	Title     string         `protobuf:"bytes,2,opt,name=title,proto3" json:"title,omitempty"`
	Users     []*UserOutPeer `protobuf:"bytes,3,rep,name=users,proto3" json:"users,omitempty"`
	GroupType GroupType      `protobuf:"varint,6,opt,name=group_type,json=groupType,proto3,enum=dialog.GroupType" json:"group_type,omitempty"`
	/// optional shortname of a group, group will be public if set
	Username *types.StringValue `protobuf:"bytes,8,opt,name=username,proto3" json:"username,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,7,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
	/// Base permissions for invited members
	BasePermissions []GroupAdminPermission `protobuf:"varint,10,rep,packed,name=base_permissions,json=basePermissions,proto3,enum=dialog.GroupAdminPermission" json:"base_permissions,omitempty"`
}

func (m *RequestCreateGroup) Reset()      { *m = RequestCreateGroup{} }
func (*RequestCreateGroup) ProtoMessage() {}
func (*RequestCreateGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{15}
}
func (m *RequestCreateGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestCreateGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestCreateGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestCreateGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestCreateGroup.Merge(m, src)
}
func (m *RequestCreateGroup) XXX_Size() int {
	return m.Size()
}
func (m *RequestCreateGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestCreateGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RequestCreateGroup proto.InternalMessageInfo

func (m *RequestCreateGroup) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestCreateGroup) GetSpaceId() *UUIDValue {
	if m != nil {
		return m.SpaceId
	}
	return nil
}

func (m *RequestCreateGroup) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RequestCreateGroup) GetUsers() []*UserOutPeer {
	if m != nil {
		return m.Users
	}
	return nil
}

func (m *RequestCreateGroup) GetGroupType() GroupType {
	if m != nil {
		return m.GroupType
	}
	return GROUPTYPE_UNKNOWN
}

func (m *RequestCreateGroup) GetUsername() *types.StringValue {
	if m != nil {
		return m.Username
	}
	return nil
}

func (m *RequestCreateGroup) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

func (m *RequestCreateGroup) GetBasePermissions() []GroupAdminPermission {
	if m != nil {
		return m.BasePermissions
	}
	return nil
}

type ResponseCreateGroup struct {
	Seq       int32          `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	State     []byte         `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	Group     *Group         `protobuf:"bytes,3,opt,name=group,proto3" json:"group,omitempty"`
	UserPeers []*UserOutPeer `protobuf:"bytes,5,rep,name=user_peers,json=userPeers,proto3" json:"user_peers,omitempty"`
}

func (m *ResponseCreateGroup) Reset()      { *m = ResponseCreateGroup{} }
func (*ResponseCreateGroup) ProtoMessage() {}
func (*ResponseCreateGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{16}
}
func (m *ResponseCreateGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseCreateGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseCreateGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseCreateGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseCreateGroup.Merge(m, src)
}
func (m *ResponseCreateGroup) XXX_Size() int {
	return m.Size()
}
func (m *ResponseCreateGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseCreateGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseCreateGroup proto.InternalMessageInfo

func (m *ResponseCreateGroup) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ResponseCreateGroup) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ResponseCreateGroup) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ResponseCreateGroup) GetUserPeers() []*UserOutPeer {
	if m != nil {
		return m.UserPeers
	}
	return nil
}

// Changing group title
type RequestEditGroupTitle struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid       int64         `protobuf:"varint,4,opt,name=rid,proto3" json:"rid,omitempty"`
	Title     string        `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,5,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestEditGroupTitle) Reset()      { *m = RequestEditGroupTitle{} }
func (*RequestEditGroupTitle) ProtoMessage() {}
func (*RequestEditGroupTitle) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{17}
}
func (m *RequestEditGroupTitle) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestEditGroupTitle) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestEditGroupTitle.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestEditGroupTitle) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestEditGroupTitle.Merge(m, src)
}
func (m *RequestEditGroupTitle) XXX_Size() int {
	return m.Size()
}
func (m *RequestEditGroupTitle) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestEditGroupTitle.DiscardUnknown(m)
}

var xxx_messageInfo_RequestEditGroupTitle proto.InternalMessageInfo

func (m *RequestEditGroupTitle) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestEditGroupTitle) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestEditGroupTitle) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RequestEditGroupTitle) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

// Sets group short name
type RequestSetGroupShortname struct {
	Peer *GroupOutPeer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
	/// if shortname was empty, then group will become public
	Shortname string `protobuf:"bytes,2,opt,name=shortname,proto3" json:"shortname,omitempty"`
}

func (m *RequestSetGroupShortname) Reset()      { *m = RequestSetGroupShortname{} }
func (*RequestSetGroupShortname) ProtoMessage() {}
func (*RequestSetGroupShortname) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{18}
}
func (m *RequestSetGroupShortname) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestSetGroupShortname) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestSetGroupShortname.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestSetGroupShortname) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestSetGroupShortname.Merge(m, src)
}
func (m *RequestSetGroupShortname) XXX_Size() int {
	return m.Size()
}
func (m *RequestSetGroupShortname) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestSetGroupShortname.DiscardUnknown(m)
}

var xxx_messageInfo_RequestSetGroupShortname proto.InternalMessageInfo

func (m *RequestSetGroupShortname) GetPeer() *GroupOutPeer {
	if m != nil {
		return m.Peer
	}
	return nil
}

func (m *RequestSetGroupShortname) GetShortname() string {
	if m != nil {
		return m.Shortname
	}
	return ""
}

// Changing group avatar
type RequestEditGroupAvatar struct {
	GroupPeer    *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid          int64         `protobuf:"varint,4,opt,name=rid,proto3" json:"rid,omitempty"`
	FileLocation *FileLocation `protobuf:"bytes,3,opt,name=file_location,json=fileLocation,proto3" json:"file_location,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,5,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestEditGroupAvatar) Reset()      { *m = RequestEditGroupAvatar{} }
func (*RequestEditGroupAvatar) ProtoMessage() {}
func (*RequestEditGroupAvatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{19}
}
func (m *RequestEditGroupAvatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestEditGroupAvatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestEditGroupAvatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestEditGroupAvatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestEditGroupAvatar.Merge(m, src)
}
func (m *RequestEditGroupAvatar) XXX_Size() int {
	return m.Size()
}
func (m *RequestEditGroupAvatar) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestEditGroupAvatar.DiscardUnknown(m)
}

var xxx_messageInfo_RequestEditGroupAvatar proto.InternalMessageInfo

func (m *RequestEditGroupAvatar) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestEditGroupAvatar) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestEditGroupAvatar) GetFileLocation() *FileLocation {
	if m != nil {
		return m.FileLocation
	}
	return nil
}

func (m *RequestEditGroupAvatar) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

type ResponseEditGroupAvatar struct {
	Avatar *Avatar    `protobuf:"bytes,1,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Seq    int32      `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	State  []byte     `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Date   int64      `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
	Mid    *UUIDValue `protobuf:"bytes,5,opt,name=mid,proto3" json:"mid,omitempty"`
}

func (m *ResponseEditGroupAvatar) Reset()      { *m = ResponseEditGroupAvatar{} }
func (*ResponseEditGroupAvatar) ProtoMessage() {}
func (*ResponseEditGroupAvatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{20}
}
func (m *ResponseEditGroupAvatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseEditGroupAvatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseEditGroupAvatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseEditGroupAvatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseEditGroupAvatar.Merge(m, src)
}
func (m *ResponseEditGroupAvatar) XXX_Size() int {
	return m.Size()
}
func (m *ResponseEditGroupAvatar) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseEditGroupAvatar.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseEditGroupAvatar proto.InternalMessageInfo

func (m *ResponseEditGroupAvatar) GetAvatar() *Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *ResponseEditGroupAvatar) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ResponseEditGroupAvatar) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ResponseEditGroupAvatar) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *ResponseEditGroupAvatar) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

// Removing group avatar
type RequestRemoveGroupAvatar struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid       int64         `protobuf:"varint,4,opt,name=rid,proto3" json:"rid,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,5,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestRemoveGroupAvatar) Reset()      { *m = RequestRemoveGroupAvatar{} }
func (*RequestRemoveGroupAvatar) ProtoMessage() {}
func (*RequestRemoveGroupAvatar) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{21}
}
func (m *RequestRemoveGroupAvatar) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestRemoveGroupAvatar) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestRemoveGroupAvatar.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestRemoveGroupAvatar) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestRemoveGroupAvatar.Merge(m, src)
}
func (m *RequestRemoveGroupAvatar) XXX_Size() int {
	return m.Size()
}
func (m *RequestRemoveGroupAvatar) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestRemoveGroupAvatar.DiscardUnknown(m)
}

var xxx_messageInfo_RequestRemoveGroupAvatar proto.InternalMessageInfo

func (m *RequestRemoveGroupAvatar) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestRemoveGroupAvatar) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestRemoveGroupAvatar) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

// Edit Group About
type RequestEditGroupAbout struct {
	GroupPeer *GroupOutPeer      `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid       int64              `protobuf:"varint,2,opt,name=rid,proto3" json:"rid,omitempty"`
	About     *types.StringValue `protobuf:"bytes,3,opt,name=about,proto3" json:"about,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,5,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestEditGroupAbout) Reset()      { *m = RequestEditGroupAbout{} }
func (*RequestEditGroupAbout) ProtoMessage() {}
func (*RequestEditGroupAbout) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{22}
}
func (m *RequestEditGroupAbout) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestEditGroupAbout) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestEditGroupAbout.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestEditGroupAbout) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestEditGroupAbout.Merge(m, src)
}
func (m *RequestEditGroupAbout) XXX_Size() int {
	return m.Size()
}
func (m *RequestEditGroupAbout) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestEditGroupAbout.DiscardUnknown(m)
}

var xxx_messageInfo_RequestEditGroupAbout proto.InternalMessageInfo

func (m *RequestEditGroupAbout) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestEditGroupAbout) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestEditGroupAbout) GetAbout() *types.StringValue {
	if m != nil {
		return m.About
	}
	return nil
}

func (m *RequestEditGroupAbout) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

type RequestEditGroupBasePermissions struct {
	GroupPeer          *GroupOutPeer          `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	RandomId           int64                  `protobuf:"varint,2,opt,name=random_id,json=randomId,proto3" json:"random_id,omitempty"`
	GrantedPermissions []GroupAdminPermission `protobuf:"varint,3,rep,packed,name=granted_permissions,json=grantedPermissions,proto3,enum=dialog.GroupAdminPermission" json:"granted_permissions,omitempty"`
	RevokedPermissions []GroupAdminPermission `protobuf:"varint,4,rep,packed,name=revoked_permissions,json=revokedPermissions,proto3,enum=dialog.GroupAdminPermission" json:"revoked_permissions,omitempty"`
}

func (m *RequestEditGroupBasePermissions) Reset()      { *m = RequestEditGroupBasePermissions{} }
func (*RequestEditGroupBasePermissions) ProtoMessage() {}
func (*RequestEditGroupBasePermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{23}
}
func (m *RequestEditGroupBasePermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestEditGroupBasePermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestEditGroupBasePermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestEditGroupBasePermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestEditGroupBasePermissions.Merge(m, src)
}
func (m *RequestEditGroupBasePermissions) XXX_Size() int {
	return m.Size()
}
func (m *RequestEditGroupBasePermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestEditGroupBasePermissions.DiscardUnknown(m)
}

var xxx_messageInfo_RequestEditGroupBasePermissions proto.InternalMessageInfo

func (m *RequestEditGroupBasePermissions) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestEditGroupBasePermissions) GetRandomId() int64 {
	if m != nil {
		return m.RandomId
	}
	return 0
}

func (m *RequestEditGroupBasePermissions) GetGrantedPermissions() []GroupAdminPermission {
	if m != nil {
		return m.GrantedPermissions
	}
	return nil
}

func (m *RequestEditGroupBasePermissions) GetRevokedPermissions() []GroupAdminPermission {
	if m != nil {
		return m.RevokedPermissions
	}
	return nil
}

type RequestEditMemberPermissions struct {
	GroupPeer          *GroupOutPeer          `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	UserPeer           *UserOutPeer           `protobuf:"bytes,2,opt,name=user_peer,json=userPeer,proto3" json:"user_peer,omitempty"`
	GrantedPermissions []GroupAdminPermission `protobuf:"varint,3,rep,packed,name=granted_permissions,json=grantedPermissions,proto3,enum=dialog.GroupAdminPermission" json:"granted_permissions,omitempty"`
	RevokedPermissions []GroupAdminPermission `protobuf:"varint,4,rep,packed,name=revoked_permissions,json=revokedPermissions,proto3,enum=dialog.GroupAdminPermission" json:"revoked_permissions,omitempty"`
}

func (m *RequestEditMemberPermissions) Reset()      { *m = RequestEditMemberPermissions{} }
func (*RequestEditMemberPermissions) ProtoMessage() {}
func (*RequestEditMemberPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{24}
}
func (m *RequestEditMemberPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestEditMemberPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestEditMemberPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestEditMemberPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestEditMemberPermissions.Merge(m, src)
}
func (m *RequestEditMemberPermissions) XXX_Size() int {
	return m.Size()
}
func (m *RequestEditMemberPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestEditMemberPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_RequestEditMemberPermissions proto.InternalMessageInfo

func (m *RequestEditMemberPermissions) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestEditMemberPermissions) GetUserPeer() *UserOutPeer {
	if m != nil {
		return m.UserPeer
	}
	return nil
}

func (m *RequestEditMemberPermissions) GetGrantedPermissions() []GroupAdminPermission {
	if m != nil {
		return m.GrantedPermissions
	}
	return nil
}

func (m *RequestEditMemberPermissions) GetRevokedPermissions() []GroupAdminPermission {
	if m != nil {
		return m.RevokedPermissions
	}
	return nil
}

type ResponseMember struct {
	Member *Member `protobuf:"bytes,1,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *ResponseMember) Reset()      { *m = ResponseMember{} }
func (*ResponseMember) ProtoMessage() {}
func (*ResponseMember) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{25}
}
func (m *ResponseMember) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseMember) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseMember.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseMember) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseMember.Merge(m, src)
}
func (m *ResponseMember) XXX_Size() int {
	return m.Size()
}
func (m *ResponseMember) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseMember.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseMember proto.InternalMessageInfo

func (m *ResponseMember) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

// Inviting user to group
type RequestInviteUser struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid       int64         `protobuf:"varint,4,opt,name=rid,proto3" json:"rid,omitempty"`
	User      *UserOutPeer  `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,5,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestInviteUser) Reset()      { *m = RequestInviteUser{} }
func (*RequestInviteUser) ProtoMessage() {}
func (*RequestInviteUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{26}
}
func (m *RequestInviteUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestInviteUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestInviteUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestInviteUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestInviteUser.Merge(m, src)
}
func (m *RequestInviteUser) XXX_Size() int {
	return m.Size()
}
func (m *RequestInviteUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestInviteUser.DiscardUnknown(m)
}

var xxx_messageInfo_RequestInviteUser proto.InternalMessageInfo

func (m *RequestInviteUser) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestInviteUser) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestInviteUser) GetUser() *UserOutPeer {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RequestInviteUser) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

// Leaving group
type RequestLeaveGroup struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid       int64         `protobuf:"varint,2,opt,name=rid,proto3" json:"rid,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,3,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestLeaveGroup) Reset()      { *m = RequestLeaveGroup{} }
func (*RequestLeaveGroup) ProtoMessage() {}
func (*RequestLeaveGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{27}
}
func (m *RequestLeaveGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestLeaveGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestLeaveGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestLeaveGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestLeaveGroup.Merge(m, src)
}
func (m *RequestLeaveGroup) XXX_Size() int {
	return m.Size()
}
func (m *RequestLeaveGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestLeaveGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RequestLeaveGroup proto.InternalMessageInfo

func (m *RequestLeaveGroup) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestLeaveGroup) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestLeaveGroup) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

// Kicking user from group
type RequestKickUser struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	Rid       int64         `protobuf:"varint,4,opt,name=rid,proto3" json:"rid,omitempty"`
	User      *UserOutPeer  `protobuf:"bytes,3,opt,name=user,proto3" json:"user,omitempty"`
	/// Optimizations drops some info from response to decrease traffic and latency
	Optimizations []UpdateOptimization `protobuf:"varint,5,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestKickUser) Reset()      { *m = RequestKickUser{} }
func (*RequestKickUser) ProtoMessage() {}
func (*RequestKickUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{28}
}
func (m *RequestKickUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestKickUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestKickUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestKickUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestKickUser.Merge(m, src)
}
func (m *RequestKickUser) XXX_Size() int {
	return m.Size()
}
func (m *RequestKickUser) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestKickUser.DiscardUnknown(m)
}

var xxx_messageInfo_RequestKickUser proto.InternalMessageInfo

func (m *RequestKickUser) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestKickUser) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *RequestKickUser) GetUser() *UserOutPeer {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *RequestKickUser) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

// Make user admin
type RequestMakeUserAdmin struct {
	GroupPeer   *GroupOutPeer          `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	UserPeer    *UserOutPeer           `protobuf:"bytes,2,opt,name=user_peer,json=userPeer,proto3" json:"user_peer,omitempty"`
	Permissions []GroupAdminPermission `protobuf:"varint,3,rep,packed,name=permissions,proto3,enum=dialog.GroupAdminPermission" json:"permissions,omitempty"`
}

func (m *RequestMakeUserAdmin) Reset()      { *m = RequestMakeUserAdmin{} }
func (*RequestMakeUserAdmin) ProtoMessage() {}
func (*RequestMakeUserAdmin) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{29}
}
func (m *RequestMakeUserAdmin) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestMakeUserAdmin) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestMakeUserAdmin.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestMakeUserAdmin) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMakeUserAdmin.Merge(m, src)
}
func (m *RequestMakeUserAdmin) XXX_Size() int {
	return m.Size()
}
func (m *RequestMakeUserAdmin) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMakeUserAdmin.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMakeUserAdmin proto.InternalMessageInfo

func (m *RequestMakeUserAdmin) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestMakeUserAdmin) GetUserPeer() *UserOutPeer {
	if m != nil {
		return m.UserPeer
	}
	return nil
}

func (m *RequestMakeUserAdmin) GetPermissions() []GroupAdminPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// A struct mapping a group member to their permissions
// userId the id of the group member
// permissions a list of permissions that user has
type GroupMemberPermission struct {
	UserId      int32                  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Permissions []GroupAdminPermission `protobuf:"varint,2,rep,packed,name=permissions,proto3,enum=dialog.GroupAdminPermission" json:"permissions,omitempty"`
}

func (m *GroupMemberPermission) Reset()      { *m = GroupMemberPermission{} }
func (*GroupMemberPermission) ProtoMessage() {}
func (*GroupMemberPermission) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{30}
}
func (m *GroupMemberPermission) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GroupMemberPermission) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GroupMemberPermission.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GroupMemberPermission) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GroupMemberPermission.Merge(m, src)
}
func (m *GroupMemberPermission) XXX_Size() int {
	return m.Size()
}
func (m *GroupMemberPermission) XXX_DiscardUnknown() {
	xxx_messageInfo_GroupMemberPermission.DiscardUnknown(m)
}

var xxx_messageInfo_GroupMemberPermission proto.InternalMessageInfo

func (m *GroupMemberPermission) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *GroupMemberPermission) GetPermissions() []GroupAdminPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// Fetches the group administration permissions for each of the users from the list
type RequestGetGroupMemberPermissions struct {
	GroupId int32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	UserIds []int32 `protobuf:"varint,2,rep,packed,name=user_ids,json=userIds,proto3" json:"user_ids,omitempty"`
}

func (m *RequestGetGroupMemberPermissions) Reset()      { *m = RequestGetGroupMemberPermissions{} }
func (*RequestGetGroupMemberPermissions) ProtoMessage() {}
func (*RequestGetGroupMemberPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{31}
}
func (m *RequestGetGroupMemberPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetGroupMemberPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetGroupMemberPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetGroupMemberPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetGroupMemberPermissions.Merge(m, src)
}
func (m *RequestGetGroupMemberPermissions) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetGroupMemberPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetGroupMemberPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetGroupMemberPermissions proto.InternalMessageInfo

func (m *RequestGetGroupMemberPermissions) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *RequestGetGroupMemberPermissions) GetUserIds() []int32 {
	if m != nil {
		return m.UserIds
	}
	return nil
}

type ResponseGetGroupMemberPermissions struct {
	Permissions []*GroupMemberPermission `protobuf:"bytes,1,rep,name=permissions,proto3" json:"permissions,omitempty"`
}

func (m *ResponseGetGroupMemberPermissions) Reset()      { *m = ResponseGetGroupMemberPermissions{} }
func (*ResponseGetGroupMemberPermissions) ProtoMessage() {}
func (*ResponseGetGroupMemberPermissions) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{32}
}
func (m *ResponseGetGroupMemberPermissions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetGroupMemberPermissions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetGroupMemberPermissions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetGroupMemberPermissions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetGroupMemberPermissions.Merge(m, src)
}
func (m *ResponseGetGroupMemberPermissions) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetGroupMemberPermissions) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetGroupMemberPermissions.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetGroupMemberPermissions proto.InternalMessageInfo

func (m *ResponseGetGroupMemberPermissions) GetPermissions() []*GroupMemberPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// Update about the user's permissions
type UpdateGroupMemberPermissionsChanged struct {
	GroupId     int32                  `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	UserId      int32                  `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Permissions []GroupAdminPermission `protobuf:"varint,3,rep,packed,name=permissions,proto3,enum=dialog.GroupAdminPermission" json:"permissions,omitempty"`
}

func (m *UpdateGroupMemberPermissionsChanged) Reset()      { *m = UpdateGroupMemberPermissionsChanged{} }
func (*UpdateGroupMemberPermissionsChanged) ProtoMessage() {}
func (*UpdateGroupMemberPermissionsChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{33}
}
func (m *UpdateGroupMemberPermissionsChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupMemberPermissionsChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupMemberPermissionsChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupMemberPermissionsChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupMemberPermissionsChanged.Merge(m, src)
}
func (m *UpdateGroupMemberPermissionsChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupMemberPermissionsChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupMemberPermissionsChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupMemberPermissionsChanged proto.InternalMessageInfo

func (m *UpdateGroupMemberPermissionsChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupMemberPermissionsChanged) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UpdateGroupMemberPermissionsChanged) GetPermissions() []GroupAdminPermission {
	if m != nil {
		return m.Permissions
	}
	return nil
}

// Transfer ownership of group
type RequestTransferOwnership struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
	NewOwner  int32         `protobuf:"varint,2,opt,name=new_owner,json=newOwner,proto3" json:"new_owner,omitempty"`
}

func (m *RequestTransferOwnership) Reset()      { *m = RequestTransferOwnership{} }
func (*RequestTransferOwnership) ProtoMessage() {}
func (*RequestTransferOwnership) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{34}
}
func (m *RequestTransferOwnership) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestTransferOwnership) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestTransferOwnership.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestTransferOwnership) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestTransferOwnership.Merge(m, src)
}
func (m *RequestTransferOwnership) XXX_Size() int {
	return m.Size()
}
func (m *RequestTransferOwnership) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestTransferOwnership.DiscardUnknown(m)
}

var xxx_messageInfo_RequestTransferOwnership proto.InternalMessageInfo

func (m *RequestTransferOwnership) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

func (m *RequestTransferOwnership) GetNewOwner() int32 {
	if m != nil {
		return m.NewOwner
	}
	return 0
}

// Response for invite url methods
type ResponseInviteUrl struct {
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ResponseInviteUrl) Reset()      { *m = ResponseInviteUrl{} }
func (*ResponseInviteUrl) ProtoMessage() {}
func (*ResponseInviteUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{35}
}
func (m *ResponseInviteUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseInviteUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseInviteUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseInviteUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseInviteUrl.Merge(m, src)
}
func (m *ResponseInviteUrl) XXX_Size() int {
	return m.Size()
}
func (m *ResponseInviteUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseInviteUrl.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseInviteUrl proto.InternalMessageInfo

func (m *ResponseInviteUrl) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Building invite url
type RequestGetGroupInviteUrl struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
}

func (m *RequestGetGroupInviteUrl) Reset()      { *m = RequestGetGroupInviteUrl{} }
func (*RequestGetGroupInviteUrl) ProtoMessage() {}
func (*RequestGetGroupInviteUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{36}
}
func (m *RequestGetGroupInviteUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetGroupInviteUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetGroupInviteUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetGroupInviteUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetGroupInviteUrl.Merge(m, src)
}
func (m *RequestGetGroupInviteUrl) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetGroupInviteUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetGroupInviteUrl.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetGroupInviteUrl proto.InternalMessageInfo

func (m *RequestGetGroupInviteUrl) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

// Get group invite url base
type RequestGetGroupInviteUrlBase struct {
}

func (m *RequestGetGroupInviteUrlBase) Reset()      { *m = RequestGetGroupInviteUrlBase{} }
func (*RequestGetGroupInviteUrlBase) ProtoMessage() {}
func (*RequestGetGroupInviteUrlBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{37}
}
func (m *RequestGetGroupInviteUrlBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestGetGroupInviteUrlBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestGetGroupInviteUrlBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestGetGroupInviteUrlBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestGetGroupInviteUrlBase.Merge(m, src)
}
func (m *RequestGetGroupInviteUrlBase) XXX_Size() int {
	return m.Size()
}
func (m *RequestGetGroupInviteUrlBase) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestGetGroupInviteUrlBase.DiscardUnknown(m)
}

var xxx_messageInfo_RequestGetGroupInviteUrlBase proto.InternalMessageInfo

type ResponseGetGroupInviteUrlBase struct {
	Url string `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty"`
}

func (m *ResponseGetGroupInviteUrlBase) Reset()      { *m = ResponseGetGroupInviteUrlBase{} }
func (*ResponseGetGroupInviteUrlBase) ProtoMessage() {}
func (*ResponseGetGroupInviteUrlBase) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{38}
}
func (m *ResponseGetGroupInviteUrlBase) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseGetGroupInviteUrlBase) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseGetGroupInviteUrlBase.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseGetGroupInviteUrlBase) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseGetGroupInviteUrlBase.Merge(m, src)
}
func (m *ResponseGetGroupInviteUrlBase) XXX_Size() int {
	return m.Size()
}
func (m *ResponseGetGroupInviteUrlBase) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseGetGroupInviteUrlBase.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseGetGroupInviteUrlBase proto.InternalMessageInfo

func (m *ResponseGetGroupInviteUrlBase) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

// Revoking invite urls
type RequestRevokeInviteUrl struct {
	GroupPeer *GroupOutPeer `protobuf:"bytes,1,opt,name=group_peer,json=groupPeer,proto3" json:"group_peer,omitempty"`
}

func (m *RequestRevokeInviteUrl) Reset()      { *m = RequestRevokeInviteUrl{} }
func (*RequestRevokeInviteUrl) ProtoMessage() {}
func (*RequestRevokeInviteUrl) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{39}
}
func (m *RequestRevokeInviteUrl) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestRevokeInviteUrl) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestRevokeInviteUrl.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestRevokeInviteUrl) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestRevokeInviteUrl.Merge(m, src)
}
func (m *RequestRevokeInviteUrl) XXX_Size() int {
	return m.Size()
}
func (m *RequestRevokeInviteUrl) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestRevokeInviteUrl.DiscardUnknown(m)
}

var xxx_messageInfo_RequestRevokeInviteUrl proto.InternalMessageInfo

func (m *RequestRevokeInviteUrl) GetGroupPeer() *GroupOutPeer {
	if m != nil {
		return m.GroupPeer
	}
	return nil
}

// Join group method
type RequestJoinGroup struct {
	Token         string               `protobuf:"bytes,1,opt,name=token,proto3" json:"token,omitempty"`
	Optimizations []UpdateOptimization `protobuf:"varint,2,rep,packed,name=optimizations,proto3,enum=dialog.UpdateOptimization" json:"optimizations,omitempty"`
}

func (m *RequestJoinGroup) Reset()      { *m = RequestJoinGroup{} }
func (*RequestJoinGroup) ProtoMessage() {}
func (*RequestJoinGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{40}
}
func (m *RequestJoinGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestJoinGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestJoinGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestJoinGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestJoinGroup.Merge(m, src)
}
func (m *RequestJoinGroup) XXX_Size() int {
	return m.Size()
}
func (m *RequestJoinGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestJoinGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RequestJoinGroup proto.InternalMessageInfo

func (m *RequestJoinGroup) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RequestJoinGroup) GetOptimizations() []UpdateOptimization {
	if m != nil {
		return m.Optimizations
	}
	return nil
}

type ResponseJoinGroup struct {
	Group     *Group         `protobuf:"bytes,1,opt,name=group,proto3" json:"group,omitempty"`
	UserPeers []*UserOutPeer `protobuf:"bytes,7,rep,name=user_peers,json=userPeers,proto3" json:"user_peers,omitempty"`
	Mid       *UUIDValue     `protobuf:"bytes,8,opt,name=mid,proto3" json:"mid,omitempty"`
	Seq       int32          `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	State     []byte         `protobuf:"bytes,3,opt,name=state,proto3" json:"state,omitempty"`
	Date      int64          `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *ResponseJoinGroup) Reset()      { *m = ResponseJoinGroup{} }
func (*ResponseJoinGroup) ProtoMessage() {}
func (*ResponseJoinGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{41}
}
func (m *ResponseJoinGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseJoinGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseJoinGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseJoinGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseJoinGroup.Merge(m, src)
}
func (m *ResponseJoinGroup) XXX_Size() int {
	return m.Size()
}
func (m *ResponseJoinGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseJoinGroup.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseJoinGroup proto.InternalMessageInfo

func (m *ResponseJoinGroup) GetGroup() *Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *ResponseJoinGroup) GetUserPeers() []*UserOutPeer {
	if m != nil {
		return m.UserPeers
	}
	return nil
}

func (m *ResponseJoinGroup) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *ResponseJoinGroup) GetSeq() int32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ResponseJoinGroup) GetState() []byte {
	if m != nil {
		return m.State
	}
	return nil
}

func (m *ResponseJoinGroup) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// Join group by peer
type RequestJoinGroupByPeer struct {
	Peer *GroupOutPeer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer,omitempty"`
}

func (m *RequestJoinGroupByPeer) Reset()      { *m = RequestJoinGroupByPeer{} }
func (*RequestJoinGroupByPeer) ProtoMessage() {}
func (*RequestJoinGroupByPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{42}
}
func (m *RequestJoinGroupByPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestJoinGroupByPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestJoinGroupByPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestJoinGroupByPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestJoinGroupByPeer.Merge(m, src)
}
func (m *RequestJoinGroupByPeer) XXX_Size() int {
	return m.Size()
}
func (m *RequestJoinGroupByPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestJoinGroupByPeer.DiscardUnknown(m)
}

var xxx_messageInfo_RequestJoinGroupByPeer proto.InternalMessageInfo

func (m *RequestJoinGroupByPeer) GetPeer() *GroupOutPeer {
	if m != nil {
		return m.Peer
	}
	return nil
}

type RequestDeleteGroup struct {
	GroupId int32 `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
}

func (m *RequestDeleteGroup) Reset()      { *m = RequestDeleteGroup{} }
func (*RequestDeleteGroup) ProtoMessage() {}
func (*RequestDeleteGroup) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{43}
}
func (m *RequestDeleteGroup) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestDeleteGroup) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestDeleteGroup.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestDeleteGroup) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestDeleteGroup.Merge(m, src)
}
func (m *RequestDeleteGroup) XXX_Size() int {
	return m.Size()
}
func (m *RequestDeleteGroup) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestDeleteGroup.DiscardUnknown(m)
}

var xxx_messageInfo_RequestDeleteGroup proto.InternalMessageInfo

func (m *RequestDeleteGroup) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

//*
// Update notifies that some user got invited to the group
type UpdateGroupMemberInvited struct {
	GroupId int32   `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Member  *Member `protobuf:"bytes,2,opt,name=member,proto3" json:"member,omitempty"`
}

func (m *UpdateGroupMemberInvited) Reset()      { *m = UpdateGroupMemberInvited{} }
func (*UpdateGroupMemberInvited) ProtoMessage() {}
func (*UpdateGroupMemberInvited) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{44}
}
func (m *UpdateGroupMemberInvited) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupMemberInvited) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupMemberInvited.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupMemberInvited) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupMemberInvited.Merge(m, src)
}
func (m *UpdateGroupMemberInvited) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupMemberInvited) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupMemberInvited.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupMemberInvited proto.InternalMessageInfo

func (m *UpdateGroupMemberInvited) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupMemberInvited) GetMember() *Member {
	if m != nil {
		return m.Member
	}
	return nil
}

//*
// Update notifies that current user got invited to the group
// @deprecated
type UpdateGroupInviteObsolete struct {
	GroupId   int32      `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Rid       int64      `protobuf:"varint,9,opt,name=rid,proto3" json:"rid,omitempty"`
	Mid       *UUIDValue `protobuf:"bytes,10,opt,name=mid,proto3" json:"mid,omitempty"`
	InviteUid int32      `protobuf:"varint,5,opt,name=invite_uid,json=inviteUid,proto3" json:"invite_uid,omitempty"`
	Date      int64      `protobuf:"varint,8,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *UpdateGroupInviteObsolete) Reset()      { *m = UpdateGroupInviteObsolete{} }
func (*UpdateGroupInviteObsolete) ProtoMessage() {}
func (*UpdateGroupInviteObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{45}
}
func (m *UpdateGroupInviteObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupInviteObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupInviteObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupInviteObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupInviteObsolete.Merge(m, src)
}
func (m *UpdateGroupInviteObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupInviteObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupInviteObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupInviteObsolete proto.InternalMessageInfo

func (m *UpdateGroupInviteObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupInviteObsolete) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *UpdateGroupInviteObsolete) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *UpdateGroupInviteObsolete) GetInviteUid() int32 {
	if m != nil {
		return m.InviteUid
	}
	return 0
}

func (m *UpdateGroupInviteObsolete) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

//*
// Update notifies that some user got invited to the group
// @deprecated
type UpdateGroupUserInvitedObsolete struct {
	GroupId    int32      `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Rid        int64      `protobuf:"varint,5,opt,name=rid,proto3" json:"rid,omitempty"`
	Mid        *UUIDValue `protobuf:"bytes,6,opt,name=mid,proto3" json:"mid,omitempty"`
	Uid        int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	InviterUid int32      `protobuf:"varint,3,opt,name=inviter_uid,json=inviterUid,proto3" json:"inviter_uid,omitempty"`
	Date       int64      `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *UpdateGroupUserInvitedObsolete) Reset()      { *m = UpdateGroupUserInvitedObsolete{} }
func (*UpdateGroupUserInvitedObsolete) ProtoMessage() {}
func (*UpdateGroupUserInvitedObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{46}
}
func (m *UpdateGroupUserInvitedObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupUserInvitedObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupUserInvitedObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupUserInvitedObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupUserInvitedObsolete.Merge(m, src)
}
func (m *UpdateGroupUserInvitedObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupUserInvitedObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupUserInvitedObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupUserInvitedObsolete proto.InternalMessageInfo

func (m *UpdateGroupUserInvitedObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupUserInvitedObsolete) GetRid() int64 {
	if m != nil {
		return m.Rid
	}
	return 0
}

func (m *UpdateGroupUserInvitedObsolete) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *UpdateGroupUserInvitedObsolete) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateGroupUserInvitedObsolete) GetInviterUid() int32 {
	if m != nil {
		return m.InviterUid
	}
	return 0
}

func (m *UpdateGroupUserInvitedObsolete) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// Update about leaving user
type UpdateGroupUserLeaveObsolete struct {
	GroupId int32      `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Mid     *UUIDValue `protobuf:"bytes,5,opt,name=mid,proto3" json:"mid,omitempty"`
	Uid     int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Date    int64      `protobuf:"varint,3,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *UpdateGroupUserLeaveObsolete) Reset()      { *m = UpdateGroupUserLeaveObsolete{} }
func (*UpdateGroupUserLeaveObsolete) ProtoMessage() {}
func (*UpdateGroupUserLeaveObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{47}
}
func (m *UpdateGroupUserLeaveObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupUserLeaveObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupUserLeaveObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupUserLeaveObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupUserLeaveObsolete.Merge(m, src)
}
func (m *UpdateGroupUserLeaveObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupUserLeaveObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupUserLeaveObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupUserLeaveObsolete proto.InternalMessageInfo

func (m *UpdateGroupUserLeaveObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupUserLeaveObsolete) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *UpdateGroupUserLeaveObsolete) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateGroupUserLeaveObsolete) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// Update about kicking user
type UpdateGroupUserKickObsolete struct {
	GroupId   int32      `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Mid       *UUIDValue `protobuf:"bytes,6,opt,name=mid,proto3" json:"mid,omitempty"`
	Uid       int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	KickerUid int32      `protobuf:"varint,3,opt,name=kicker_uid,json=kickerUid,proto3" json:"kicker_uid,omitempty"`
	Date      int64      `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *UpdateGroupUserKickObsolete) Reset()      { *m = UpdateGroupUserKickObsolete{} }
func (*UpdateGroupUserKickObsolete) ProtoMessage() {}
func (*UpdateGroupUserKickObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{48}
}
func (m *UpdateGroupUserKickObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupUserKickObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupUserKickObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupUserKickObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupUserKickObsolete.Merge(m, src)
}
func (m *UpdateGroupUserKickObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupUserKickObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupUserKickObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupUserKickObsolete proto.InternalMessageInfo

func (m *UpdateGroupUserKickObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupUserKickObsolete) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *UpdateGroupUserKickObsolete) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateGroupUserKickObsolete) GetKickerUid() int32 {
	if m != nil {
		return m.KickerUid
	}
	return 0
}

func (m *UpdateGroupUserKickObsolete) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// Silent group members update
type UpdateGroupMembersUpdateObsolete struct {
	GroupId int32     `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Members []*Member `protobuf:"bytes,2,rep,name=members,proto3" json:"members,omitempty"`
}

func (m *UpdateGroupMembersUpdateObsolete) Reset()      { *m = UpdateGroupMembersUpdateObsolete{} }
func (*UpdateGroupMembersUpdateObsolete) ProtoMessage() {}
func (*UpdateGroupMembersUpdateObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{49}
}
func (m *UpdateGroupMembersUpdateObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupMembersUpdateObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupMembersUpdateObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupMembersUpdateObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupMembersUpdateObsolete.Merge(m, src)
}
func (m *UpdateGroupMembersUpdateObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupMembersUpdateObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupMembersUpdateObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupMembersUpdateObsolete proto.InternalMessageInfo

func (m *UpdateGroupMembersUpdateObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupMembersUpdateObsolete) GetMembers() []*Member {
	if m != nil {
		return m.Members
	}
	return nil
}

// Update about group title change
type UpdateGroupTitleChangedObsolete struct {
	GroupId int32      `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Mid     *UUIDValue `protobuf:"bytes,6,opt,name=mid,proto3" json:"mid,omitempty"`
	Uid     int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Title   string     `protobuf:"bytes,3,opt,name=title,proto3" json:"title,omitempty"`
	Date    int64      `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *UpdateGroupTitleChangedObsolete) Reset()      { *m = UpdateGroupTitleChangedObsolete{} }
func (*UpdateGroupTitleChangedObsolete) ProtoMessage() {}
func (*UpdateGroupTitleChangedObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{50}
}
func (m *UpdateGroupTitleChangedObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupTitleChangedObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupTitleChangedObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupTitleChangedObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupTitleChangedObsolete.Merge(m, src)
}
func (m *UpdateGroupTitleChangedObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupTitleChangedObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupTitleChangedObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupTitleChangedObsolete proto.InternalMessageInfo

func (m *UpdateGroupTitleChangedObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupTitleChangedObsolete) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *UpdateGroupTitleChangedObsolete) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateGroupTitleChangedObsolete) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *UpdateGroupTitleChangedObsolete) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// Update about group about change
type UpdateGroupAboutChangedObsolete struct {
	GroupId int32              `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	About   *types.StringValue `protobuf:"bytes,2,opt,name=about,proto3" json:"about,omitempty"`
}

func (m *UpdateGroupAboutChangedObsolete) Reset()      { *m = UpdateGroupAboutChangedObsolete{} }
func (*UpdateGroupAboutChangedObsolete) ProtoMessage() {}
func (*UpdateGroupAboutChangedObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{51}
}
func (m *UpdateGroupAboutChangedObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupAboutChangedObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupAboutChangedObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupAboutChangedObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupAboutChangedObsolete.Merge(m, src)
}
func (m *UpdateGroupAboutChangedObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupAboutChangedObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupAboutChangedObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupAboutChangedObsolete proto.InternalMessageInfo

func (m *UpdateGroupAboutChangedObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupAboutChangedObsolete) GetAbout() *types.StringValue {
	if m != nil {
		return m.About
	}
	return nil
}

// Update about group avatar change
type UpdateGroupAvatarChangedObsolete struct {
	GroupId int32      `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Mid     *UUIDValue `protobuf:"bytes,6,opt,name=mid,proto3" json:"mid,omitempty"`
	Uid     int32      `protobuf:"varint,2,opt,name=uid,proto3" json:"uid,omitempty"`
	Avatar  *Avatar    `protobuf:"bytes,3,opt,name=avatar,proto3" json:"avatar,omitempty"`
	Date    int64      `protobuf:"varint,4,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *UpdateGroupAvatarChangedObsolete) Reset()      { *m = UpdateGroupAvatarChangedObsolete{} }
func (*UpdateGroupAvatarChangedObsolete) ProtoMessage() {}
func (*UpdateGroupAvatarChangedObsolete) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{52}
}
func (m *UpdateGroupAvatarChangedObsolete) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupAvatarChangedObsolete) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupAvatarChangedObsolete.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupAvatarChangedObsolete) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupAvatarChangedObsolete.Merge(m, src)
}
func (m *UpdateGroupAvatarChangedObsolete) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupAvatarChangedObsolete) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupAvatarChangedObsolete.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupAvatarChangedObsolete proto.InternalMessageInfo

func (m *UpdateGroupAvatarChangedObsolete) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupAvatarChangedObsolete) GetMid() *UUIDValue {
	if m != nil {
		return m.Mid
	}
	return nil
}

func (m *UpdateGroupAvatarChangedObsolete) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func (m *UpdateGroupAvatarChangedObsolete) GetAvatar() *Avatar {
	if m != nil {
		return m.Avatar
	}
	return nil
}

func (m *UpdateGroupAvatarChangedObsolete) GetDate() int64 {
	if m != nil {
		return m.Date
	}
	return 0
}

// Update group short name
type UpdateGroupShortnameChanged struct {
	GroupId   int32  `protobuf:"varint,1,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
	Shortname string `protobuf:"bytes,2,opt,name=shortname,proto3" json:"shortname,omitempty"`
	Uid       int32  `protobuf:"varint,3,opt,name=uid,proto3" json:"uid,omitempty"`
}

func (m *UpdateGroupShortnameChanged) Reset()      { *m = UpdateGroupShortnameChanged{} }
func (*UpdateGroupShortnameChanged) ProtoMessage() {}
func (*UpdateGroupShortnameChanged) Descriptor() ([]byte, []int) {
	return fileDescriptor_6616980d7c5e2870, []int{53}
}
func (m *UpdateGroupShortnameChanged) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateGroupShortnameChanged) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateGroupShortnameChanged.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateGroupShortnameChanged) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateGroupShortnameChanged.Merge(m, src)
}
func (m *UpdateGroupShortnameChanged) XXX_Size() int {
	return m.Size()
}
func (m *UpdateGroupShortnameChanged) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateGroupShortnameChanged.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateGroupShortnameChanged proto.InternalMessageInfo

func (m *UpdateGroupShortnameChanged) GetGroupId() int32 {
	if m != nil {
		return m.GroupId
	}
	return 0
}

func (m *UpdateGroupShortnameChanged) GetShortname() string {
	if m != nil {
		return m.Shortname
	}
	return ""
}

func (m *UpdateGroupShortnameChanged) GetUid() int32 {
	if m != nil {
		return m.Uid
	}
	return 0
}

func init() {
	proto.RegisterEnum("dialog.GroupType", GroupType_name, GroupType_value)
	proto.RegisterEnum("dialog.GroupAdminPermission", GroupAdminPermission_name, GroupAdminPermission_value)
	proto.RegisterType((*Member)(nil), "dialog.Member")
	proto.RegisterType((*Group)(nil), "dialog.Group")
	proto.RegisterType((*GroupData)(nil), "dialog.GroupData")
	proto.RegisterType((*GroupPartialInfo)(nil), "dialog.GroupPartialInfo")
	proto.RegisterType((*UpdateGroup)(nil), "dialog.UpdateGroup")
	proto.RegisterType((*RequestLoadMembers)(nil), "dialog.RequestLoadMembers")
	proto.RegisterType((*ResponseLoadMembers)(nil), "dialog.ResponseLoadMembers")
	proto.RegisterType((*UpdateGroupTitleChanged)(nil), "dialog.UpdateGroupTitleChanged")
	proto.RegisterType((*UpdateGroupAvatarChanged)(nil), "dialog.UpdateGroupAvatarChanged")
	proto.RegisterType((*UpdateGroupAboutChanged)(nil), "dialog.UpdateGroupAboutChanged")
	proto.RegisterType((*UpdateGroupOwnerChanged)(nil), "dialog.UpdateGroupOwnerChanged")
	proto.RegisterType((*UpdateGroupBasePermissionsChanged)(nil), "dialog.UpdateGroupBasePermissionsChanged")
	proto.RegisterType((*UpdateGroupMembersUpdated)(nil), "dialog.UpdateGroupMembersUpdated")
	proto.RegisterType((*UpdateGroupMemberDiff)(nil), "dialog.UpdateGroupMemberDiff")
	proto.RegisterType((*UpdateGroupMembersCountChanged)(nil), "dialog.UpdateGroupMembersCountChanged")
	proto.RegisterType((*RequestCreateGroup)(nil), "dialog.RequestCreateGroup")
	proto.RegisterType((*ResponseCreateGroup)(nil), "dialog.ResponseCreateGroup")
	proto.RegisterType((*RequestEditGroupTitle)(nil), "dialog.RequestEditGroupTitle")
	proto.RegisterType((*RequestSetGroupShortname)(nil), "dialog.RequestSetGroupShortname")
	proto.RegisterType((*RequestEditGroupAvatar)(nil), "dialog.RequestEditGroupAvatar")
	proto.RegisterType((*ResponseEditGroupAvatar)(nil), "dialog.ResponseEditGroupAvatar")
	proto.RegisterType((*RequestRemoveGroupAvatar)(nil), "dialog.RequestRemoveGroupAvatar")
	proto.RegisterType((*RequestEditGroupAbout)(nil), "dialog.RequestEditGroupAbout")
	proto.RegisterType((*RequestEditGroupBasePermissions)(nil), "dialog.RequestEditGroupBasePermissions")
	proto.RegisterType((*RequestEditMemberPermissions)(nil), "dialog.RequestEditMemberPermissions")
	proto.RegisterType((*ResponseMember)(nil), "dialog.ResponseMember")
	proto.RegisterType((*RequestInviteUser)(nil), "dialog.RequestInviteUser")
	proto.RegisterType((*RequestLeaveGroup)(nil), "dialog.RequestLeaveGroup")
	proto.RegisterType((*RequestKickUser)(nil), "dialog.RequestKickUser")
	proto.RegisterType((*RequestMakeUserAdmin)(nil), "dialog.RequestMakeUserAdmin")
	proto.RegisterType((*GroupMemberPermission)(nil), "dialog.GroupMemberPermission")
	proto.RegisterType((*RequestGetGroupMemberPermissions)(nil), "dialog.RequestGetGroupMemberPermissions")
	proto.RegisterType((*ResponseGetGroupMemberPermissions)(nil), "dialog.ResponseGetGroupMemberPermissions")
	proto.RegisterType((*UpdateGroupMemberPermissionsChanged)(nil), "dialog.UpdateGroupMemberPermissionsChanged")
	proto.RegisterType((*RequestTransferOwnership)(nil), "dialog.RequestTransferOwnership")
	proto.RegisterType((*ResponseInviteUrl)(nil), "dialog.ResponseInviteUrl")
	proto.RegisterType((*RequestGetGroupInviteUrl)(nil), "dialog.RequestGetGroupInviteUrl")
	proto.RegisterType((*RequestGetGroupInviteUrlBase)(nil), "dialog.RequestGetGroupInviteUrlBase")
	proto.RegisterType((*ResponseGetGroupInviteUrlBase)(nil), "dialog.ResponseGetGroupInviteUrlBase")
	proto.RegisterType((*RequestRevokeInviteUrl)(nil), "dialog.RequestRevokeInviteUrl")
	proto.RegisterType((*RequestJoinGroup)(nil), "dialog.RequestJoinGroup")
	proto.RegisterType((*ResponseJoinGroup)(nil), "dialog.ResponseJoinGroup")
	proto.RegisterType((*RequestJoinGroupByPeer)(nil), "dialog.RequestJoinGroupByPeer")
	proto.RegisterType((*RequestDeleteGroup)(nil), "dialog.RequestDeleteGroup")
	proto.RegisterType((*UpdateGroupMemberInvited)(nil), "dialog.UpdateGroupMemberInvited")
	proto.RegisterType((*UpdateGroupInviteObsolete)(nil), "dialog.UpdateGroupInviteObsolete")
	proto.RegisterType((*UpdateGroupUserInvitedObsolete)(nil), "dialog.UpdateGroupUserInvitedObsolete")
	proto.RegisterType((*UpdateGroupUserLeaveObsolete)(nil), "dialog.UpdateGroupUserLeaveObsolete")
	proto.RegisterType((*UpdateGroupUserKickObsolete)(nil), "dialog.UpdateGroupUserKickObsolete")
	proto.RegisterType((*UpdateGroupMembersUpdateObsolete)(nil), "dialog.UpdateGroupMembersUpdateObsolete")
	proto.RegisterType((*UpdateGroupTitleChangedObsolete)(nil), "dialog.UpdateGroupTitleChangedObsolete")
	proto.RegisterType((*UpdateGroupAboutChangedObsolete)(nil), "dialog.UpdateGroupAboutChangedObsolete")
	proto.RegisterType((*UpdateGroupAvatarChangedObsolete)(nil), "dialog.UpdateGroupAvatarChangedObsolete")
	proto.RegisterType((*UpdateGroupShortnameChanged)(nil), "dialog.UpdateGroupShortnameChanged")
}

func init() { proto.RegisterFile("groups.proto", fileDescriptor_6616980d7c5e2870) }

var fileDescriptor_6616980d7c5e2870 = []byte{
	// 3227 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x5b, 0x4f, 0x6c, 0xe4, 0x56,
	0x19, 0x5f, 0x7b, 0x3c, 0x13, 0xcf, 0x97, 0x3f, 0xeb, 0x38, 0xc9, 0xee, 0x64, 0x36, 0x99, 0x64,
	0xbd, 0x7f, 0x9a, 0x2e, 0xdb, 0xa4, 0xdd, 0x2e, 0x6d, 0x59, 0x21, 0x96, 0xc9, 0x66, 0x9a, 0x9d,
	0xd9, 0xcd, 0x24, 0x9a, 0x4c, 0xb6, 0x02, 0x55, 0x1a, 0x39, 0xe3, 0x97, 0xac, 0xc9, 0x8c, 0x3d,
	0xb5, 0x3d, 0xd9, 0x6e, 0xa9, 0x0a, 0x02, 0x55, 0xa0, 0x4a, 0x15, 0x15, 0x05, 0x6e, 0x50, 0x71,
	0x28, 0xea, 0x85, 0x43, 0x2f, 0x5c, 0xb8, 0x80, 0x90, 0x10, 0x07, 0x90, 0x2a, 0xb8, 0xf4, 0x80,
	0x10, 0x4d, 0x91, 0x40, 0x05, 0xa1, 0x8a, 0x3b, 0x12, 0xf2, 0x7b, 0xb6, 0xc7, 0x7e, 0xb6, 0xe7,
	0x4f, 0x92, 0xa6, 0x08, 0x71, 0xda, 0x89, 0xbf, 0xef, 0xbd, 0xdf, 0xf7, 0xef, 0xbd, 0xef, 0x7b,
	0xdf, 0x7b, 0x0b, 0x23, 0xbb, 0x86, 0xde, 0x6e, 0x99, 0x8b, 0x2d, 0x43, 0xb7, 0x74, 0x31, 0xa5,
	0xa8, 0x72, 0x43, 0xdf, 0xcd, 0xce, 0xed, 0xea, 0xfa, 0x6e, 0x03, 0x2d, 0xe1, 0xaf, 0xdb, 0xed,
	0x9d, 0x25, 0x4b, 0x6d, 0x22, 0xd3, 0x92, 0x9b, 0x2d, 0xc2, 0x98, 0xcd, 0xd1, 0x0c, 0x0f, 0x0c,
	0xb9, 0xd5, 0x42, 0x86, 0x33, 0x51, 0xf6, 0x1c, 0x4d, 0x47, 0xcd, 0x96, 0xf5, 0xd0, 0x21, 0xce,
	0x38, 0x44, 0xb9, 0xa5, 0x2e, 0xc9, 0x9a, 0xa6, 0x5b, 0xb2, 0xa5, 0xea, 0x9a, 0x3b, 0x74, 0x5c,
	0x41, 0x3b, 0xaa, 0xa6, 0xfa, 0x3f, 0x4d, 0x34, 0x55, 0xb3, 0x8e, 0x1a, 0x0d, 0x59, 0x43, 0x7a,
	0xdb, 0xfd, 0x38, 0xdc, 0x42, 0x1d, 0xbc, 0xa9, 0x26, 0x52, 0x54, 0xb9, 0x26, 0x6b, 0x4a, 0x6d,
	0x47, 0x6d, 0x20, 0xef, 0xb3, 0x59, 0x97, 0x1b, 0x72, 0x6b, 0x7b, 0xc9, 0xf9, 0x97, 0x7c, 0x96,
	0x7e, 0xcc, 0x42, 0x6a, 0x0d, 0x35, 0xb7, 0x91, 0x21, 0xce, 0x41, 0xa2, 0xad, 0x2a, 0x19, 0x66,
	0x9e, 0x59, 0x48, 0x2e, 0x8f, 0xbe, 0xf6, 0xd1, 0xe3, 0x69, 0x18, 0xda, 0x57, 0x4d, 0x75, 0xbb,
	0x81, 0x2a, 0x36, 0x45, 0xbc, 0x0a, 0xa0, 0x6a, 0xfb, 0xaa, 0x85, 0x94, 0x9a, 0x6c, 0x65, 0x12,
	0xf3, 0xcc, 0x42, 0x82, 0xe6, 0x4b, 0x3b, 0x0c, 0x79, 0x4b, 0x5c, 0x83, 0xe1, 0x16, 0x32, 0x9a,
	0xaa, 0x69, 0xda, 0xe2, 0x67, 0x92, 0xf3, 0x89, 0x85, 0xb1, 0x6b, 0x33, 0x8b, 0xc4, 0xac, 0x8b,
	0xab, 0xb6, 0xad, 0xf3, 0x4a, 0x53, 0xd5, 0x36, 0x3c, 0x26, 0x7a, 0x32, 0xff, 0x78, 0xf1, 0x02,
	0x24, 0xeb, 0x0d, 0xbd, 0xbe, 0x97, 0x49, 0x45, 0xe1, 0x12, 0x9a, 0x78, 0x1b, 0x40, 0x41, 0x0d,
	0xe4, 0x48, 0x38, 0x34, 0xcf, 0x2c, 0x0c, 0x5f, 0xcb, 0x2e, 0x12, 0x1b, 0x2f, 0xba, 0x0e, 0x58,
	0xac, 0xba, 0x1e, 0x0c, 0x49, 0xef, 0x0c, 0xce, 0x5b, 0x25, 0x8e, 0x67, 0x85, 0x44, 0x89, 0xe3,
	0x39, 0x21, 0x29, 0xbd, 0x9d, 0x80, 0x24, 0x96, 0x57, 0x9c, 0x05, 0x36, 0xce, 0x42, 0xac, 0xaa,
	0x88, 0x8f, 0xc1, 0xb0, 0x5c, 0xaf, 0x23, 0xd3, 0xac, 0xdd, 0x97, 0xcd, 0xfb, 0x19, 0x16, 0x4b,
	0x3a, 0xf2, 0xda, 0x47, 0x8f, 0xf3, 0x90, 0x52, 0x64, 0x6d, 0x17, 0x19, 0x15, 0x20, 0x0c, 0xb7,
	0x65, 0xf3, 0xbe, 0x78, 0x09, 0x38, 0x45, 0xb6, 0xe4, 0xcc, 0x2c, 0x96, 0x73, 0x3c, 0x60, 0x9a,
	0x15, 0xd9, 0x92, 0x2b, 0x98, 0x2c, 0x2e, 0xc1, 0xb0, 0x89, 0x1a, 0x3b, 0xb5, 0x26, 0x76, 0x53,
	0x26, 0x87, 0xb9, 0xc7, 0x5c, 0x6e, 0xe2, 0xbc, 0x0a, 0xd8, 0x2c, 0x8e, 0x23, 0x25, 0x48, 0x5a,
	0xaa, 0xd5, 0x40, 0xd8, 0x45, 0x69, 0x57, 0x80, 0xfb, 0xaa, 0xa2, 0x20, 0xad, 0x42, 0x48, 0xe2,
	0x4d, 0x00, 0x1c, 0xee, 0x35, 0xeb, 0x61, 0x0b, 0x65, 0xa6, 0xe7, 0x99, 0x85, 0x31, 0x4a, 0x82,
	0xea, 0xc3, 0x16, 0x0a, 0x19, 0x68, 0xd7, 0xa5, 0x88, 0x45, 0x48, 0x9b, 0xf7, 0x75, 0xc3, 0xd2,
	0xe4, 0x26, 0xca, 0x4c, 0x60, 0x99, 0x66, 0x42, 0x96, 0xde, 0xb4, 0x0c, 0x55, 0xdb, 0xbd, 0x27,
	0x37, 0xda, 0xe1, 0xa9, 0xbc, 0xd1, 0xc4, 0xca, 0x25, 0x8e, 0xcf, 0x08, 0xd3, 0x25, 0x8e, 0x4f,
	0x09, 0x43, 0x25, 0x8e, 0x9f, 0x14, 0xa6, 0x4a, 0x1c, 0x9f, 0x15, 0xce, 0x95, 0x38, 0x5e, 0x10,
	0xc6, 0x4b, 0x1c, 0xcf, 0x0b, 0xe9, 0x12, 0xc7, 0xa7, 0x05, 0x28, 0x71, 0x3c, 0x08, 0xc3, 0x25,
	0x8e, 0x1f, 0x17, 0xc4, 0x12, 0xc7, 0x8b, 0xc2, 0x44, 0x89, 0xe3, 0x67, 0x84, 0x59, 0xe9, 0xb7,
	0x49, 0x48, 0x7b, 0xc6, 0x13, 0xaf, 0x02, 0x6f, 0xb6, 0xe4, 0x3a, 0xaa, 0x39, 0x1e, 0xf3, 0x59,
	0x78, 0x6b, 0xab, 0xb8, 0x82, 0x85, 0xaa, 0x0c, 0x61, 0x96, 0xa2, 0xd2, 0xb1, 0x19, 0x1b, 0x6f,
	0xb3, 0xcf, 0x42, 0x4a, 0xde, 0x97, 0x2d, 0xd9, 0xc0, 0x86, 0xf5, 0xf9, 0x20, 0x8f, 0xbf, 0xba,
	0x1a, 0xd6, 0xf5, 0x66, 0x4b, 0xae, 0x5b, 0x15, 0x87, 0x59, 0xbc, 0x0e, 0x63, 0xc4, 0x75, 0x66,
	0x4d, 0x6e, 0xea, 0x6d, 0xcd, 0xca, 0x70, 0x51, 0x01, 0x34, 0xea, 0x30, 0xe5, 0x31, 0x0f, 0xe5,
	0xa0, 0xe4, 0xe0, 0x0e, 0x7a, 0x02, 0x46, 0xf5, 0x07, 0x1a, 0x32, 0x6a, 0x6d, 0x13, 0x19, 0xb6,
	0x11, 0x52, 0x51, 0xa8, 0xc3, 0x98, 0x67, 0xcb, 0x44, 0x46, 0x51, 0xb1, 0x97, 0x4f, 0xdd, 0x40,
	0xf2, 0xa1, 0x97, 0x8f, 0x33, 0x38, 0x6f, 0x89, 0x5f, 0x84, 0xa4, 0xbc, 0xad, 0xb7, 0xad, 0x0c,
	0xdf, 0x47, 0x64, 0x50, 0xc6, 0xc6, 0x03, 0x83, 0xf1, 0x95, 0x3e, 0x4a, 0x7c, 0x89, 0xf7, 0x40,
	0xd8, 0x96, 0x4d, 0x54, 0xf3, 0x6f, 0x47, 0x30, 0xf8, 0x76, 0x74, 0xda, 0x9e, 0x64, 0x23, 0x6a,
	0x4b, 0x1a, 0xee, 0xb2, 0x25, 0x3d, 0x03, 0xe9, 0x96, 0xaa, 0x69, 0xc4, 0xa4, 0x23, 0x58, 0x8f,
	0x73, 0x21, 0x3d, 0x8a, 0x9a, 0xf5, 0xd4, 0x75, 0x12, 0x91, 0x3c, 0xe1, 0xce, 0x5b, 0xd2, 0xef,
	0x12, 0x20, 0x60, 0xb9, 0x36, 0x64, 0xc3, 0x52, 0xe5, 0x46, 0x51, 0xdb, 0xd1, 0x8f, 0x79, 0x07,
	0xf2, 0x34, 0x48, 0x74, 0xd1, 0xe0, 0x3a, 0x70, 0x38, 0x06, 0xb9, 0x3e, 0x63, 0x10, 0x73, 0xdb,
	0x53, 0x93, 0x05, 0x95, 0xc4, 0x0b, 0x8a, 0x5a, 0x1b, 0xce, 0x8a, 0x0a, 0x38, 0x39, 0x75, 0x24,
	0x27, 0x77, 0x16, 0xe7, 0xd0, 0x20, 0x8b, 0x93, 0xda, 0x5c, 0xf9, 0x9e, 0x9b, 0x6b, 0xc0, 0x9f,
	0xe9, 0x41, 0xfc, 0xb9, 0x02, 0xc3, 0x5b, 0x2d, 0x45, 0xb6, 0x10, 0xc9, 0x25, 0x63, 0x1d, 0x4f,
	0x62, 0xd7, 0xb9, 0xd9, 0x80, 0xed, 0x9a, 0x0d, 0xa4, 0xdf, 0x33, 0x20, 0x56, 0xd0, 0x0b, 0x6d,
	0x64, 0x5a, 0x77, 0x75, 0x59, 0x21, 0x52, 0x99, 0xe2, 0xe7, 0x20, 0x89, 0x97, 0xbe, 0xb3, 0xd5,
	0x4d, 0x06, 0x86, 0xaf, 0xb7, 0xad, 0x0d, 0x84, 0x8c, 0x90, 0x7f, 0xf1, 0x08, 0xdb, 0x53, 0x0d,
	0xb5, 0xa9, 0x5a, 0x18, 0x39, 0x14, 0x55, 0x84, 0x26, 0x7e, 0x01, 0x38, 0x0d, 0xbd, 0x68, 0x39,
	0x3b, 0x5f, 0x58, 0xe3, 0xe5, 0x87, 0x16, 0x32, 0x23, 0x7d, 0x84, 0xc7, 0xdd, 0x98, 0x39, 0xb8,
	0x39, 0x0d, 0x67, 0xd5, 0xe6, 0xa2, 0xd2, 0xd8, 0x5d, 0xdc, 0x35, 0x5a, 0xf5, 0xc5, 0x55, 0xa3,
	0x55, 0x77, 0x14, 0x91, 0xde, 0x65, 0x60, 0xa2, 0x82, 0xcc, 0x96, 0xae, 0x99, 0xc8, 0xaf, 0xd5,
	0x32, 0xa4, 0xea, 0x6d, 0xc3, 0xd4, 0x0d, 0xc7, 0x2a, 0xfd, 0xe0, 0x7a, 0x1e, 0x26, 0x23, 0xc5,
	0xa7, 0x61, 0xc8, 0xd9, 0x59, 0x33, 0x89, 0xf9, 0x44, 0xd8, 0xbb, 0xb4, 0xbc, 0x2e, 0xf7, 0x8d,
	0xd9, 0x83, 0x9b, 0x59, 0xc8, 0x84, 0x45, 0x26, 0x62, 0x4a, 0xbb, 0x70, 0xd6, 0xe7, 0xce, 0xaa,
	0x1d, 0xcf, 0xb7, 0xee, 0xdb, 0x4b, 0x4c, 0x11, 0x17, 0x80, 0x27, 0x7b, 0x77, 0xdc, 0x52, 0x1d,
	0xc2, 0xe4, 0xfe, 0xd2, 0x8e, 0xf4, 0x55, 0xc8, 0xf8, 0x80, 0x48, 0x38, 0x0f, 0x8e, 0xd4, 0x59,
	0x1f, 0x6c, 0xb7, 0xf5, 0xe1, 0x8e, 0x73, 0x98, 0xa5, 0x57, 0x99, 0x80, 0x9a, 0x79, 0x7b, 0x6f,
	0x1e, 0x1c, 0xdc, 0x4b, 0x07, 0xec, 0x21, 0xd3, 0x81, 0xb4, 0x17, 0x10, 0x63, 0xdd, 0x4e, 0x5a,
	0x83, 0x8b, 0x71, 0x19, 0x86, 0xdc, 0x64, 0x18, 0x19, 0xeb, 0xa9, 0x36, 0xce, 0x83, 0xd2, 0xdb,
	0x0c, 0x9c, 0xf7, 0xa1, 0x2d, 0x07, 0xf7, 0xfd, 0xc1, 0x71, 0xa3, 0x12, 0x10, 0x7b, 0xf4, 0x04,
	0x24, 0xbd, 0x02, 0xd3, 0x3e, 0x31, 0x9d, 0x45, 0x43, 0xbe, 0x0c, 0x22, 0x9e, 0x6f, 0x85, 0xb0,
	0x83, 0xac, 0x10, 0xe9, 0x57, 0x0c, 0x4c, 0x85, 0x04, 0x58, 0x51, 0x77, 0x76, 0xc4, 0x6b, 0x30,
	0x6a, 0xa0, 0xa6, 0xbe, 0x8f, 0x14, 0x5c, 0x7e, 0x98, 0x19, 0x66, 0x3e, 0x11, 0x96, 0x60, 0xc4,
	0xe1, 0xb1, 0xcb, 0x0f, 0x7b, 0xb1, 0x8f, 0xca, 0x8a, 0x82, 0x94, 0xda, 0x40, 0xc2, 0x8c, 0xe0,
	0x31, 0xee, 0x86, 0x71, 0x0d, 0xdc, 0x32, 0xaa, 0x56, 0xc7, 0xa5, 0x56, 0x22, 0x4a, 0xf3, 0x11,
	0x87, 0xe7, 0x96, 0xcd, 0x22, 0xbd, 0x02, 0xb9, 0xb0, 0x15, 0x31, 0x69, 0x70, 0x4f, 0x87, 0xf0,
	0xd9, 0xde, 0xf8, 0xdf, 0xe5, 0xbc, 0x1d, 0xfd, 0x16, 0x2e, 0xa0, 0x48, 0x7e, 0x98, 0x83, 0x84,
	0xe1, 0xe0, 0x85, 0x32, 0xb3, 0x4d, 0x09, 0x14, 0xb8, 0xe9, 0x63, 0x29, 0x70, 0x9f, 0x81, 0x24,
	0xf1, 0x16, 0xd9, 0x28, 0x27, 0xbc, 0xe9, 0x4c, 0x64, 0xc4, 0xe5, 0x10, 0x3c, 0x80, 0xaa, 0x56,
	0x53, 0x83, 0x57, 0xab, 0xab, 0xc0, 0xdb, 0x33, 0xe1, 0x42, 0x80, 0x1f, 0xbc, 0x10, 0xf0, 0x06,
	0x8b, 0xeb, 0x30, 0xaa, 0xb7, 0x2c, 0xb5, 0xa9, 0xbe, 0x44, 0x8e, 0xd2, 0x99, 0x21, 0xbc, 0xd0,
	0xb2, 0x9e, 0x2e, 0xd8, 0xd5, 0xeb, 0x3e, 0x96, 0x50, 0x21, 0x1e, 0x18, 0xff, 0x49, 0x55, 0x8f,
	0x3d, 0x32, 0xe2, 0xcf, 0x7d, 0x19, 0xd1, 0x1f, 0x15, 0x02, 0x24, 0x4c, 0xf4, 0x82, 0x53, 0x36,
	0xd8, 0x3f, 0xc5, 0x49, 0x48, 0x9a, 0x96, 0x6c, 0x11, 0xc7, 0x8e, 0x54, 0xc8, 0x1f, 0x76, 0x52,
	0x27, 0xf5, 0x00, 0x49, 0xd8, 0xa3, 0x01, 0x51, 0xdd, 0xcc, 0x7f, 0x0d, 0x00, 0xef, 0x87, 0xb8,
	0x7d, 0x80, 0x4f, 0xe8, 0xd1, 0x4e, 0xaf, 0xa4, 0x6d, 0x36, 0xfb, 0x57, 0xaf, 0xac, 0xe8, 0x9c,
	0x98, 0xbf, 0xc3, 0xc2, 0x94, 0xa3, 0x49, 0x41, 0x51, 0xad, 0x4e, 0x86, 0x14, 0x97, 0xdd, 0x40,
	0xb1, 0x31, 0x07, 0x29, 0x56, 0x48, 0xac, 0xd8, 0x14, 0x77, 0x65, 0x70, 0xb1, 0x2b, 0xa3, 0x9f,
	0x03, 0x70, 0x28, 0x4e, 0x92, 0x47, 0x8b, 0x93, 0x1e, 0xfe, 0xfc, 0x11, 0x03, 0x19, 0xe7, 0xf7,
	0x26, 0x22, 0x06, 0xd9, 0xf4, 0x6a, 0xd7, 0xa7, 0x81, 0x1b, 0xd4, 0x1c, 0x78, 0x80, 0xf8, 0x19,
	0x7f, 0xfd, 0xcc, 0xfa, 0x0b, 0xed, 0x70, 0x85, 0xdc, 0x43, 0xc0, 0x9f, 0xb1, 0x70, 0x86, 0x76,
	0x19, 0x29, 0x0d, 0x4e, 0xc6, 0x67, 0xb7, 0x61, 0x74, 0x47, 0x6d, 0xa0, 0x5a, 0x43, 0xaf, 0x63,
	0x83, 0x3a, 0x81, 0xeb, 0xe1, 0x3c, 0xab, 0x36, 0xd0, 0x5d, 0x87, 0x46, 0x97, 0x7a, 0x23, 0x3b,
	0x3e, 0xe2, 0x49, 0x7b, 0xf6, 0x97, 0x0c, 0x9c, 0x75, 0xc3, 0x9f, 0xb6, 0xdc, 0x65, 0xaf, 0xe8,
	0x62, 0xa2, 0x8a, 0x2e, 0xef, 0x14, 0xe2, 0xac, 0x6a, 0x36, 0x62, 0x55, 0x27, 0xfc, 0xab, 0x5a,
	0xc4, 0x67, 0x04, 0x72, 0x14, 0x4b, 0xe0, 0x03, 0x81, 0xbd, 0xd2, 0x13, 0x4d, 0x55, 0xc1, 0xc7,
	0xac, 0xc8, 0x0c, 0x60, 0x53, 0x7b, 0xd5, 0xb2, 0xff, 0xec, 0x44, 0x67, 0x05, 0xa7, 0xe4, 0x13,
	0x77, 0xff, 0x09, 0x3b, 0xed, 0xa7, 0x11, 0x1b, 0x14, 0xae, 0x6d, 0x8f, 0x53, 0x5b, 0x36, 0x56,
	0x5b, 0xaf, 0x1e, 0x4e, 0x1c, 0xb6, 0x3d, 0x72, 0xc2, 0xf6, 0xfa, 0x3b, 0x0b, 0x73, 0xb4, 0xbd,
	0xa8, 0xb2, 0xf8, 0x58, 0x2c, 0x77, 0x05, 0xd2, 0x86, 0xac, 0x29, 0x7a, 0xb3, 0x16, 0x67, 0x3f,
	0x9e, 0xd0, 0x8b, 0x8a, 0xf8, 0x3c, 0x4c, 0xec, 0x1a, 0xb2, 0x66, 0x21, 0x25, 0x90, 0x9b, 0x13,
	0x83, 0xe7, 0x66, 0xd1, 0x99, 0xc7, 0xaf, 0xcd, 0xf3, 0x30, 0x61, 0xa0, 0x7d, 0x7d, 0x8f, 0x9a,
	0x9d, 0x3b, 0xc4, 0xec, 0xce, 0x3c, 0xfd, 0x27, 0xff, 0x7f, 0xb3, 0x30, 0xe3, 0xb3, 0x36, 0x29,
	0x49, 0x8f, 0xdb, 0xd4, 0x37, 0x21, 0xed, 0x25, 0x7f, 0xe7, 0x5c, 0xd6, 0x4f, 0xc1, 0xc7, 0xbb,
	0xa5, 0xc0, 0xff, 0xb0, 0xfd, 0x9f, 0x83, 0x31, 0x77, 0x6b, 0x74, 0xba, 0x3e, 0x97, 0x21, 0xe5,
	0x74, 0x88, 0x98, 0xc8, 0x0e, 0x91, 0x43, 0xed, 0xb5, 0xcf, 0xbe, 0xc5, 0xc2, 0xb8, 0x03, 0x52,
	0xc4, 0x17, 0x25, 0xb6, 0xa1, 0x4f, 0x66, 0x83, 0x7d, 0x0a, 0x38, 0xdb, 0x73, 0xce, 0x8e, 0xd3,
	0x8f, 0xa7, 0x31, 0xff, 0x49, 0x6f, 0x34, 0x7f, 0x65, 0x3c, 0x0b, 0xdd, 0x45, 0xb2, 0x93, 0x88,
	0x4e, 0x66, 0x53, 0x0e, 0x69, 0x9a, 0xf8, 0x44, 0x35, 0xfd, 0x21, 0x0b, 0xa7, 0x9d, 0xdf, 0x77,
	0xd4, 0xfa, 0xde, 0xff, 0x23, 0x81, 0xb2, 0xcf, 0xb7, 0x59, 0x98, 0x74, 0x7e, 0xaf, 0xc9, 0x7b,
	0x78, 0xa5, 0xe0, 0x85, 0xfe, 0xdf, 0xb1, 0xf9, 0x51, 0xb7, 0x9b, 0x89, 0xa3, 0xdd, 0x6e, 0xf6,
	0x30, 0xc5, 0xeb, 0x0c, 0x4c, 0xf9, 0x9a, 0x13, 0x9d, 0x39, 0xfd, 0x1d, 0x2d, 0xa6, 0x4b, 0x47,
	0x4b, 0xbc, 0x1b, 0x14, 0xb7, 0x9f, 0xe6, 0x53, 0xb0, 0xec, 0xf0, 0x0f, 0x97, 0xbe, 0xc7, 0xc0,
	0xbc, 0x23, 0xdb, 0xaa, 0x73, 0x98, 0x09, 0xe7, 0xa8, 0xfe, 0x9b, 0x26, 0x0b, 0xe4, 0xec, 0x5f,
	0x53, 0x15, 0x22, 0x59, 0x98, 0x93, 0x68, 0xd1, 0xcb, 0x4c, 0xdf, 0x64, 0xe0, 0xbc, 0xbb, 0xd5,
	0xc6, 0xcb, 0x75, 0x33, 0x68, 0x0a, 0x06, 0x9f, 0x7a, 0x67, 0x03, 0xa6, 0xa0, 0x07, 0x05, 0x7d,
	0xd5, 0x63, 0x8f, 0xff, 0x35, 0x03, 0x17, 0x42, 0xfd, 0xa4, 0x23, 0xb5, 0x0f, 0xfb, 0x6c, 0x5b,
	0x1e, 0x73, 0x4c, 0x4a, 0xef, 0x74, 0x0e, 0x05, 0x55, 0x43, 0xd6, 0xcc, 0x1d, 0x64, 0xe0, 0xbe,
	0xab, 0x79, 0x5f, 0x6d, 0x1d, 0x57, 0xb1, 0xa7, 0xa1, 0x07, 0x35, 0x7c, 0x03, 0x19, 0xad, 0x19,
	0xaf, 0xa1, 0x07, 0x18, 0xb3, 0x87, 0xe7, 0x57, 0xec, 0xa4, 0x41, 0xec, 0xef, 0xe4, 0x55, 0xa3,
	0x61, 0x1f, 0xaa, 0xda, 0x46, 0x03, 0xcb, 0x96, 0xae, 0xd8, 0x3f, 0x7b, 0x79, 0xee, 0x65, 0x4f,
	0x5f, 0x37, 0x7a, 0x3a, 0x93, 0x1d, 0x83, 0xbe, 0x3d, 0x74, 0xf8, 0xbc, 0x57, 0xf3, 0x85, 0xd0,
	0xed, 0x4a, 0xbb, 0xc7, 0xe8, 0x0d, 0x98, 0xa5, 0x43, 0x3f, 0x30, 0x7c, 0x70, 0x6b, 0xbc, 0xe4,
	0xf5, 0x03, 0x2a, 0xb8, 0x7e, 0x3a, 0x49, 0x5b, 0xbc, 0xcd, 0x80, 0xe0, 0xfc, 0x2e, 0xe9, 0xaa,
	0xb6, 0xea, 0xde, 0x53, 0x59, 0xfa, 0x1e, 0xd2, 0x88, 0x0e, 0xa1, 0x46, 0x24, 0xa6, 0x89, 0x65,
	0x3a, 0x49, 0xb1, 0x3d, 0x93, 0x54, 0x70, 0xa3, 0x1b, 0x28, 0x47, 0xfd, 0x8b, 0xe9, 0x04, 0x5e,
	0x40, 0x50, 0xff, 0x5d, 0x5c, 0x3f, 0xbd, 0xb7, 0xa1, 0x7e, 0x7a, 0x6f, 0xee, 0x51, 0x9f, 0xef,
	0x76, 0xd4, 0x3f, 0x4a, 0x2f, 0xa1, 0x77, 0x73, 0x2f, 0x29, 0xa4, 0x24, 0xdd, 0x0b, 0x0c, 0x4f,
	0xe5, 0xe5, 0x87, 0x78, 0x41, 0x1f, 0xb6, 0x8f, 0xd5, 0xc3, 0xca, 0xcf, 0x7b, 0xfd, 0xf1, 0x15,
	0xfc, 0x3e, 0x87, 0x58, 0xb9, 0xef, 0xfd, 0xb3, 0xc7, 0xec, 0x8d, 0xc0, 0xf5, 0x1a, 0xd9, 0xae,
	0x49, 0xac, 0x0f, 0xb6, 0x47, 0xbb, 0x07, 0x04, 0xb6, 0xdb, 0x01, 0x41, 0xfa, 0x23, 0x13, 0xb8,
	0xb3, 0x21, 0x40, 0xeb, 0xdb, 0xa6, 0x6e, 0x2b, 0x36, 0x00, 0x9e, 0x53, 0xe5, 0xa5, 0x63, 0xab,
	0x3c, 0x27, 0x56, 0xa0, 0x6b, 0xac, 0x78, 0x2f, 0xba, 0x6a, 0x6d, 0xa7, 0x85, 0x94, 0x8c, 0x79,
	0xd1, 0xb5, 0xa5, 0x2a, 0xe2, 0x79, 0x27, 0x62, 0xf8, 0x28, 0x50, 0x4c, 0x92, 0xde, 0x64, 0x03,
	0x97, 0x29, 0xf8, 0x5d, 0x09, 0xb1, 0xe5, 0xe1, 0x75, 0x4c, 0xc6, 0xea, 0x78, 0x8d, 0xe8, 0x98,
	0x8a, 0xd1, 0x31, 0x34, 0xc6, 0x56, 0xd9, 0x79, 0xe5, 0xc6, 0xc6, 0xbe, 0x72, 0x5b, 0x84, 0x61,
	0xa2, 0xb2, 0x81, 0x8d, 0x12, 0x79, 0x81, 0xe4, 0x58, 0xcd, 0xf0, 0x5b, 0x85, 0x8b, 0xb7, 0xca,
	0xbb, 0x0c, 0xcc, 0x50, 0x56, 0xc1, 0x87, 0x9b, 0x43, 0xd8, 0xa4, 0x9f, 0x6e, 0x5f, 0x6f, 0x1d,
	0x5d, 0x99, 0x13, 0xf1, 0x32, 0xff, 0x89, 0x81, 0x73, 0x94, 0xcc, 0xf6, 0x31, 0xe5, 0xf0, 0x22,
	0xa7, 0x8e, 0x26, 0xf2, 0x55, 0x80, 0x3d, 0xb5, 0xbe, 0xd7, 0xcd, 0x2b, 0x69, 0xc2, 0xd0, 0xa7,
	0x53, 0x5e, 0x65, 0x60, 0x3e, 0xee, 0xf6, 0xf4, 0x10, 0x5a, 0x1e, 0xfa, 0x12, 0xf5, 0x7d, 0x06,
	0xe6, 0x62, 0x1e, 0x12, 0x7c, 0x6a, 0xc6, 0xee, 0xe7, 0x02, 0xa5, 0x0f, 0x13, 0xbf, 0x1e, 0x54,
	0xcd, 0xff, 0x78, 0xe0, 0x10, 0xaa, 0x1d, 0xfd, 0x11, 0xc1, 0x3f, 0x82, 0x2e, 0x0f, 0x3c, 0xa5,
	0xf8, 0xd4, 0x6c, 0x7d, 0xc8, 0x57, 0x85, 0x7d, 0x98, 0xff, 0xfb, 0xc1, 0x25, 0xec, 0xdd, 0x37,
	0x0d, 0x7e, 0x02, 0x19, 0xe4, 0x9e, 0xc9, 0xd5, 0x38, 0x11, 0xa7, 0xf1, 0x15, 0xc5, 0x79, 0xa6,
	0x89, 0x2f, 0x7e, 0xa7, 0x60, 0x7c, 0xb5, 0xb2, 0xbe, 0xb5, 0x51, 0xfd, 0xd2, 0x46, 0xa1, 0xb6,
	0x55, 0xbe, 0x53, 0x5e, 0x7f, 0xae, 0x2c, 0x9c, 0x12, 0x27, 0xe0, 0x74, 0xe7, 0x33, 0xfe, 0x25,
	0x30, 0x41, 0xde, 0x5b, 0xb7, 0xf3, 0xe5, 0x72, 0xe1, 0xae, 0xc0, 0x8a, 0x93, 0x20, 0x74, 0x3e,
	0x57, 0x6f, 0x57, 0x0a, 0xf9, 0x15, 0x81, 0xbb, 0xf2, 0x0b, 0x0e, 0x26, 0xa3, 0xce, 0x3c, 0xe2,
	0x3c, 0xcc, 0x60, 0xf6, 0xfc, 0xca, 0x5a, 0xb1, 0xbc, 0x51, 0xa8, 0xac, 0x15, 0x37, 0x37, 0x8b,
	0xeb, 0x65, 0x1f, 0xf8, 0x65, 0x90, 0x22, 0x39, 0x0a, 0x2b, 0xc5, 0xea, 0xe6, 0xed, 0xf5, 0x4a,
	0xb5, 0x9c, 0x5f, 0x2b, 0x08, 0x8c, 0x38, 0x07, 0xe7, 0x22, 0xf9, 0x8a, 0xe5, 0x7b, 0xc5, 0x6a,
	0x41, 0x60, 0xc5, 0x59, 0x98, 0x8e, 0x64, 0xb8, 0x53, 0xbc, 0x75, 0x47, 0x48, 0x88, 0x17, 0x60,
	0x2e, 0x5a, 0x92, 0x8d, 0x95, 0x7c, 0xb5, 0x50, 0x2c, 0x3f, 0xbb, 0x2e, 0x70, 0xe2, 0x23, 0x70,
	0x21, 0x92, 0x69, 0xb3, 0x50, 0xed, 0xfc, 0xb5, 0x29, 0x24, 0xc5, 0x8b, 0x30, 0x1f, 0x2b, 0xf5,
	0x5a, 0x61, 0x73, 0x33, 0xbf, 0x5a, 0x10, 0x52, 0xb1, 0xba, 0xad, 0x14, 0xee, 0x16, 0xaa, 0x05,
	0x97, 0x6f, 0x48, 0xbc, 0x0a, 0x0b, 0x91, 0x7c, 0xab, 0x85, 0x6a, 0xb1, 0x5c, 0x2d, 0xac, 0x56,
	0xf2, 0xd5, 0xe2, 0x7a, 0xb9, 0xba, 0x7e, 0xa7, 0x50, 0x16, 0xf8, 0x58, 0xec, 0xcd, 0x42, 0x79,
	0xc5, 0x9d, 0x33, 0x1d, 0xab, 0xef, 0x46, 0xb1, 0xec, 0x32, 0x41, 0xec, 0x54, 0xf7, 0x8a, 0x85,
	0xe7, 0xd6, 0x0a, 0x6b, 0xcb, 0x85, 0xca, 0xa6, 0x30, 0x2c, 0xe6, 0x20, 0x1b, 0xc9, 0x75, 0xb7,
	0x90, 0xbf, 0x57, 0x10, 0x46, 0x44, 0x09, 0x72, 0x91, 0xf4, 0x6a, 0xbe, 0x82, 0x35, 0x58, 0x15,
	0x46, 0x63, 0xdd, 0x47, 0x4c, 0x21, 0x8c, 0x5d, 0x7b, 0x6b, 0x12, 0x52, 0x38, 0x84, 0x4c, 0x51,
	0x83, 0x61, 0xff, 0xc3, 0x34, 0xef, 0x3c, 0x11, 0x7e, 0x8a, 0x97, 0x3d, 0xd7, 0xa1, 0x85, 0x5e,
	0xb4, 0x49, 0x97, 0xbf, 0xf1, 0x87, 0xbf, 0xbc, 0xc9, 0xce, 0x4b, 0xe7, 0x96, 0xf6, 0x9f, 0x58,
	0xb2, 0x6b, 0xd1, 0x25, 0x02, 0xb0, 0xe4, 0x63, 0xba, 0xc1, 0x5c, 0xb1, 0xf1, 0xfc, 0xd7, 0xfe,
	0x34, 0x9e, 0x8f, 0x16, 0xc6, 0xf3, 0x11, 0xe3, 0xf1, 0x7c, 0x4c, 0x36, 0xde, 0x3e, 0x8c, 0x51,
	0x37, 0xf5, 0xb3, 0x14, 0x64, 0x90, 0x9c, 0xcd, 0xd2, 0xa8, 0x9b, 0xe8, 0x85, 0x15, 0xd9, 0x42,
	0x6b, 0xaa, 0x22, 0x3d, 0x8a, 0x41, 0x2f, 0x48, 0x39, 0x1a, 0x34, 0x38, 0x87, 0x8d, 0xfb, 0x22,
	0x8c, 0x87, 0xef, 0xc3, 0xe7, 0x29, 0xe8, 0x10, 0x47, 0x76, 0x22, 0x02, 0x5d, 0xba, 0x8a, 0x61,
	0x2f, 0x4b, 0xe7, 0x69, 0xd8, 0xd0, 0x78, 0x1b, 0xf9, 0x15, 0x38, 0x4d, 0x5f, 0xd7, 0xe6, 0xe2,
	0x54, 0x26, 0xf4, 0xec, 0x1c, 0x8d, 0x4a, 0x31, 0x48, 0x57, 0xb0, 0x04, 0x17, 0xa5, 0xb9, 0x58,
	0xc5, 0x09, 0xa3, 0x8d, 0xff, 0x35, 0xfb, 0xe8, 0x48, 0xdf, 0xb5, 0xd2, 0x9a, 0x87, 0x38, 0xba,
	0xda, 0x3d, 0xd6, 0x00, 0xa1, 0x69, 0x6c, 0x01, 0x4c, 0x9f, 0xcb, 0xc9, 0xdd, 0x67, 0xac, 0xcb,
	0x31, 0x39, 0x7b, 0x36, 0x06, 0xba, 0x0f, 0x7f, 0xe3, 0x09, 0x6c, 0xd0, 0x37, 0x18, 0xc8, 0xc4,
	0xde, 0x20, 0x3e, 0x12, 0x87, 0x4f, 0x31, 0x66, 0xcf, 0x84, 0x72, 0x7f, 0xa1, 0xd9, 0xb2, 0x1e,
	0x4a, 0x4f, 0x62, 0x41, 0x1e, 0x93, 0x16, 0x62, 0x05, 0xa1, 0x66, 0xb2, 0x45, 0xfa, 0x0a, 0x80,
	0xef, 0x32, 0x66, 0x9a, 0x92, 0xa1, 0x43, 0xea, 0x6a, 0xfa, 0x4b, 0x18, 0x79, 0x4e, 0xca, 0xd2,
	0xc8, 0x9d, 0xf1, 0x0e, 0x96, 0xef, 0x5a, 0x83, 0xc6, 0xea, 0x90, 0x0e, 0x87, 0xd5, 0x19, 0x6f,
	0x63, 0x29, 0xc0, 0x7b, 0x17, 0x0b, 0x67, 0x29, 0x24, 0x97, 0xd0, 0x15, 0xe7, 0x02, 0xc6, 0x99,
	0x95, 0x32, 0x34, 0x8e, 0x3b, 0xda, 0x46, 0x69, 0xc1, 0x68, 0xb0, 0x3d, 0x3f, 0x43, 0x41, 0x05,
	0xa8, 0xf1, 0x31, 0xb4, 0x80, 0xc1, 0x24, 0x69, 0x96, 0x06, 0x0b, 0x8c, 0xb7, 0x11, 0x7f, 0xc2,
	0xc0, 0x74, 0x97, 0xb6, 0x33, 0x05, 0x1f, 0xcb, 0x99, 0x7d, 0x94, 0x16, 0x25, 0x96, 0x55, 0xba,
	0x8e, 0x85, 0x5b, 0x94, 0x1e, 0xa5, 0x85, 0x8b, 0x1d, 0x62, 0x0b, 0xfa, 0x2d, 0x06, 0xa6, 0xa2,
	0xef, 0x6f, 0x2f, 0x46, 0x04, 0x7a, 0x58, 0xc0, 0x33, 0xb4, 0x80, 0x84, 0x45, 0x7a, 0x1c, 0x4b,
	0x73, 0x45, 0xba, 0x14, 0x15, 0xe5, 0x91, 0x92, 0xbc, 0x0c, 0xe3, 0xe1, 0x16, 0x2e, 0xbd, 0xd7,
	0x84, 0x38, 0xe2, 0x9d, 0x15, 0xbb, 0xd1, 0x84, 0xe6, 0x20, 0x3b, 0xed, 0x78, 0xb8, 0xa1, 0x3a,
	0x1f, 0xe3, 0x27, 0x8f, 0x23, 0x3b, 0x4d, 0xa3, 0x7b, 0xa4, 0x78, 0xfc, 0xd0, 0x2c, 0x36, 0xfe,
	0x0f, 0x18, 0x98, 0x8a, 0x6e, 0x8a, 0x5e, 0xec, 0x25, 0x84, 0xcd, 0x95, 0xbd, 0x14, 0x17, 0x28,
	0x01, 0xb6, 0x78, 0xb7, 0x44, 0xf7, 0x73, 0x71, 0xf2, 0x3b, 0x4d, 0xf7, 0x56, 0x73, 0xa1, 0x04,
	0x10, 0xa0, 0x77, 0x33, 0x4a, 0x6c, 0xf2, 0xa1, 0xe6, 0xb0, 0x91, 0x77, 0x20, 0xdd, 0xe9, 0x57,
	0x66, 0x28, 0x4c, 0x8f, 0x12, 0x46, 0xf3, 0x48, 0xd2, 0x45, 0x8c, 0x96, 0x93, 0xa6, 0x69, 0x34,
	0x8f, 0x85, 0xe4, 0x98, 0xd3, 0x74, 0x93, 0x30, 0x17, 0x87, 0x46, 0xe8, 0xd9, 0x49, 0x1a, 0xf3,
	0x9e, 0xae, 0x2a, 0xf1, 0xca, 0x51, 0xc3, 0x6d, 0x50, 0x15, 0x86, 0xfd, 0x8d, 0x42, 0xba, 0x76,
	0xf2, 0xd1, 0x62, 0x13, 0x49, 0x6c, 0xd9, 0xe4, 0x1b, 0x7c, 0x83, 0xb9, 0xb2, 0xbc, 0x75, 0x70,
	0xf3, 0x0c, 0x4c, 0xfa, 0x5b, 0x8b, 0x26, 0x32, 0xf6, 0xd5, 0x3a, 0x32, 0xdf, 0xfb, 0x20, 0x77,
	0xea, 0xfd, 0x0f, 0x72, 0xa7, 0x3e, 0xfe, 0x20, 0xc7, 0x7c, 0xfd, 0x20, 0xc7, 0xbc, 0x73, 0x90,
	0x63, 0x7e, 0x73, 0x90, 0x63, 0xde, 0x3b, 0xc8, 0x31, 0x7f, 0x3e, 0xc8, 0x31, 0x7f, 0x3b, 0xc8,
	0x9d, 0xfa, 0xf8, 0x20, 0xc7, 0xbc, 0xf1, 0x61, 0xee, 0xd4, 0x7b, 0x1f, 0xe6, 0x4e, 0xbd, 0xff,
	0x61, 0xee, 0xd4, 0x97, 0x9d, 0xff, 0x74, 0xba, 0x9d, 0xc2, 0xe2, 0x3c, 0xf9, 0x9f, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x78, 0x14, 0xa0, 0xc2, 0x93, 0x3a, 0x00, 0x00,
}

func (x GroupType) String() string {
	s, ok := GroupType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x GroupAdminPermission) String() string {
	s, ok := GroupAdminPermission_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *Member) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Member)
	if !ok {
		that2, ok := that.(Member)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.InvitedAt != that1.InvitedAt {
		return false
	}
	if len(this.Permissions) != len(that1.Permissions) {
		return false
	}
	for i := range this.Permissions {
		if this.Permissions[i] != that1.Permissions[i] {
			return false
		}
	}
	if this.Clock != that1.Clock {
		return false
	}
	if !this.DeletedAt.Equal(that1.DeletedAt) {
		return false
	}
	return true
}
func (this *Group) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Group)
	if !ok {
		that2, ok := that.(Group)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AccessHash != that1.AccessHash {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	if !this.SelfMember.Equal(that1.SelfMember) {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.GroupType != that1.GroupType {
		return false
	}
	if !this.Shortname.Equal(that1.Shortname) {
		return false
	}
	return true
}
func (this *GroupData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupData)
	if !ok {
		that2, ok := that.(GroupData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.SpaceId.Equal(that1.SpaceId) {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if !this.Avatar.Equal(that1.Avatar) {
		return false
	}
	if this.MembersAmount != that1.MembersAmount {
		return false
	}
	if this.GroupType != that1.GroupType {
		return false
	}
	if this.OwnerUserId != that1.OwnerUserId {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if !this.About.Equal(that1.About) {
		return false
	}
	if !this.Shortname.Equal(that1.Shortname) {
		return false
	}
	if len(this.BasePermissions) != len(that1.BasePermissions) {
		return false
	}
	for i := range this.BasePermissions {
		if this.BasePermissions[i] != that1.BasePermissions[i] {
			return false
		}
	}
	if this.Clock != that1.Clock {
		return false
	}
	if !this.PinnedAt.Equal(that1.PinnedAt) {
		return false
	}
	return true
}
func (this *GroupPartialInfo) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupPartialInfo)
	if !ok {
		that2, ok := that.(GroupPartialInfo)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.AccessHash != that1.AccessHash {
		return false
	}
	if this.Clock != that1.Clock {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if !this.Shortname.Equal(that1.Shortname) {
		return false
	}
	if !this.Avatar.Equal(that1.Avatar) {
		return false
	}
	if !this.SelfMember.Equal(that1.SelfMember) {
		return false
	}
	if !this.PinnedAt.Equal(that1.PinnedAt) {
		return false
	}
	return true
}
func (this *UpdateGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroup)
	if !ok {
		that2, ok := that.(UpdateGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if !this.Data.Equal(that1.Data) {
		return false
	}
	return true
}
func (this *RequestLoadMembers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestLoadMembers)
	if !ok {
		that2, ok := that.(RequestLoadMembers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Group.Equal(that1.Group) {
		return false
	}
	if this.Limit != that1.Limit {
		return false
	}
	if !this.Next.Equal(that1.Next) {
		return false
	}
	return true
}
func (this *ResponseLoadMembers) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseLoadMembers)
	if !ok {
		that2, ok := that.(ResponseLoadMembers)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Cursor.Equal(that1.Cursor) {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateGroupTitleChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupTitleChanged)
	if !ok {
		that2, ok := that.(UpdateGroupTitleChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	return true
}
func (this *UpdateGroupAvatarChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupAvatarChanged)
	if !ok {
		that2, ok := that.(UpdateGroupAvatarChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.Avatar.Equal(that1.Avatar) {
		return false
	}
	return true
}
func (this *UpdateGroupAboutChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupAboutChanged)
	if !ok {
		that2, ok := that.(UpdateGroupAboutChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.About.Equal(that1.About) {
		return false
	}
	return true
}
func (this *UpdateGroupOwnerChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupOwnerChanged)
	if !ok {
		that2, ok := that.(UpdateGroupOwnerChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	return true
}
func (this *UpdateGroupBasePermissionsChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupBasePermissionsChanged)
	if !ok {
		that2, ok := that.(UpdateGroupBasePermissionsChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if len(this.BasePermissions) != len(that1.BasePermissions) {
		return false
	}
	for i := range this.BasePermissions {
		if this.BasePermissions[i] != that1.BasePermissions[i] {
			return false
		}
	}
	return true
}
func (this *UpdateGroupMembersUpdated) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupMembersUpdated)
	if !ok {
		that2, ok := that.(UpdateGroupMembersUpdated)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateGroupMemberDiff) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupMemberDiff)
	if !ok {
		that2, ok := that.(UpdateGroupMemberDiff)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.RemovedUsers) != len(that1.RemovedUsers) {
		return false
	}
	for i := range this.RemovedUsers {
		if this.RemovedUsers[i] != that1.RemovedUsers[i] {
			return false
		}
	}
	if len(this.AddedMembers) != len(that1.AddedMembers) {
		return false
	}
	for i := range this.AddedMembers {
		if !this.AddedMembers[i].Equal(that1.AddedMembers[i]) {
			return false
		}
	}
	if this.MembersCount != that1.MembersCount {
		return false
	}
	return true
}
func (this *UpdateGroupMembersCountChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupMembersCountChanged)
	if !ok {
		that2, ok := that.(UpdateGroupMembersCountChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.MembersCount != that1.MembersCount {
		return false
	}
	return true
}
func (this *RequestCreateGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestCreateGroup)
	if !ok {
		that2, ok := that.(RequestCreateGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.SpaceId.Equal(that1.SpaceId) {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if len(this.Users) != len(that1.Users) {
		return false
	}
	for i := range this.Users {
		if !this.Users[i].Equal(that1.Users[i]) {
			return false
		}
	}
	if this.GroupType != that1.GroupType {
		return false
	}
	if !this.Username.Equal(that1.Username) {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	if len(this.BasePermissions) != len(that1.BasePermissions) {
		return false
	}
	for i := range this.BasePermissions {
		if this.BasePermissions[i] != that1.BasePermissions[i] {
			return false
		}
	}
	return true
}
func (this *ResponseCreateGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseCreateGroup)
	if !ok {
		that2, ok := that.(ResponseCreateGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if !bytes.Equal(this.State, that1.State) {
		return false
	}
	if !this.Group.Equal(that1.Group) {
		return false
	}
	if len(this.UserPeers) != len(that1.UserPeers) {
		return false
	}
	for i := range this.UserPeers {
		if !this.UserPeers[i].Equal(that1.UserPeers[i]) {
			return false
		}
	}
	return true
}
func (this *RequestEditGroupTitle) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestEditGroupTitle)
	if !ok {
		that2, ok := that.(RequestEditGroupTitle)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *RequestSetGroupShortname) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestSetGroupShortname)
	if !ok {
		that2, ok := that.(RequestSetGroupShortname)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Peer.Equal(that1.Peer) {
		return false
	}
	if this.Shortname != that1.Shortname {
		return false
	}
	return true
}
func (this *RequestEditGroupAvatar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestEditGroupAvatar)
	if !ok {
		that2, ok := that.(RequestEditGroupAvatar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.FileLocation.Equal(that1.FileLocation) {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *ResponseEditGroupAvatar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseEditGroupAvatar)
	if !ok {
		that2, ok := that.(ResponseEditGroupAvatar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Avatar.Equal(that1.Avatar) {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if !bytes.Equal(this.State, that1.State) {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	return true
}
func (this *RequestRemoveGroupAvatar) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestRemoveGroupAvatar)
	if !ok {
		that2, ok := that.(RequestRemoveGroupAvatar)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *RequestEditGroupAbout) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestEditGroupAbout)
	if !ok {
		that2, ok := that.(RequestEditGroupAbout)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.About.Equal(that1.About) {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *RequestEditGroupBasePermissions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestEditGroupBasePermissions)
	if !ok {
		that2, ok := that.(RequestEditGroupBasePermissions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.RandomId != that1.RandomId {
		return false
	}
	if len(this.GrantedPermissions) != len(that1.GrantedPermissions) {
		return false
	}
	for i := range this.GrantedPermissions {
		if this.GrantedPermissions[i] != that1.GrantedPermissions[i] {
			return false
		}
	}
	if len(this.RevokedPermissions) != len(that1.RevokedPermissions) {
		return false
	}
	for i := range this.RevokedPermissions {
		if this.RevokedPermissions[i] != that1.RevokedPermissions[i] {
			return false
		}
	}
	return true
}
func (this *RequestEditMemberPermissions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestEditMemberPermissions)
	if !ok {
		that2, ok := that.(RequestEditMemberPermissions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if !this.UserPeer.Equal(that1.UserPeer) {
		return false
	}
	if len(this.GrantedPermissions) != len(that1.GrantedPermissions) {
		return false
	}
	for i := range this.GrantedPermissions {
		if this.GrantedPermissions[i] != that1.GrantedPermissions[i] {
			return false
		}
	}
	if len(this.RevokedPermissions) != len(that1.RevokedPermissions) {
		return false
	}
	for i := range this.RevokedPermissions {
		if this.RevokedPermissions[i] != that1.RevokedPermissions[i] {
			return false
		}
	}
	return true
}
func (this *ResponseMember) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseMember)
	if !ok {
		that2, ok := that.(ResponseMember)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Member.Equal(that1.Member) {
		return false
	}
	return true
}
func (this *RequestInviteUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestInviteUser)
	if !ok {
		that2, ok := that.(RequestInviteUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *RequestLeaveGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestLeaveGroup)
	if !ok {
		that2, ok := that.(RequestLeaveGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *RequestKickUser) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestKickUser)
	if !ok {
		that2, ok := that.(RequestKickUser)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.User.Equal(that1.User) {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *RequestMakeUserAdmin) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestMakeUserAdmin)
	if !ok {
		that2, ok := that.(RequestMakeUserAdmin)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if !this.UserPeer.Equal(that1.UserPeer) {
		return false
	}
	if len(this.Permissions) != len(that1.Permissions) {
		return false
	}
	for i := range this.Permissions {
		if this.Permissions[i] != that1.Permissions[i] {
			return false
		}
	}
	return true
}
func (this *GroupMemberPermission) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*GroupMemberPermission)
	if !ok {
		that2, ok := that.(GroupMemberPermission)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if len(this.Permissions) != len(that1.Permissions) {
		return false
	}
	for i := range this.Permissions {
		if this.Permissions[i] != that1.Permissions[i] {
			return false
		}
	}
	return true
}
func (this *RequestGetGroupMemberPermissions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetGroupMemberPermissions)
	if !ok {
		that2, ok := that.(RequestGetGroupMemberPermissions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if len(this.UserIds) != len(that1.UserIds) {
		return false
	}
	for i := range this.UserIds {
		if this.UserIds[i] != that1.UserIds[i] {
			return false
		}
	}
	return true
}
func (this *ResponseGetGroupMemberPermissions) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetGroupMemberPermissions)
	if !ok {
		that2, ok := that.(ResponseGetGroupMemberPermissions)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Permissions) != len(that1.Permissions) {
		return false
	}
	for i := range this.Permissions {
		if !this.Permissions[i].Equal(that1.Permissions[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateGroupMemberPermissionsChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupMemberPermissionsChanged)
	if !ok {
		that2, ok := that.(UpdateGroupMemberPermissionsChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.UserId != that1.UserId {
		return false
	}
	if len(this.Permissions) != len(that1.Permissions) {
		return false
	}
	for i := range this.Permissions {
		if this.Permissions[i] != that1.Permissions[i] {
			return false
		}
	}
	return true
}
func (this *RequestTransferOwnership) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestTransferOwnership)
	if !ok {
		that2, ok := that.(RequestTransferOwnership)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	if this.NewOwner != that1.NewOwner {
		return false
	}
	return true
}
func (this *ResponseInviteUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseInviteUrl)
	if !ok {
		that2, ok := that.(ResponseInviteUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *RequestGetGroupInviteUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetGroupInviteUrl)
	if !ok {
		that2, ok := that.(RequestGetGroupInviteUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	return true
}
func (this *RequestGetGroupInviteUrlBase) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestGetGroupInviteUrlBase)
	if !ok {
		that2, ok := that.(RequestGetGroupInviteUrlBase)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *ResponseGetGroupInviteUrlBase) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseGetGroupInviteUrlBase)
	if !ok {
		that2, ok := that.(ResponseGetGroupInviteUrlBase)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Url != that1.Url {
		return false
	}
	return true
}
func (this *RequestRevokeInviteUrl) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestRevokeInviteUrl)
	if !ok {
		that2, ok := that.(RequestRevokeInviteUrl)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.GroupPeer.Equal(that1.GroupPeer) {
		return false
	}
	return true
}
func (this *RequestJoinGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestJoinGroup)
	if !ok {
		that2, ok := that.(RequestJoinGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Token != that1.Token {
		return false
	}
	if len(this.Optimizations) != len(that1.Optimizations) {
		return false
	}
	for i := range this.Optimizations {
		if this.Optimizations[i] != that1.Optimizations[i] {
			return false
		}
	}
	return true
}
func (this *ResponseJoinGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ResponseJoinGroup)
	if !ok {
		that2, ok := that.(ResponseJoinGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Group.Equal(that1.Group) {
		return false
	}
	if len(this.UserPeers) != len(that1.UserPeers) {
		return false
	}
	for i := range this.UserPeers {
		if !this.UserPeers[i].Equal(that1.UserPeers[i]) {
			return false
		}
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.Seq != that1.Seq {
		return false
	}
	if !bytes.Equal(this.State, that1.State) {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *RequestJoinGroupByPeer) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestJoinGroupByPeer)
	if !ok {
		that2, ok := that.(RequestJoinGroupByPeer)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if !this.Peer.Equal(that1.Peer) {
		return false
	}
	return true
}
func (this *RequestDeleteGroup) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*RequestDeleteGroup)
	if !ok {
		that2, ok := that.(RequestDeleteGroup)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	return true
}
func (this *UpdateGroupMemberInvited) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupMemberInvited)
	if !ok {
		that2, ok := that.(UpdateGroupMemberInvited)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.Member.Equal(that1.Member) {
		return false
	}
	return true
}
func (this *UpdateGroupInviteObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupInviteObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupInviteObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.InviteUid != that1.InviteUid {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *UpdateGroupUserInvitedObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupUserInvitedObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupUserInvitedObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.Rid != that1.Rid {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.InviterUid != that1.InviterUid {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *UpdateGroupUserLeaveObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupUserLeaveObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupUserLeaveObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *UpdateGroupUserKickObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupUserKickObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupUserKickObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.KickerUid != that1.KickerUid {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *UpdateGroupMembersUpdateObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupMembersUpdateObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupMembersUpdateObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if len(this.Members) != len(that1.Members) {
		return false
	}
	for i := range this.Members {
		if !this.Members[i].Equal(that1.Members[i]) {
			return false
		}
	}
	return true
}
func (this *UpdateGroupTitleChangedObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupTitleChangedObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupTitleChangedObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if this.Title != that1.Title {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *UpdateGroupAboutChangedObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupAboutChangedObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupAboutChangedObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.About.Equal(that1.About) {
		return false
	}
	return true
}
func (this *UpdateGroupAvatarChangedObsolete) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupAvatarChangedObsolete)
	if !ok {
		that2, ok := that.(UpdateGroupAvatarChangedObsolete)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if !this.Mid.Equal(that1.Mid) {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	if !this.Avatar.Equal(that1.Avatar) {
		return false
	}
	if this.Date != that1.Date {
		return false
	}
	return true
}
func (this *UpdateGroupShortnameChanged) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*UpdateGroupShortnameChanged)
	if !ok {
		that2, ok := that.(UpdateGroupShortnameChanged)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.GroupId != that1.GroupId {
		return false
	}
	if this.Shortname != that1.Shortname {
		return false
	}
	if this.Uid != that1.Uid {
		return false
	}
	return true
}
func (this *Member) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.Member{")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "InvitedAt: "+fmt.Sprintf("%#v", this.InvitedAt)+",\n")
	s = append(s, "Permissions: "+fmt.Sprintf("%#v", this.Permissions)+",\n")
	s = append(s, "Clock: "+fmt.Sprintf("%#v", this.Clock)+",\n")
	if this.DeletedAt != nil {
		s = append(s, "DeletedAt: "+fmt.Sprintf("%#v", this.DeletedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Group) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&dialog.Group{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AccessHash: "+fmt.Sprintf("%#v", this.AccessHash)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	if this.SelfMember != nil {
		s = append(s, "SelfMember: "+fmt.Sprintf("%#v", this.SelfMember)+",\n")
	}
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "GroupType: "+fmt.Sprintf("%#v", this.GroupType)+",\n")
	if this.Shortname != nil {
		s = append(s, "Shortname: "+fmt.Sprintf("%#v", this.Shortname)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 16)
	s = append(s, "&dialog.GroupData{")
	if this.SpaceId != nil {
		s = append(s, "SpaceId: "+fmt.Sprintf("%#v", this.SpaceId)+",\n")
	}
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	if this.Avatar != nil {
		s = append(s, "Avatar: "+fmt.Sprintf("%#v", this.Avatar)+",\n")
	}
	s = append(s, "MembersAmount: "+fmt.Sprintf("%#v", this.MembersAmount)+",\n")
	s = append(s, "GroupType: "+fmt.Sprintf("%#v", this.GroupType)+",\n")
	s = append(s, "OwnerUserId: "+fmt.Sprintf("%#v", this.OwnerUserId)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	if this.About != nil {
		s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	}
	if this.Shortname != nil {
		s = append(s, "Shortname: "+fmt.Sprintf("%#v", this.Shortname)+",\n")
	}
	s = append(s, "BasePermissions: "+fmt.Sprintf("%#v", this.BasePermissions)+",\n")
	s = append(s, "Clock: "+fmt.Sprintf("%#v", this.Clock)+",\n")
	if this.PinnedAt != nil {
		s = append(s, "PinnedAt: "+fmt.Sprintf("%#v", this.PinnedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupPartialInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 13)
	s = append(s, "&dialog.GroupPartialInfo{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "AccessHash: "+fmt.Sprintf("%#v", this.AccessHash)+",\n")
	s = append(s, "Clock: "+fmt.Sprintf("%#v", this.Clock)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	if this.Shortname != nil {
		s = append(s, "Shortname: "+fmt.Sprintf("%#v", this.Shortname)+",\n")
	}
	if this.Avatar != nil {
		s = append(s, "Avatar: "+fmt.Sprintf("%#v", this.Avatar)+",\n")
	}
	if this.SelfMember != nil {
		s = append(s, "SelfMember: "+fmt.Sprintf("%#v", this.SelfMember)+",\n")
	}
	if this.PinnedAt != nil {
		s = append(s, "PinnedAt: "+fmt.Sprintf("%#v", this.PinnedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroup{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestLoadMembers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.RequestLoadMembers{")
	if this.Group != nil {
		s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	}
	s = append(s, "Limit: "+fmt.Sprintf("%#v", this.Limit)+",\n")
	if this.Next != nil {
		s = append(s, "Next: "+fmt.Sprintf("%#v", this.Next)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseLoadMembers) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.ResponseLoadMembers{")
	if this.Cursor != nil {
		s = append(s, "Cursor: "+fmt.Sprintf("%#v", this.Cursor)+",\n")
	}
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupTitleChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupTitleChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupAvatarChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupAvatarChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Avatar != nil {
		s = append(s, "Avatar: "+fmt.Sprintf("%#v", this.Avatar)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupAboutChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupAboutChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.About != nil {
		s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupOwnerChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupOwnerChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupBasePermissionsChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupBasePermissionsChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "BasePermissions: "+fmt.Sprintf("%#v", this.BasePermissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupMembersUpdated) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupMembersUpdated{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupMemberDiff) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateGroupMemberDiff{")
	s = append(s, "RemovedUsers: "+fmt.Sprintf("%#v", this.RemovedUsers)+",\n")
	if this.AddedMembers != nil {
		s = append(s, "AddedMembers: "+fmt.Sprintf("%#v", this.AddedMembers)+",\n")
	}
	s = append(s, "MembersCount: "+fmt.Sprintf("%#v", this.MembersCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupMembersCountChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupMembersCountChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "MembersCount: "+fmt.Sprintf("%#v", this.MembersCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestCreateGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&dialog.RequestCreateGroup{")
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.SpaceId != nil {
		s = append(s, "SpaceId: "+fmt.Sprintf("%#v", this.SpaceId)+",\n")
	}
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	if this.Users != nil {
		s = append(s, "Users: "+fmt.Sprintf("%#v", this.Users)+",\n")
	}
	s = append(s, "GroupType: "+fmt.Sprintf("%#v", this.GroupType)+",\n")
	if this.Username != nil {
		s = append(s, "Username: "+fmt.Sprintf("%#v", this.Username)+",\n")
	}
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "BasePermissions: "+fmt.Sprintf("%#v", this.BasePermissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseCreateGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.ResponseCreateGroup{")
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	if this.Group != nil {
		s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	}
	if this.UserPeers != nil {
		s = append(s, "UserPeers: "+fmt.Sprintf("%#v", this.UserPeers)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestEditGroupTitle) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestEditGroupTitle{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestSetGroupShortname) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestSetGroupShortname{")
	if this.Peer != nil {
		s = append(s, "Peer: "+fmt.Sprintf("%#v", this.Peer)+",\n")
	}
	s = append(s, "Shortname: "+fmt.Sprintf("%#v", this.Shortname)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestEditGroupAvatar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestEditGroupAvatar{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.FileLocation != nil {
		s = append(s, "FileLocation: "+fmt.Sprintf("%#v", this.FileLocation)+",\n")
	}
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseEditGroupAvatar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.ResponseEditGroupAvatar{")
	if this.Avatar != nil {
		s = append(s, "Avatar: "+fmt.Sprintf("%#v", this.Avatar)+",\n")
	}
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestRemoveGroupAvatar) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.RequestRemoveGroupAvatar{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestEditGroupAbout) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestEditGroupAbout{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.About != nil {
		s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	}
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestEditGroupBasePermissions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestEditGroupBasePermissions{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "RandomId: "+fmt.Sprintf("%#v", this.RandomId)+",\n")
	s = append(s, "GrantedPermissions: "+fmt.Sprintf("%#v", this.GrantedPermissions)+",\n")
	s = append(s, "RevokedPermissions: "+fmt.Sprintf("%#v", this.RevokedPermissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestEditMemberPermissions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestEditMemberPermissions{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	if this.UserPeer != nil {
		s = append(s, "UserPeer: "+fmt.Sprintf("%#v", this.UserPeer)+",\n")
	}
	s = append(s, "GrantedPermissions: "+fmt.Sprintf("%#v", this.GrantedPermissions)+",\n")
	s = append(s, "RevokedPermissions: "+fmt.Sprintf("%#v", this.RevokedPermissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseMember) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseMember{")
	if this.Member != nil {
		s = append(s, "Member: "+fmt.Sprintf("%#v", this.Member)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestInviteUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestInviteUser{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestLeaveGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.RequestLeaveGroup{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestKickUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.RequestKickUser{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.User != nil {
		s = append(s, "User: "+fmt.Sprintf("%#v", this.User)+",\n")
	}
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestMakeUserAdmin) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.RequestMakeUserAdmin{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	if this.UserPeer != nil {
		s = append(s, "UserPeer: "+fmt.Sprintf("%#v", this.UserPeer)+",\n")
	}
	s = append(s, "Permissions: "+fmt.Sprintf("%#v", this.Permissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *GroupMemberPermission) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.GroupMemberPermission{")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Permissions: "+fmt.Sprintf("%#v", this.Permissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetGroupMemberPermissions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestGetGroupMemberPermissions{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "UserIds: "+fmt.Sprintf("%#v", this.UserIds)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetGroupMemberPermissions) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseGetGroupMemberPermissions{")
	if this.Permissions != nil {
		s = append(s, "Permissions: "+fmt.Sprintf("%#v", this.Permissions)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupMemberPermissionsChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateGroupMemberPermissionsChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "Permissions: "+fmt.Sprintf("%#v", this.Permissions)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestTransferOwnership) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestTransferOwnership{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "NewOwner: "+fmt.Sprintf("%#v", this.NewOwner)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseInviteUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseInviteUrl{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetGroupInviteUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestGetGroupInviteUrl{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestGetGroupInviteUrlBase) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&dialog.RequestGetGroupInviteUrlBase{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseGetGroupInviteUrlBase) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.ResponseGetGroupInviteUrlBase{")
	s = append(s, "Url: "+fmt.Sprintf("%#v", this.Url)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestRevokeInviteUrl) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestRevokeInviteUrl{")
	if this.GroupPeer != nil {
		s = append(s, "GroupPeer: "+fmt.Sprintf("%#v", this.GroupPeer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestJoinGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.RequestJoinGroup{")
	s = append(s, "Token: "+fmt.Sprintf("%#v", this.Token)+",\n")
	s = append(s, "Optimizations: "+fmt.Sprintf("%#v", this.Optimizations)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ResponseJoinGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&dialog.ResponseJoinGroup{")
	if this.Group != nil {
		s = append(s, "Group: "+fmt.Sprintf("%#v", this.Group)+",\n")
	}
	if this.UserPeers != nil {
		s = append(s, "UserPeers: "+fmt.Sprintf("%#v", this.UserPeers)+",\n")
	}
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "Seq: "+fmt.Sprintf("%#v", this.Seq)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestJoinGroupByPeer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestJoinGroupByPeer{")
	if this.Peer != nil {
		s = append(s, "Peer: "+fmt.Sprintf("%#v", this.Peer)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *RequestDeleteGroup) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&dialog.RequestDeleteGroup{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupMemberInvited) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupMemberInvited{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Member != nil {
		s = append(s, "Member: "+fmt.Sprintf("%#v", this.Member)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupInviteObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.UpdateGroupInviteObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "InviteUid: "+fmt.Sprintf("%#v", this.InviteUid)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupUserInvitedObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&dialog.UpdateGroupUserInvitedObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "Rid: "+fmt.Sprintf("%#v", this.Rid)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "InviterUid: "+fmt.Sprintf("%#v", this.InviterUid)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupUserLeaveObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&dialog.UpdateGroupUserLeaveObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupUserKickObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.UpdateGroupUserKickObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "KickerUid: "+fmt.Sprintf("%#v", this.KickerUid)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupMembersUpdateObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupMembersUpdateObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Members != nil {
		s = append(s, "Members: "+fmt.Sprintf("%#v", this.Members)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupTitleChangedObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.UpdateGroupTitleChangedObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "Title: "+fmt.Sprintf("%#v", this.Title)+",\n")
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupAboutChangedObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&dialog.UpdateGroupAboutChangedObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.About != nil {
		s = append(s, "About: "+fmt.Sprintf("%#v", this.About)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupAvatarChangedObsolete) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&dialog.UpdateGroupAvatarChangedObsolete{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	if this.Mid != nil {
		s = append(s, "Mid: "+fmt.Sprintf("%#v", this.Mid)+",\n")
	}
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	if this.Avatar != nil {
		s = append(s, "Avatar: "+fmt.Sprintf("%#v", this.Avatar)+",\n")
	}
	s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *UpdateGroupShortnameChanged) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&dialog.UpdateGroupShortnameChanged{")
	s = append(s, "GroupId: "+fmt.Sprintf("%#v", this.GroupId)+",\n")
	s = append(s, "Shortname: "+fmt.Sprintf("%#v", this.Shortname)+",\n")
	s = append(s, "Uid: "+fmt.Sprintf("%#v", this.Uid)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringGroups(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// GroupsClient is the client API for Groups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type GroupsClient interface {
	LoadMembers(ctx context.Context, in *RequestLoadMembers, opts ...grpc.CallOption) (*ResponseLoadMembers, error)
	CreateGroup(ctx context.Context, in *RequestCreateGroup, opts ...grpc.CallOption) (*ResponseCreateGroup, error)
	EditGroupTitle(ctx context.Context, in *RequestEditGroupTitle, opts ...grpc.CallOption) (*ResponseSeqDateMid, error)
	SetGroupShortname(ctx context.Context, in *RequestSetGroupShortname, opts ...grpc.CallOption) (*ResponseSeq, error)
	EditGroupAvatar(ctx context.Context, in *RequestEditGroupAvatar, opts ...grpc.CallOption) (*ResponseEditGroupAvatar, error)
	RemoveGroupAvatar(ctx context.Context, in *RequestRemoveGroupAvatar, opts ...grpc.CallOption) (*ResponseSeqDateMid, error)
	EditGroupAbout(ctx context.Context, in *RequestEditGroupAbout, opts ...grpc.CallOption) (*ResponseSeqDate, error)
	EditGroupBasePermissions(ctx context.Context, in *RequestEditGroupBasePermissions, opts ...grpc.CallOption) (*types.Empty, error)
	InviteUser(ctx context.Context, in *RequestInviteUser, opts ...grpc.CallOption) (*ResponseSeqDateMid, error)
	LeaveGroup(ctx context.Context, in *RequestLeaveGroup, opts ...grpc.CallOption) (*ResponseSeqDateMid, error)
	KickUser(ctx context.Context, in *RequestKickUser, opts ...grpc.CallOption) (*ResponseSeqDateMid, error)
	MakeUserAdmin(ctx context.Context, in *RequestMakeUserAdmin, opts ...grpc.CallOption) (*ResponseSeqDate, error)
	GetGroupMemberPermissions(ctx context.Context, in *RequestGetGroupMemberPermissions, opts ...grpc.CallOption) (*ResponseGetGroupMemberPermissions, error)
	EditMemberPermissions(ctx context.Context, in *RequestEditMemberPermissions, opts ...grpc.CallOption) (*ResponseMember, error)
	TransferOwnership(ctx context.Context, in *RequestTransferOwnership, opts ...grpc.CallOption) (*ResponseSeqDate, error)
	GetGroupInviteUrl(ctx context.Context, in *RequestGetGroupInviteUrl, opts ...grpc.CallOption) (*ResponseInviteUrl, error)
	GetGroupInviteUrlBase(ctx context.Context, in *RequestGetGroupInviteUrlBase, opts ...grpc.CallOption) (*ResponseGetGroupInviteUrlBase, error)
	RevokeInviteUrl(ctx context.Context, in *RequestRevokeInviteUrl, opts ...grpc.CallOption) (*ResponseInviteUrl, error)
	JoinGroup(ctx context.Context, in *RequestJoinGroup, opts ...grpc.CallOption) (*ResponseJoinGroup, error)
	JoinGroupByPeer(ctx context.Context, in *RequestJoinGroupByPeer, opts ...grpc.CallOption) (*ResponseVoid, error)
	DeleteGroup(ctx context.Context, in *RequestDeleteGroup, opts ...grpc.CallOption) (*types.Empty, error)
}

type groupsClient struct {
	cc *grpc.ClientConn
}

func NewGroupsClient(cc *grpc.ClientConn) GroupsClient {
	return &groupsClient{cc}
}

func (c *groupsClient) LoadMembers(ctx context.Context, in *RequestLoadMembers, opts ...grpc.CallOption) (*ResponseLoadMembers, error) {
	out := new(ResponseLoadMembers)
	err := c.cc.Invoke(ctx, "/dialog.Groups/LoadMembers", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) CreateGroup(ctx context.Context, in *RequestCreateGroup, opts ...grpc.CallOption) (*ResponseCreateGroup, error) {
	out := new(ResponseCreateGroup)
	err := c.cc.Invoke(ctx, "/dialog.Groups/CreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) EditGroupTitle(ctx context.Context, in *RequestEditGroupTitle, opts ...grpc.CallOption) (*ResponseSeqDateMid, error) {
	out := new(ResponseSeqDateMid)
	err := c.cc.Invoke(ctx, "/dialog.Groups/EditGroupTitle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) SetGroupShortname(ctx context.Context, in *RequestSetGroupShortname, opts ...grpc.CallOption) (*ResponseSeq, error) {
	out := new(ResponseSeq)
	err := c.cc.Invoke(ctx, "/dialog.Groups/SetGroupShortname", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) EditGroupAvatar(ctx context.Context, in *RequestEditGroupAvatar, opts ...grpc.CallOption) (*ResponseEditGroupAvatar, error) {
	out := new(ResponseEditGroupAvatar)
	err := c.cc.Invoke(ctx, "/dialog.Groups/EditGroupAvatar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) RemoveGroupAvatar(ctx context.Context, in *RequestRemoveGroupAvatar, opts ...grpc.CallOption) (*ResponseSeqDateMid, error) {
	out := new(ResponseSeqDateMid)
	err := c.cc.Invoke(ctx, "/dialog.Groups/RemoveGroupAvatar", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) EditGroupAbout(ctx context.Context, in *RequestEditGroupAbout, opts ...grpc.CallOption) (*ResponseSeqDate, error) {
	out := new(ResponseSeqDate)
	err := c.cc.Invoke(ctx, "/dialog.Groups/EditGroupAbout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) EditGroupBasePermissions(ctx context.Context, in *RequestEditGroupBasePermissions, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/dialog.Groups/EditGroupBasePermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) InviteUser(ctx context.Context, in *RequestInviteUser, opts ...grpc.CallOption) (*ResponseSeqDateMid, error) {
	out := new(ResponseSeqDateMid)
	err := c.cc.Invoke(ctx, "/dialog.Groups/InviteUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) LeaveGroup(ctx context.Context, in *RequestLeaveGroup, opts ...grpc.CallOption) (*ResponseSeqDateMid, error) {
	out := new(ResponseSeqDateMid)
	err := c.cc.Invoke(ctx, "/dialog.Groups/LeaveGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) KickUser(ctx context.Context, in *RequestKickUser, opts ...grpc.CallOption) (*ResponseSeqDateMid, error) {
	out := new(ResponseSeqDateMid)
	err := c.cc.Invoke(ctx, "/dialog.Groups/KickUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) MakeUserAdmin(ctx context.Context, in *RequestMakeUserAdmin, opts ...grpc.CallOption) (*ResponseSeqDate, error) {
	out := new(ResponseSeqDate)
	err := c.cc.Invoke(ctx, "/dialog.Groups/MakeUserAdmin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) GetGroupMemberPermissions(ctx context.Context, in *RequestGetGroupMemberPermissions, opts ...grpc.CallOption) (*ResponseGetGroupMemberPermissions, error) {
	out := new(ResponseGetGroupMemberPermissions)
	err := c.cc.Invoke(ctx, "/dialog.Groups/GetGroupMemberPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) EditMemberPermissions(ctx context.Context, in *RequestEditMemberPermissions, opts ...grpc.CallOption) (*ResponseMember, error) {
	out := new(ResponseMember)
	err := c.cc.Invoke(ctx, "/dialog.Groups/EditMemberPermissions", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) TransferOwnership(ctx context.Context, in *RequestTransferOwnership, opts ...grpc.CallOption) (*ResponseSeqDate, error) {
	out := new(ResponseSeqDate)
	err := c.cc.Invoke(ctx, "/dialog.Groups/TransferOwnership", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) GetGroupInviteUrl(ctx context.Context, in *RequestGetGroupInviteUrl, opts ...grpc.CallOption) (*ResponseInviteUrl, error) {
	out := new(ResponseInviteUrl)
	err := c.cc.Invoke(ctx, "/dialog.Groups/GetGroupInviteUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) GetGroupInviteUrlBase(ctx context.Context, in *RequestGetGroupInviteUrlBase, opts ...grpc.CallOption) (*ResponseGetGroupInviteUrlBase, error) {
	out := new(ResponseGetGroupInviteUrlBase)
	err := c.cc.Invoke(ctx, "/dialog.Groups/GetGroupInviteUrlBase", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) RevokeInviteUrl(ctx context.Context, in *RequestRevokeInviteUrl, opts ...grpc.CallOption) (*ResponseInviteUrl, error) {
	out := new(ResponseInviteUrl)
	err := c.cc.Invoke(ctx, "/dialog.Groups/RevokeInviteUrl", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) JoinGroup(ctx context.Context, in *RequestJoinGroup, opts ...grpc.CallOption) (*ResponseJoinGroup, error) {
	out := new(ResponseJoinGroup)
	err := c.cc.Invoke(ctx, "/dialog.Groups/JoinGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) JoinGroupByPeer(ctx context.Context, in *RequestJoinGroupByPeer, opts ...grpc.CallOption) (*ResponseVoid, error) {
	out := new(ResponseVoid)
	err := c.cc.Invoke(ctx, "/dialog.Groups/JoinGroupByPeer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupsClient) DeleteGroup(ctx context.Context, in *RequestDeleteGroup, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/dialog.Groups/DeleteGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupsServer is the server API for Groups service.
type GroupsServer interface {
	LoadMembers(context.Context, *RequestLoadMembers) (*ResponseLoadMembers, error)
	CreateGroup(context.Context, *RequestCreateGroup) (*ResponseCreateGroup, error)
	EditGroupTitle(context.Context, *RequestEditGroupTitle) (*ResponseSeqDateMid, error)
	SetGroupShortname(context.Context, *RequestSetGroupShortname) (*ResponseSeq, error)
	EditGroupAvatar(context.Context, *RequestEditGroupAvatar) (*ResponseEditGroupAvatar, error)
	RemoveGroupAvatar(context.Context, *RequestRemoveGroupAvatar) (*ResponseSeqDateMid, error)
	EditGroupAbout(context.Context, *RequestEditGroupAbout) (*ResponseSeqDate, error)
	EditGroupBasePermissions(context.Context, *RequestEditGroupBasePermissions) (*types.Empty, error)
	InviteUser(context.Context, *RequestInviteUser) (*ResponseSeqDateMid, error)
	LeaveGroup(context.Context, *RequestLeaveGroup) (*ResponseSeqDateMid, error)
	KickUser(context.Context, *RequestKickUser) (*ResponseSeqDateMid, error)
	MakeUserAdmin(context.Context, *RequestMakeUserAdmin) (*ResponseSeqDate, error)
	GetGroupMemberPermissions(context.Context, *RequestGetGroupMemberPermissions) (*ResponseGetGroupMemberPermissions, error)
	EditMemberPermissions(context.Context, *RequestEditMemberPermissions) (*ResponseMember, error)
	TransferOwnership(context.Context, *RequestTransferOwnership) (*ResponseSeqDate, error)
	GetGroupInviteUrl(context.Context, *RequestGetGroupInviteUrl) (*ResponseInviteUrl, error)
	GetGroupInviteUrlBase(context.Context, *RequestGetGroupInviteUrlBase) (*ResponseGetGroupInviteUrlBase, error)
	RevokeInviteUrl(context.Context, *RequestRevokeInviteUrl) (*ResponseInviteUrl, error)
	JoinGroup(context.Context, *RequestJoinGroup) (*ResponseJoinGroup, error)
	JoinGroupByPeer(context.Context, *RequestJoinGroupByPeer) (*ResponseVoid, error)
	DeleteGroup(context.Context, *RequestDeleteGroup) (*types.Empty, error)
}

// UnimplementedGroupsServer can be embedded to have forward compatible implementations.
type UnimplementedGroupsServer struct {
}

func (*UnimplementedGroupsServer) LoadMembers(ctx context.Context, req *RequestLoadMembers) (*ResponseLoadMembers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LoadMembers not implemented")
}
func (*UnimplementedGroupsServer) CreateGroup(ctx context.Context, req *RequestCreateGroup) (*ResponseCreateGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (*UnimplementedGroupsServer) EditGroupTitle(ctx context.Context, req *RequestEditGroupTitle) (*ResponseSeqDateMid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditGroupTitle not implemented")
}
func (*UnimplementedGroupsServer) SetGroupShortname(ctx context.Context, req *RequestSetGroupShortname) (*ResponseSeq, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetGroupShortname not implemented")
}
func (*UnimplementedGroupsServer) EditGroupAvatar(ctx context.Context, req *RequestEditGroupAvatar) (*ResponseEditGroupAvatar, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditGroupAvatar not implemented")
}
func (*UnimplementedGroupsServer) RemoveGroupAvatar(ctx context.Context, req *RequestRemoveGroupAvatar) (*ResponseSeqDateMid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveGroupAvatar not implemented")
}
func (*UnimplementedGroupsServer) EditGroupAbout(ctx context.Context, req *RequestEditGroupAbout) (*ResponseSeqDate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditGroupAbout not implemented")
}
func (*UnimplementedGroupsServer) EditGroupBasePermissions(ctx context.Context, req *RequestEditGroupBasePermissions) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditGroupBasePermissions not implemented")
}
func (*UnimplementedGroupsServer) InviteUser(ctx context.Context, req *RequestInviteUser) (*ResponseSeqDateMid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InviteUser not implemented")
}
func (*UnimplementedGroupsServer) LeaveGroup(ctx context.Context, req *RequestLeaveGroup) (*ResponseSeqDateMid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LeaveGroup not implemented")
}
func (*UnimplementedGroupsServer) KickUser(ctx context.Context, req *RequestKickUser) (*ResponseSeqDateMid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method KickUser not implemented")
}
func (*UnimplementedGroupsServer) MakeUserAdmin(ctx context.Context, req *RequestMakeUserAdmin) (*ResponseSeqDate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MakeUserAdmin not implemented")
}
func (*UnimplementedGroupsServer) GetGroupMemberPermissions(ctx context.Context, req *RequestGetGroupMemberPermissions) (*ResponseGetGroupMemberPermissions, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroupMemberPermissions not implemented")
}
func (*UnimplementedGroupsServer) EditMemberPermissions(ctx context.Context, req *RequestEditMemberPermissions) (*ResponseMember, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EditMemberPermissions not implemented")
}
func (*UnimplementedGroupsServer) TransferOwnership(ctx context.Context, req *RequestTransferOwnership) (*ResponseSeqDate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferOwnership not implemented")
}
func (*UnimplementedGroupsServer) GetGroupInviteUrl(ctx context.Context, req *RequestGetGroupInviteUrl) (*ResponseInviteUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroupInviteUrl not implemented")
}
func (*UnimplementedGroupsServer) GetGroupInviteUrlBase(ctx context.Context, req *RequestGetGroupInviteUrlBase) (*ResponseGetGroupInviteUrlBase, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroupInviteUrlBase not implemented")
}
func (*UnimplementedGroupsServer) RevokeInviteUrl(ctx context.Context, req *RequestRevokeInviteUrl) (*ResponseInviteUrl, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RevokeInviteUrl not implemented")
}
func (*UnimplementedGroupsServer) JoinGroup(ctx context.Context, req *RequestJoinGroup) (*ResponseJoinGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinGroup not implemented")
}
func (*UnimplementedGroupsServer) JoinGroupByPeer(ctx context.Context, req *RequestJoinGroupByPeer) (*ResponseVoid, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JoinGroupByPeer not implemented")
}
func (*UnimplementedGroupsServer) DeleteGroup(ctx context.Context, req *RequestDeleteGroup) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteGroup not implemented")
}

func RegisterGroupsServer(s *grpc.Server, srv GroupsServer) {
	s.RegisterService(&_Groups_serviceDesc, srv)
}

func _Groups_LoadMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestLoadMembers)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).LoadMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/LoadMembers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).LoadMembers(ctx, req.(*RequestLoadMembers))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestCreateGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).CreateGroup(ctx, req.(*RequestCreateGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_EditGroupTitle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEditGroupTitle)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).EditGroupTitle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/EditGroupTitle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).EditGroupTitle(ctx, req.(*RequestEditGroupTitle))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_SetGroupShortname_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestSetGroupShortname)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).SetGroupShortname(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/SetGroupShortname",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).SetGroupShortname(ctx, req.(*RequestSetGroupShortname))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_EditGroupAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEditGroupAvatar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).EditGroupAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/EditGroupAvatar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).EditGroupAvatar(ctx, req.(*RequestEditGroupAvatar))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_RemoveGroupAvatar_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRemoveGroupAvatar)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).RemoveGroupAvatar(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/RemoveGroupAvatar",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).RemoveGroupAvatar(ctx, req.(*RequestRemoveGroupAvatar))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_EditGroupAbout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEditGroupAbout)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).EditGroupAbout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/EditGroupAbout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).EditGroupAbout(ctx, req.(*RequestEditGroupAbout))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_EditGroupBasePermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEditGroupBasePermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).EditGroupBasePermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/EditGroupBasePermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).EditGroupBasePermissions(ctx, req.(*RequestEditGroupBasePermissions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_InviteUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestInviteUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).InviteUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/InviteUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).InviteUser(ctx, req.(*RequestInviteUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_LeaveGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestLeaveGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).LeaveGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/LeaveGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).LeaveGroup(ctx, req.(*RequestLeaveGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_KickUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestKickUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).KickUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/KickUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).KickUser(ctx, req.(*RequestKickUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_MakeUserAdmin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestMakeUserAdmin)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).MakeUserAdmin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/MakeUserAdmin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).MakeUserAdmin(ctx, req.(*RequestMakeUserAdmin))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_GetGroupMemberPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetGroupMemberPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).GetGroupMemberPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/GetGroupMemberPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).GetGroupMemberPermissions(ctx, req.(*RequestGetGroupMemberPermissions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_EditMemberPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestEditMemberPermissions)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).EditMemberPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/EditMemberPermissions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).EditMemberPermissions(ctx, req.(*RequestEditMemberPermissions))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_TransferOwnership_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestTransferOwnership)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).TransferOwnership(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/TransferOwnership",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).TransferOwnership(ctx, req.(*RequestTransferOwnership))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_GetGroupInviteUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetGroupInviteUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).GetGroupInviteUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/GetGroupInviteUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).GetGroupInviteUrl(ctx, req.(*RequestGetGroupInviteUrl))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_GetGroupInviteUrlBase_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestGetGroupInviteUrlBase)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).GetGroupInviteUrlBase(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/GetGroupInviteUrlBase",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).GetGroupInviteUrlBase(ctx, req.(*RequestGetGroupInviteUrlBase))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_RevokeInviteUrl_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRevokeInviteUrl)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).RevokeInviteUrl(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/RevokeInviteUrl",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).RevokeInviteUrl(ctx, req.(*RequestRevokeInviteUrl))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_JoinGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestJoinGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).JoinGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/JoinGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).JoinGroup(ctx, req.(*RequestJoinGroup))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_JoinGroupByPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestJoinGroupByPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).JoinGroupByPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/JoinGroupByPeer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).JoinGroupByPeer(ctx, req.(*RequestJoinGroupByPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _Groups_DeleteGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestDeleteGroup)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupsServer).DeleteGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/dialog.Groups/DeleteGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupsServer).DeleteGroup(ctx, req.(*RequestDeleteGroup))
	}
	return interceptor(ctx, in, info, handler)
}

var _Groups_serviceDesc = grpc.ServiceDesc{
	ServiceName: "dialog.Groups",
	HandlerType: (*GroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "LoadMembers",
			Handler:    _Groups_LoadMembers_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _Groups_CreateGroup_Handler,
		},
		{
			MethodName: "EditGroupTitle",
			Handler:    _Groups_EditGroupTitle_Handler,
		},
		{
			MethodName: "SetGroupShortname",
			Handler:    _Groups_SetGroupShortname_Handler,
		},
		{
			MethodName: "EditGroupAvatar",
			Handler:    _Groups_EditGroupAvatar_Handler,
		},
		{
			MethodName: "RemoveGroupAvatar",
			Handler:    _Groups_RemoveGroupAvatar_Handler,
		},
		{
			MethodName: "EditGroupAbout",
			Handler:    _Groups_EditGroupAbout_Handler,
		},
		{
			MethodName: "EditGroupBasePermissions",
			Handler:    _Groups_EditGroupBasePermissions_Handler,
		},
		{
			MethodName: "InviteUser",
			Handler:    _Groups_InviteUser_Handler,
		},
		{
			MethodName: "LeaveGroup",
			Handler:    _Groups_LeaveGroup_Handler,
		},
		{
			MethodName: "KickUser",
			Handler:    _Groups_KickUser_Handler,
		},
		{
			MethodName: "MakeUserAdmin",
			Handler:    _Groups_MakeUserAdmin_Handler,
		},
		{
			MethodName: "GetGroupMemberPermissions",
			Handler:    _Groups_GetGroupMemberPermissions_Handler,
		},
		{
			MethodName: "EditMemberPermissions",
			Handler:    _Groups_EditMemberPermissions_Handler,
		},
		{
			MethodName: "TransferOwnership",
			Handler:    _Groups_TransferOwnership_Handler,
		},
		{
			MethodName: "GetGroupInviteUrl",
			Handler:    _Groups_GetGroupInviteUrl_Handler,
		},
		{
			MethodName: "GetGroupInviteUrlBase",
			Handler:    _Groups_GetGroupInviteUrlBase_Handler,
		},
		{
			MethodName: "RevokeInviteUrl",
			Handler:    _Groups_RevokeInviteUrl_Handler,
		},
		{
			MethodName: "JoinGroup",
			Handler:    _Groups_JoinGroup_Handler,
		},
		{
			MethodName: "JoinGroupByPeer",
			Handler:    _Groups_JoinGroupByPeer_Handler,
		},
		{
			MethodName: "DeleteGroup",
			Handler:    _Groups_DeleteGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "groups.proto",
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DeletedAt != nil {
		{
			size, err := m.DeletedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Clock != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Permissions) > 0 {
		dAtA3 := make([]byte, len(m.Permissions)*10)
		var j2 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA3[j2] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j2++
			}
			dAtA3[j2] = uint8(num)
			j2++
		}
		i -= j2
		copy(dAtA[i:], dAtA3[:j2])
		i = encodeVarintGroups(dAtA, i, uint64(j2))
		i--
		dAtA[i] = 0x2a
	}
	if m.InvitedAt != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.InvitedAt))
		i--
		dAtA[i] = 0x18
	}
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Group) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Group) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Group) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SelfMember != nil {
		{
			size, err := m.SelfMember.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xf2
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xea
	}
	if m.GroupType != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupType))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xc8
	}
	if m.Shortname != nil {
		{
			size, err := m.Shortname.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x9a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AccessHash != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GroupData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PinnedAt != nil {
		{
			size, err := m.PinnedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	if m.Clock != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x58
	}
	if len(m.BasePermissions) > 0 {
		dAtA9 := make([]byte, len(m.BasePermissions)*10)
		var j8 int
		for _, num := range m.BasePermissions {
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		i -= j8
		copy(dAtA[i:], dAtA9[:j8])
		i = encodeVarintGroups(dAtA, i, uint64(j8))
		i--
		dAtA[i] = 0x52
	}
	if m.Shortname != nil {
		{
			size, err := m.Shortname.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.About != nil {
		{
			size, err := m.About.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.OwnerUserId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.OwnerUserId))
		i--
		dAtA[i] = 0x30
	}
	if m.GroupType != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupType))
		i--
		dAtA[i] = 0x28
	}
	if m.MembersAmount != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.MembersAmount))
		i--
		dAtA[i] = 0x20
	}
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.SpaceId != nil {
		{
			size, err := m.SpaceId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupPartialInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupPartialInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupPartialInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PinnedAt != nil {
		{
			size, err := m.PinnedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.SelfMember != nil {
		{
			size, err := m.SelfMember.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Shortname != nil {
		{
			size, err := m.Shortname.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Type != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x20
	}
	if m.Clock != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Clock))
		i--
		dAtA[i] = 0x18
	}
	if m.AccessHash != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestLoadMembers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLoadMembers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestLoadMembers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Next != nil {
		{
			size, err := m.Next.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Limit != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x10
	}
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseLoadMembers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseLoadMembers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseLoadMembers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Cursor != nil {
		{
			size, err := m.Cursor.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupTitleChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupTitleChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupTitleChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupAvatarChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupAvatarChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupAvatarChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupAboutChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupAboutChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupAboutChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.About != nil {
		{
			size, err := m.About.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupOwnerChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupOwnerChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupOwnerChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupBasePermissionsChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupBasePermissionsChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupBasePermissionsChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasePermissions) > 0 {
		dAtA26 := make([]byte, len(m.BasePermissions)*10)
		var j25 int
		for _, num := range m.BasePermissions {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintGroups(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupMembersUpdated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupMembersUpdated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupMembersUpdated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupMemberDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupMemberDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupMemberDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MembersCount != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.MembersCount))
		i--
		dAtA[i] = 0x18
	}
	if len(m.AddedMembers) > 0 {
		for iNdEx := len(m.AddedMembers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddedMembers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RemovedUsers) > 0 {
		dAtA28 := make([]byte, len(m.RemovedUsers)*10)
		var j27 int
		for _, num1 := range m.RemovedUsers {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA28[j27] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j27++
			}
			dAtA28[j27] = uint8(num)
			j27++
		}
		i -= j27
		copy(dAtA[i:], dAtA28[:j27])
		i = encodeVarintGroups(dAtA, i, uint64(j27))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupMembersCountChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupMembersCountChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupMembersCountChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MembersCount != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.MembersCount))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestCreateGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestCreateGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestCreateGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BasePermissions) > 0 {
		dAtA30 := make([]byte, len(m.BasePermissions)*10)
		var j29 int
		for _, num := range m.BasePermissions {
			for num >= 1<<7 {
				dAtA30[j29] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j29++
			}
			dAtA30[j29] = uint8(num)
			j29++
		}
		i -= j29
		copy(dAtA[i:], dAtA30[:j29])
		i = encodeVarintGroups(dAtA, i, uint64(j29))
		i--
		dAtA[i] = 0x52
	}
	if m.SpaceId != nil {
		{
			size, err := m.SpaceId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.Username != nil {
		{
			size, err := m.Username.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.Optimizations) > 0 {
		dAtA34 := make([]byte, len(m.Optimizations)*10)
		var j33 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		i -= j33
		copy(dAtA[i:], dAtA34[:j33])
		i = encodeVarintGroups(dAtA, i, uint64(j33))
		i--
		dAtA[i] = 0x3a
	}
	if m.GroupType != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupType))
		i--
		dAtA[i] = 0x30
	}
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x12
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseCreateGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseCreateGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseCreateGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserPeers) > 0 {
		for iNdEx := len(m.UserPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestEditGroupTitle) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEditGroupTitle) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestEditGroupTitle) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA37 := make([]byte, len(m.Optimizations)*10)
		var j36 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA37[j36] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j36++
			}
			dAtA37[j36] = uint8(num)
			j36++
		}
		i -= j36
		copy(dAtA[i:], dAtA37[:j36])
		i = encodeVarintGroups(dAtA, i, uint64(j36))
		i--
		dAtA[i] = 0x2a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestSetGroupShortname) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestSetGroupShortname) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestSetGroupShortname) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shortname) > 0 {
		i -= len(m.Shortname)
		copy(dAtA[i:], m.Shortname)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Shortname)))
		i--
		dAtA[i] = 0x12
	}
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestEditGroupAvatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEditGroupAvatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestEditGroupAvatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA41 := make([]byte, len(m.Optimizations)*10)
		var j40 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA41[j40] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j40++
			}
			dAtA41[j40] = uint8(num)
			j40++
		}
		i -= j40
		copy(dAtA[i:], dAtA41[:j40])
		i = encodeVarintGroups(dAtA, i, uint64(j40))
		i--
		dAtA[i] = 0x2a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x20
	}
	if m.FileLocation != nil {
		{
			size, err := m.FileLocation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseEditGroupAvatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseEditGroupAvatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseEditGroupAvatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestRemoveGroupAvatar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRemoveGroupAvatar) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestRemoveGroupAvatar) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA47 := make([]byte, len(m.Optimizations)*10)
		var j46 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		i -= j46
		copy(dAtA[i:], dAtA47[:j46])
		i = encodeVarintGroups(dAtA, i, uint64(j46))
		i--
		dAtA[i] = 0x2a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x20
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestEditGroupAbout) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEditGroupAbout) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestEditGroupAbout) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA50 := make([]byte, len(m.Optimizations)*10)
		var j49 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA50[j49] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j49++
			}
			dAtA50[j49] = uint8(num)
			j49++
		}
		i -= j49
		copy(dAtA[i:], dAtA50[:j49])
		i = encodeVarintGroups(dAtA, i, uint64(j49))
		i--
		dAtA[i] = 0x2a
	}
	if m.About != nil {
		{
			size, err := m.About.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestEditGroupBasePermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEditGroupBasePermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestEditGroupBasePermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RevokedPermissions) > 0 {
		dAtA54 := make([]byte, len(m.RevokedPermissions)*10)
		var j53 int
		for _, num := range m.RevokedPermissions {
			for num >= 1<<7 {
				dAtA54[j53] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j53++
			}
			dAtA54[j53] = uint8(num)
			j53++
		}
		i -= j53
		copy(dAtA[i:], dAtA54[:j53])
		i = encodeVarintGroups(dAtA, i, uint64(j53))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GrantedPermissions) > 0 {
		dAtA56 := make([]byte, len(m.GrantedPermissions)*10)
		var j55 int
		for _, num := range m.GrantedPermissions {
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintGroups(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x1a
	}
	if m.RandomId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.RandomId))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestEditMemberPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestEditMemberPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestEditMemberPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RevokedPermissions) > 0 {
		dAtA59 := make([]byte, len(m.RevokedPermissions)*10)
		var j58 int
		for _, num := range m.RevokedPermissions {
			for num >= 1<<7 {
				dAtA59[j58] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j58++
			}
			dAtA59[j58] = uint8(num)
			j58++
		}
		i -= j58
		copy(dAtA[i:], dAtA59[:j58])
		i = encodeVarintGroups(dAtA, i, uint64(j58))
		i--
		dAtA[i] = 0x22
	}
	if len(m.GrantedPermissions) > 0 {
		dAtA61 := make([]byte, len(m.GrantedPermissions)*10)
		var j60 int
		for _, num := range m.GrantedPermissions {
			for num >= 1<<7 {
				dAtA61[j60] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j60++
			}
			dAtA61[j60] = uint8(num)
			j60++
		}
		i -= j60
		copy(dAtA[i:], dAtA61[:j60])
		i = encodeVarintGroups(dAtA, i, uint64(j60))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserPeer != nil {
		{
			size, err := m.UserPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseMember) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseMember) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseMember) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestInviteUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestInviteUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestInviteUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA66 := make([]byte, len(m.Optimizations)*10)
		var j65 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA66[j65] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j65++
			}
			dAtA66[j65] = uint8(num)
			j65++
		}
		i -= j65
		copy(dAtA[i:], dAtA66[:j65])
		i = encodeVarintGroups(dAtA, i, uint64(j65))
		i--
		dAtA[i] = 0x2a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x20
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestLeaveGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestLeaveGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestLeaveGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA70 := make([]byte, len(m.Optimizations)*10)
		var j69 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA70[j69] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j69++
			}
			dAtA70[j69] = uint8(num)
			j69++
		}
		i -= j69
		copy(dAtA[i:], dAtA70[:j69])
		i = encodeVarintGroups(dAtA, i, uint64(j69))
		i--
		dAtA[i] = 0x1a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestKickUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestKickUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestKickUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA73 := make([]byte, len(m.Optimizations)*10)
		var j72 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA73[j72] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j72++
			}
			dAtA73[j72] = uint8(num)
			j72++
		}
		i -= j72
		copy(dAtA[i:], dAtA73[:j72])
		i = encodeVarintGroups(dAtA, i, uint64(j72))
		i--
		dAtA[i] = 0x2a
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x20
	}
	if m.User != nil {
		{
			size, err := m.User.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestMakeUserAdmin) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestMakeUserAdmin) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestMakeUserAdmin) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		dAtA77 := make([]byte, len(m.Permissions)*10)
		var j76 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA77[j76] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j76++
			}
			dAtA77[j76] = uint8(num)
			j76++
		}
		i -= j76
		copy(dAtA[i:], dAtA77[:j76])
		i = encodeVarintGroups(dAtA, i, uint64(j76))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserPeer != nil {
		{
			size, err := m.UserPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GroupMemberPermission) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GroupMemberPermission) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GroupMemberPermission) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		dAtA81 := make([]byte, len(m.Permissions)*10)
		var j80 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA81[j80] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j80++
			}
			dAtA81[j80] = uint8(num)
			j80++
		}
		i -= j80
		copy(dAtA[i:], dAtA81[:j80])
		i = encodeVarintGroups(dAtA, i, uint64(j80))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetGroupMemberPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetGroupMemberPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetGroupMemberPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserIds) > 0 {
		dAtA83 := make([]byte, len(m.UserIds)*10)
		var j82 int
		for _, num1 := range m.UserIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA83[j82] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j82++
			}
			dAtA83[j82] = uint8(num)
			j82++
		}
		i -= j82
		copy(dAtA[i:], dAtA83[:j82])
		i = encodeVarintGroups(dAtA, i, uint64(j82))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResponseGetGroupMemberPermissions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetGroupMemberPermissions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetGroupMemberPermissions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for iNdEx := len(m.Permissions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Permissions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupMemberPermissionsChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupMemberPermissionsChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupMemberPermissionsChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		dAtA85 := make([]byte, len(m.Permissions)*10)
		var j84 int
		for _, num := range m.Permissions {
			for num >= 1<<7 {
				dAtA85[j84] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j84++
			}
			dAtA85[j84] = uint8(num)
			j84++
		}
		i -= j84
		copy(dAtA[i:], dAtA85[:j84])
		i = encodeVarintGroups(dAtA, i, uint64(j84))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RequestTransferOwnership) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestTransferOwnership) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestTransferOwnership) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewOwner != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.NewOwner))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseInviteUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseInviteUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseInviteUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetGroupInviteUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetGroupInviteUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetGroupInviteUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestGetGroupInviteUrlBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestGetGroupInviteUrlBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestGetGroupInviteUrlBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *ResponseGetGroupInviteUrlBase) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseGetGroupInviteUrlBase) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseGetGroupInviteUrlBase) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestRevokeInviteUrl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestRevokeInviteUrl) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestRevokeInviteUrl) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupPeer != nil {
		{
			size, err := m.GroupPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestJoinGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestJoinGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestJoinGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Optimizations) > 0 {
		dAtA90 := make([]byte, len(m.Optimizations)*10)
		var j89 int
		for _, num := range m.Optimizations {
			for num >= 1<<7 {
				dAtA90[j89] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j89++
			}
			dAtA90[j89] = uint8(num)
			j89++
		}
		i -= j89
		copy(dAtA[i:], dAtA90[:j89])
		i = encodeVarintGroups(dAtA, i, uint64(j89))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseJoinGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseJoinGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseJoinGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if len(m.UserPeers) > 0 {
		for iNdEx := len(m.UserPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.Group != nil {
		{
			size, err := m.Group.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestJoinGroupByPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestJoinGroupByPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestJoinGroupByPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Peer != nil {
		{
			size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestDeleteGroup) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestDeleteGroup) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestDeleteGroup) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupMemberInvited) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupMemberInvited) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupMemberInvited) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Member != nil {
		{
			size, err := m.Member.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupInviteObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupInviteObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupInviteObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x48
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x40
	}
	if m.InviteUid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.InviteUid))
		i--
		dAtA[i] = 0x28
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupUserInvitedObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupUserInvitedObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupUserInvitedObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Rid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Rid))
		i--
		dAtA[i] = 0x28
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.InviterUid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.InviterUid))
		i--
		dAtA[i] = 0x18
	}
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupUserLeaveObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupUserLeaveObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupUserLeaveObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x18
	}
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupUserKickObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupUserKickObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupUserKickObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.KickerUid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.KickerUid))
		i--
		dAtA[i] = 0x18
	}
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupMembersUpdateObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupMembersUpdateObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupMembersUpdateObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Members) > 0 {
		for iNdEx := len(m.Members) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Members[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintGroups(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupTitleChangedObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupTitleChangedObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupTitleChangedObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupAboutChangedObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupAboutChangedObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupAboutChangedObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.About != nil {
		{
			size, err := m.About.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupAvatarChangedObsolete) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupAvatarChangedObsolete) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupAvatarChangedObsolete) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Mid != nil {
		{
			size, err := m.Mid.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Date != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x20
	}
	if m.Avatar != nil {
		{
			size, err := m.Avatar.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintGroups(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x10
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UpdateGroupShortnameChanged) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateGroupShortnameChanged) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateGroupShortnameChanged) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Uid != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.Uid))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shortname) > 0 {
		i -= len(m.Shortname)
		copy(dAtA[i:], m.Shortname)
		i = encodeVarintGroups(dAtA, i, uint64(len(m.Shortname)))
		i--
		dAtA[i] = 0x12
	}
	if m.GroupId != 0 {
		i = encodeVarintGroups(dAtA, i, uint64(m.GroupId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintGroups(dAtA []byte, offset int, v uint64) int {
	offset -= sovGroups(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	if m.InvitedAt != 0 {
		n += 1 + sovGroups(uint64(m.InvitedAt))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	if m.Clock != 0 {
		n += 1 + sovGroups(uint64(m.Clock))
	}
	if m.DeletedAt != nil {
		l = m.DeletedAt.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *Group) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGroups(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovGroups(uint64(m.AccessHash))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Shortname != nil {
		l = m.Shortname.Size()
		n += 2 + l + sovGroups(uint64(l))
	}
	if m.GroupType != 0 {
		n += 2 + sovGroups(uint64(m.GroupType))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 2 + l + sovGroups(uint64(l))
	}
	if m.SelfMember != nil {
		l = m.SelfMember.Size()
		n += 2 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *GroupData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SpaceId != nil {
		l = m.SpaceId.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.MembersAmount != 0 {
		n += 1 + sovGroups(uint64(m.MembersAmount))
	}
	if m.GroupType != 0 {
		n += 1 + sovGroups(uint64(m.GroupType))
	}
	if m.OwnerUserId != 0 {
		n += 1 + sovGroups(uint64(m.OwnerUserId))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.About != nil {
		l = m.About.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Shortname != nil {
		l = m.Shortname.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.BasePermissions) > 0 {
		l = 0
		for _, e := range m.BasePermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	if m.Clock != 0 {
		n += 1 + sovGroups(uint64(m.Clock))
	}
	if m.PinnedAt != nil {
		l = m.PinnedAt.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *GroupPartialInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGroups(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovGroups(uint64(m.AccessHash))
	}
	if m.Clock != 0 {
		n += 1 + sovGroups(uint64(m.Clock))
	}
	if m.Type != 0 {
		n += 1 + sovGroups(uint64(m.Type))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Shortname != nil {
		l = m.Shortname.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.SelfMember != nil {
		l = m.SelfMember.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.PinnedAt != nil {
		l = m.PinnedAt.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovGroups(uint64(m.Id))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestLoadMembers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovGroups(uint64(m.Limit))
	}
	if m.Next != nil {
		l = m.Next.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *ResponseLoadMembers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cursor != nil {
		l = m.Cursor.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	return n
}

func (m *UpdateGroupTitleChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupAvatarChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupAboutChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.About != nil {
		l = m.About.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupOwnerChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.UserId != 0 {
		n += 1 + sovGroups(uint64(m.UserId))
	}
	return n
}

func (m *UpdateGroupBasePermissionsChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if len(m.BasePermissions) > 0 {
		l = 0
		for _, e := range m.BasePermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *UpdateGroupMembersUpdated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	return n
}

func (m *UpdateGroupMemberDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RemovedUsers) > 0 {
		l = 0
		for _, e := range m.RemovedUsers {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	if len(m.AddedMembers) > 0 {
		for _, e := range m.AddedMembers {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	if m.MembersCount != 0 {
		n += 1 + sovGroups(uint64(m.MembersCount))
	}
	return n
}

func (m *UpdateGroupMembersCountChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.MembersCount != 0 {
		n += 1 + sovGroups(uint64(m.MembersCount))
	}
	return n
}

func (m *RequestCreateGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	if m.GroupType != 0 {
		n += 1 + sovGroups(uint64(m.GroupType))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	if m.Username != nil {
		l = m.Username.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.SpaceId != nil {
		l = m.SpaceId.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.BasePermissions) > 0 {
		l = 0
		for _, e := range m.BasePermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *ResponseCreateGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovGroups(uint64(m.Seq))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.UserPeers) > 0 {
		for _, e := range m.UserPeers {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	return n
}

func (m *RequestEditGroupTitle) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestSetGroupShortname) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	l = len(m.Shortname)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestEditGroupAvatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.FileLocation != nil {
		l = m.FileLocation.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *ResponseEditGroupAvatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovGroups(uint64(m.Seq))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestRemoveGroupAvatar) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestEditGroupAbout) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if m.About != nil {
		l = m.About.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestEditGroupBasePermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.RandomId != 0 {
		n += 1 + sovGroups(uint64(m.RandomId))
	}
	if len(m.GrantedPermissions) > 0 {
		l = 0
		for _, e := range m.GrantedPermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	if len(m.RevokedPermissions) > 0 {
		l = 0
		for _, e := range m.RevokedPermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestEditMemberPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.UserPeer != nil {
		l = m.UserPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.GrantedPermissions) > 0 {
		l = 0
		for _, e := range m.GrantedPermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	if len(m.RevokedPermissions) > 0 {
		l = 0
		for _, e := range m.RevokedPermissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *ResponseMember) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestInviteUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestLeaveGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestKickUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.User != nil {
		l = m.User.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestMakeUserAdmin) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.UserPeer != nil {
		l = m.UserPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *GroupMemberPermission) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovGroups(uint64(m.UserId))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestGetGroupMemberPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if len(m.UserIds) > 0 {
		l = 0
		for _, e := range m.UserIds {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *ResponseGetGroupMemberPermissions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Permissions) > 0 {
		for _, e := range m.Permissions {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	return n
}

func (m *UpdateGroupMemberPermissionsChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.UserId != 0 {
		n += 1 + sovGroups(uint64(m.UserId))
	}
	if len(m.Permissions) > 0 {
		l = 0
		for _, e := range m.Permissions {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *RequestTransferOwnership) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.NewOwner != 0 {
		n += 1 + sovGroups(uint64(m.NewOwner))
	}
	return n
}

func (m *ResponseInviteUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestGetGroupInviteUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestGetGroupInviteUrlBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *ResponseGetGroupInviteUrlBase) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestRevokeInviteUrl) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupPeer != nil {
		l = m.GroupPeer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestJoinGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if len(m.Optimizations) > 0 {
		l = 0
		for _, e := range m.Optimizations {
			l += sovGroups(uint64(e))
		}
		n += 1 + sovGroups(uint64(l)) + l
	}
	return n
}

func (m *ResponseJoinGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Seq != 0 {
		n += 1 + sovGroups(uint64(m.Seq))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if len(m.UserPeers) > 0 {
		for _, e := range m.UserPeers {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestJoinGroupByPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Peer != nil {
		l = m.Peer.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *RequestDeleteGroup) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	return n
}

func (m *UpdateGroupMemberInvited) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Member != nil {
		l = m.Member.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupInviteObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.InviteUid != 0 {
		n += 1 + sovGroups(uint64(m.InviteUid))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupUserInvitedObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	if m.InviterUid != 0 {
		n += 1 + sovGroups(uint64(m.InviterUid))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Rid != 0 {
		n += 1 + sovGroups(uint64(m.Rid))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupUserLeaveObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupUserKickObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	if m.KickerUid != 0 {
		n += 1 + sovGroups(uint64(m.KickerUid))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupMembersUpdateObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if len(m.Members) > 0 {
		for _, e := range m.Members {
			l = e.Size()
			n += 1 + l + sovGroups(uint64(l))
		}
	}
	return n
}

func (m *UpdateGroupTitleChangedObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupAboutChangedObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.About != nil {
		l = m.About.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupAvatarChangedObsolete) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	if m.Avatar != nil {
		l = m.Avatar.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Date != 0 {
		n += 1 + sovGroups(uint64(m.Date))
	}
	if m.Mid != nil {
		l = m.Mid.Size()
		n += 1 + l + sovGroups(uint64(l))
	}
	return n
}

func (m *UpdateGroupShortnameChanged) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GroupId != 0 {
		n += 1 + sovGroups(uint64(m.GroupId))
	}
	l = len(m.Shortname)
	if l > 0 {
		n += 1 + l + sovGroups(uint64(l))
	}
	if m.Uid != 0 {
		n += 1 + sovGroups(uint64(m.Uid))
	}
	return n
}

func sovGroups(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozGroups(x uint64) (n int) {
	return sovGroups(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Member) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Member{`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`InvitedAt:` + fmt.Sprintf("%v", this.InvitedAt) + `,`,
		`Permissions:` + fmt.Sprintf("%v", this.Permissions) + `,`,
		`Clock:` + fmt.Sprintf("%v", this.Clock) + `,`,
		`DeletedAt:` + strings.Replace(fmt.Sprintf("%v", this.DeletedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Group) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Group{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`AccessHash:` + fmt.Sprintf("%v", this.AccessHash) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Shortname:` + strings.Replace(fmt.Sprintf("%v", this.Shortname), "StringValue", "types.StringValue", 1) + `,`,
		`GroupType:` + fmt.Sprintf("%v", this.GroupType) + `,`,
		`Data:` + strings.Replace(this.Data.String(), "GroupData", "GroupData", 1) + `,`,
		`SelfMember:` + strings.Replace(this.SelfMember.String(), "Member", "Member", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupData{`,
		`SpaceId:` + strings.Replace(fmt.Sprintf("%v", this.SpaceId), "UUIDValue", "UUIDValue", 1) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Avatar:` + strings.Replace(fmt.Sprintf("%v", this.Avatar), "Avatar", "Avatar", 1) + `,`,
		`MembersAmount:` + fmt.Sprintf("%v", this.MembersAmount) + `,`,
		`GroupType:` + fmt.Sprintf("%v", this.GroupType) + `,`,
		`OwnerUserId:` + fmt.Sprintf("%v", this.OwnerUserId) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`About:` + strings.Replace(fmt.Sprintf("%v", this.About), "StringValue", "types.StringValue", 1) + `,`,
		`Shortname:` + strings.Replace(fmt.Sprintf("%v", this.Shortname), "StringValue", "types.StringValue", 1) + `,`,
		`BasePermissions:` + fmt.Sprintf("%v", this.BasePermissions) + `,`,
		`Clock:` + fmt.Sprintf("%v", this.Clock) + `,`,
		`PinnedAt:` + strings.Replace(fmt.Sprintf("%v", this.PinnedAt), "Int64Value", "types.Int64Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupPartialInfo) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupPartialInfo{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`AccessHash:` + fmt.Sprintf("%v", this.AccessHash) + `,`,
		`Clock:` + fmt.Sprintf("%v", this.Clock) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Shortname:` + strings.Replace(fmt.Sprintf("%v", this.Shortname), "StringValue", "types.StringValue", 1) + `,`,
		`Avatar:` + strings.Replace(fmt.Sprintf("%v", this.Avatar), "Avatar", "Avatar", 1) + `,`,
		`SelfMember:` + strings.Replace(this.SelfMember.String(), "Member", "Member", 1) + `,`,
		`PinnedAt:` + strings.Replace(fmt.Sprintf("%v", this.PinnedAt), "Int64Value", "types.Int64Value", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroup{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Data:` + strings.Replace(this.Data.String(), "GroupData", "GroupData", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestLoadMembers) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestLoadMembers{`,
		`Group:` + strings.Replace(fmt.Sprintf("%v", this.Group), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`Limit:` + fmt.Sprintf("%v", this.Limit) + `,`,
		`Next:` + strings.Replace(fmt.Sprintf("%v", this.Next), "BytesValue", "types.BytesValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseLoadMembers) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*Member{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "Member", "Member", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&ResponseLoadMembers{`,
		`Cursor:` + strings.Replace(fmt.Sprintf("%v", this.Cursor), "BytesValue", "types.BytesValue", 1) + `,`,
		`Members:` + repeatedStringForMembers + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupTitleChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupTitleChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupAvatarChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupAvatarChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Avatar:` + strings.Replace(fmt.Sprintf("%v", this.Avatar), "Avatar", "Avatar", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupAboutChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupAboutChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`About:` + strings.Replace(fmt.Sprintf("%v", this.About), "StringValue", "types.StringValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupOwnerChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupOwnerChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupBasePermissionsChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupBasePermissionsChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`BasePermissions:` + fmt.Sprintf("%v", this.BasePermissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupMembersUpdated) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*Member{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "Member", "Member", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&UpdateGroupMembersUpdated{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Members:` + repeatedStringForMembers + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupMemberDiff) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAddedMembers := "[]*Member{"
	for _, f := range this.AddedMembers {
		repeatedStringForAddedMembers += strings.Replace(f.String(), "Member", "Member", 1) + ","
	}
	repeatedStringForAddedMembers += "}"
	s := strings.Join([]string{`&UpdateGroupMemberDiff{`,
		`RemovedUsers:` + fmt.Sprintf("%v", this.RemovedUsers) + `,`,
		`AddedMembers:` + repeatedStringForAddedMembers + `,`,
		`MembersCount:` + fmt.Sprintf("%v", this.MembersCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupMembersCountChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupMembersCountChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`MembersCount:` + fmt.Sprintf("%v", this.MembersCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestCreateGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUsers := "[]*UserOutPeer{"
	for _, f := range this.Users {
		repeatedStringForUsers += strings.Replace(fmt.Sprintf("%v", f), "UserOutPeer", "UserOutPeer", 1) + ","
	}
	repeatedStringForUsers += "}"
	s := strings.Join([]string{`&RequestCreateGroup{`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Users:` + repeatedStringForUsers + `,`,
		`GroupType:` + fmt.Sprintf("%v", this.GroupType) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`Username:` + strings.Replace(fmt.Sprintf("%v", this.Username), "StringValue", "types.StringValue", 1) + `,`,
		`SpaceId:` + strings.Replace(fmt.Sprintf("%v", this.SpaceId), "UUIDValue", "UUIDValue", 1) + `,`,
		`BasePermissions:` + fmt.Sprintf("%v", this.BasePermissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseCreateGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUserPeers := "[]*UserOutPeer{"
	for _, f := range this.UserPeers {
		repeatedStringForUserPeers += strings.Replace(fmt.Sprintf("%v", f), "UserOutPeer", "UserOutPeer", 1) + ","
	}
	repeatedStringForUserPeers += "}"
	s := strings.Join([]string{`&ResponseCreateGroup{`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Group:` + strings.Replace(this.Group.String(), "Group", "Group", 1) + `,`,
		`UserPeers:` + repeatedStringForUserPeers + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestEditGroupTitle) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestEditGroupTitle{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestSetGroupShortname) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestSetGroupShortname{`,
		`Peer:` + strings.Replace(fmt.Sprintf("%v", this.Peer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`Shortname:` + fmt.Sprintf("%v", this.Shortname) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestEditGroupAvatar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestEditGroupAvatar{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`FileLocation:` + strings.Replace(fmt.Sprintf("%v", this.FileLocation), "FileLocation", "FileLocation", 1) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseEditGroupAvatar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseEditGroupAvatar{`,
		`Avatar:` + strings.Replace(fmt.Sprintf("%v", this.Avatar), "Avatar", "Avatar", 1) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestRemoveGroupAvatar) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestRemoveGroupAvatar{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestEditGroupAbout) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestEditGroupAbout{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`About:` + strings.Replace(fmt.Sprintf("%v", this.About), "StringValue", "types.StringValue", 1) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestEditGroupBasePermissions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestEditGroupBasePermissions{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`RandomId:` + fmt.Sprintf("%v", this.RandomId) + `,`,
		`GrantedPermissions:` + fmt.Sprintf("%v", this.GrantedPermissions) + `,`,
		`RevokedPermissions:` + fmt.Sprintf("%v", this.RevokedPermissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestEditMemberPermissions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestEditMemberPermissions{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`UserPeer:` + strings.Replace(fmt.Sprintf("%v", this.UserPeer), "UserOutPeer", "UserOutPeer", 1) + `,`,
		`GrantedPermissions:` + fmt.Sprintf("%v", this.GrantedPermissions) + `,`,
		`RevokedPermissions:` + fmt.Sprintf("%v", this.RevokedPermissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseMember) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseMember{`,
		`Member:` + strings.Replace(this.Member.String(), "Member", "Member", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestInviteUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestInviteUser{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`User:` + strings.Replace(fmt.Sprintf("%v", this.User), "UserOutPeer", "UserOutPeer", 1) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestLeaveGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestLeaveGroup{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestKickUser) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestKickUser{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`User:` + strings.Replace(fmt.Sprintf("%v", this.User), "UserOutPeer", "UserOutPeer", 1) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestMakeUserAdmin) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestMakeUserAdmin{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`UserPeer:` + strings.Replace(fmt.Sprintf("%v", this.UserPeer), "UserOutPeer", "UserOutPeer", 1) + `,`,
		`Permissions:` + fmt.Sprintf("%v", this.Permissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *GroupMemberPermission) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&GroupMemberPermission{`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Permissions:` + fmt.Sprintf("%v", this.Permissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetGroupMemberPermissions) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetGroupMemberPermissions{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`UserIds:` + fmt.Sprintf("%v", this.UserIds) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetGroupMemberPermissions) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForPermissions := "[]*GroupMemberPermission{"
	for _, f := range this.Permissions {
		repeatedStringForPermissions += strings.Replace(f.String(), "GroupMemberPermission", "GroupMemberPermission", 1) + ","
	}
	repeatedStringForPermissions += "}"
	s := strings.Join([]string{`&ResponseGetGroupMemberPermissions{`,
		`Permissions:` + repeatedStringForPermissions + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupMemberPermissionsChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupMemberPermissionsChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`UserId:` + fmt.Sprintf("%v", this.UserId) + `,`,
		`Permissions:` + fmt.Sprintf("%v", this.Permissions) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestTransferOwnership) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestTransferOwnership{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`NewOwner:` + fmt.Sprintf("%v", this.NewOwner) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseInviteUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseInviteUrl{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetGroupInviteUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetGroupInviteUrl{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestGetGroupInviteUrlBase) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestGetGroupInviteUrlBase{`,
		`}`,
	}, "")
	return s
}
func (this *ResponseGetGroupInviteUrlBase) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ResponseGetGroupInviteUrlBase{`,
		`Url:` + fmt.Sprintf("%v", this.Url) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestRevokeInviteUrl) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestRevokeInviteUrl{`,
		`GroupPeer:` + strings.Replace(fmt.Sprintf("%v", this.GroupPeer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestJoinGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestJoinGroup{`,
		`Token:` + fmt.Sprintf("%v", this.Token) + `,`,
		`Optimizations:` + fmt.Sprintf("%v", this.Optimizations) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ResponseJoinGroup) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForUserPeers := "[]*UserOutPeer{"
	for _, f := range this.UserPeers {
		repeatedStringForUserPeers += strings.Replace(fmt.Sprintf("%v", f), "UserOutPeer", "UserOutPeer", 1) + ","
	}
	repeatedStringForUserPeers += "}"
	s := strings.Join([]string{`&ResponseJoinGroup{`,
		`Group:` + strings.Replace(this.Group.String(), "Group", "Group", 1) + `,`,
		`Seq:` + fmt.Sprintf("%v", this.Seq) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`UserPeers:` + repeatedStringForUserPeers + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestJoinGroupByPeer) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestJoinGroupByPeer{`,
		`Peer:` + strings.Replace(fmt.Sprintf("%v", this.Peer), "GroupOutPeer", "GroupOutPeer", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *RequestDeleteGroup) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&RequestDeleteGroup{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupMemberInvited) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupMemberInvited{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Member:` + strings.Replace(this.Member.String(), "Member", "Member", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupInviteObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupInviteObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`InviteUid:` + fmt.Sprintf("%v", this.InviteUid) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupUserInvitedObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupUserInvitedObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`InviterUid:` + fmt.Sprintf("%v", this.InviterUid) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Rid:` + fmt.Sprintf("%v", this.Rid) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupUserLeaveObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupUserLeaveObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupUserKickObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupUserKickObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`KickerUid:` + fmt.Sprintf("%v", this.KickerUid) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupMembersUpdateObsolete) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForMembers := "[]*Member{"
	for _, f := range this.Members {
		repeatedStringForMembers += strings.Replace(f.String(), "Member", "Member", 1) + ","
	}
	repeatedStringForMembers += "}"
	s := strings.Join([]string{`&UpdateGroupMembersUpdateObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Members:` + repeatedStringForMembers + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupTitleChangedObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupTitleChangedObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Title:` + fmt.Sprintf("%v", this.Title) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupAboutChangedObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupAboutChangedObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`About:` + strings.Replace(fmt.Sprintf("%v", this.About), "StringValue", "types.StringValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupAvatarChangedObsolete) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupAvatarChangedObsolete{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`Avatar:` + strings.Replace(fmt.Sprintf("%v", this.Avatar), "Avatar", "Avatar", 1) + `,`,
		`Date:` + fmt.Sprintf("%v", this.Date) + `,`,
		`Mid:` + strings.Replace(fmt.Sprintf("%v", this.Mid), "UUIDValue", "UUIDValue", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *UpdateGroupShortnameChanged) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&UpdateGroupShortnameChanged{`,
		`GroupId:` + fmt.Sprintf("%v", this.GroupId) + `,`,
		`Shortname:` + fmt.Sprintf("%v", this.Shortname) + `,`,
		`Uid:` + fmt.Sprintf("%v", this.Uid) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringGroups(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvitedAt", wireType)
			}
			m.InvitedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InvitedAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletedAt == nil {
				m.DeletedAt = &types.Timestamp{}
			}
			if err := m.DeletedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Group) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortname", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shortname == nil {
				m.Shortname = &types.StringValue{}
			}
			if err := m.Shortname.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 25:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= GroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 29:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &GroupData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfMember", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelfMember == nil {
				m.SelfMember = &Member{}
			}
			if err := m.SelfMember.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpaceId == nil {
				m.SpaceId = &UUIDValue{}
			}
			if err := m.SpaceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &Avatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembersAmount", wireType)
			}
			m.MembersAmount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MembersAmount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= GroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerUserId", wireType)
			}
			m.OwnerUserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OwnerUserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.About == nil {
				m.About = &types.StringValue{}
			}
			if err := m.About.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortname", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shortname == nil {
				m.Shortname = &types.StringValue{}
			}
			if err := m.Shortname.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BasePermissions = append(m.BasePermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.BasePermissions) == 0 {
					m.BasePermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BasePermissions = append(m.BasePermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePermissions", wireType)
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedAt == nil {
				m.PinnedAt = &types.Int64Value{}
			}
			if err := m.PinnedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupPartialInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupPartialInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupPartialInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Clock", wireType)
			}
			m.Clock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Clock |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= GroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortname", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shortname == nil {
				m.Shortname = &types.StringValue{}
			}
			if err := m.Shortname.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &Avatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfMember", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SelfMember == nil {
				m.SelfMember = &Member{}
			}
			if err := m.SelfMember.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PinnedAt == nil {
				m.PinnedAt = &types.Int64Value{}
			}
			if err := m.PinnedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &GroupData{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLoadMembers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLoadMembers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLoadMembers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &GroupOutPeer{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Next", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Next == nil {
				m.Next = &types.BytesValue{}
			}
			if err := m.Next.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseLoadMembers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseLoadMembers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseLoadMembers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cursor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cursor == nil {
				m.Cursor = &types.BytesValue{}
			}
			if err := m.Cursor.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupTitleChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupTitleChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupTitleChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupAvatarChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupAvatarChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupAvatarChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &Avatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupAboutChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupAboutChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupAboutChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.About == nil {
				m.About = &types.StringValue{}
			}
			if err := m.About.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupOwnerChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupOwnerChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupOwnerChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupBasePermissionsChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupBasePermissionsChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupBasePermissionsChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BasePermissions = append(m.BasePermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.BasePermissions) == 0 {
					m.BasePermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BasePermissions = append(m.BasePermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePermissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupMembersUpdated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupMembersUpdated: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupMembersUpdated: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupMemberDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupMemberDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupMemberDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RemovedUsers = append(m.RemovedUsers, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.RemovedUsers) == 0 {
					m.RemovedUsers = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RemovedUsers = append(m.RemovedUsers, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovedUsers", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddedMembers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddedMembers = append(m.AddedMembers, &Member{})
			if err := m.AddedMembers[len(m.AddedMembers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembersCount", wireType)
			}
			m.MembersCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MembersCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupMembersCountChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupMembersCountChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupMembersCountChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembersCount", wireType)
			}
			m.MembersCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MembersCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestCreateGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestCreateGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestCreateGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &UserOutPeer{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupType", wireType)
			}
			m.GroupType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupType |= GroupType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Username == nil {
				m.Username = &types.StringValue{}
			}
			if err := m.Username.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpaceId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SpaceId == nil {
				m.SpaceId = &UUIDValue{}
			}
			if err := m.SpaceId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.BasePermissions = append(m.BasePermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.BasePermissions) == 0 {
					m.BasePermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.BasePermissions = append(m.BasePermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field BasePermissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseCreateGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseCreateGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseCreateGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPeers = append(m.UserPeers, &UserOutPeer{})
			if err := m.UserPeers[len(m.UserPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEditGroupTitle) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEditGroupTitle: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEditGroupTitle: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestSetGroupShortname) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestSetGroupShortname: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestSetGroupShortname: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &GroupOutPeer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shortname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEditGroupAvatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEditGroupAvatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEditGroupAvatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FileLocation == nil {
				m.FileLocation = &FileLocation{}
			}
			if err := m.FileLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseEditGroupAvatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseEditGroupAvatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseEditGroupAvatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &Avatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRemoveGroupAvatar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRemoveGroupAvatar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRemoveGroupAvatar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEditGroupAbout) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEditGroupAbout: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEditGroupAbout: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.About == nil {
				m.About = &types.StringValue{}
			}
			if err := m.About.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEditGroupBasePermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEditGroupBasePermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEditGroupBasePermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomId", wireType)
			}
			m.RandomId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RandomId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GrantedPermissions = append(m.GrantedPermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GrantedPermissions) == 0 {
					m.GrantedPermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GrantedPermissions = append(m.GrantedPermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantedPermissions", wireType)
			}
		case 4:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RevokedPermissions = append(m.RevokedPermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RevokedPermissions) == 0 {
					m.RevokedPermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RevokedPermissions = append(m.RevokedPermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedPermissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestEditMemberPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestEditMemberPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestEditMemberPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPeer == nil {
				m.UserPeer = &UserOutPeer{}
			}
			if err := m.UserPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.GrantedPermissions = append(m.GrantedPermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.GrantedPermissions) == 0 {
					m.GrantedPermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.GrantedPermissions = append(m.GrantedPermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field GrantedPermissions", wireType)
			}
		case 4:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.RevokedPermissions = append(m.RevokedPermissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.RevokedPermissions) == 0 {
					m.RevokedPermissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.RevokedPermissions = append(m.RevokedPermissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field RevokedPermissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseMember) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseMember: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseMember: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestInviteUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestInviteUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestInviteUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserOutPeer{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestLeaveGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestLeaveGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestLeaveGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestKickUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestKickUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestKickUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field User", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.User == nil {
				m.User = &UserOutPeer{}
			}
			if err := m.User.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestMakeUserAdmin) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMakeUserAdmin: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMakeUserAdmin: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UserPeer == nil {
				m.UserPeer = &UserOutPeer{}
			}
			if err := m.UserPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GroupMemberPermission) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GroupMemberPermission: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GroupMemberPermission: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetGroupMemberPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetGroupMemberPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetGroupMemberPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.UserIds = append(m.UserIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.UserIds) == 0 {
					m.UserIds = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.UserIds = append(m.UserIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetGroupMemberPermissions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetGroupMemberPermissions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetGroupMemberPermissions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permissions = append(m.Permissions, &GroupMemberPermission{})
			if err := m.Permissions[len(m.Permissions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupMemberPermissionsChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupMemberPermissionsChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupMemberPermissionsChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v GroupAdminPermission
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= GroupAdminPermission(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Permissions = append(m.Permissions, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Permissions) == 0 {
					m.Permissions = make([]GroupAdminPermission, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v GroupAdminPermission
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= GroupAdminPermission(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Permissions = append(m.Permissions, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Permissions", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestTransferOwnership) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestTransferOwnership: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestTransferOwnership: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewOwner", wireType)
			}
			m.NewOwner = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewOwner |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseInviteUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseInviteUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseInviteUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetGroupInviteUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetGroupInviteUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetGroupInviteUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestGetGroupInviteUrlBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestGetGroupInviteUrlBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestGetGroupInviteUrlBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseGetGroupInviteUrlBase) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseGetGroupInviteUrlBase: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseGetGroupInviteUrlBase: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestRevokeInviteUrl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestRevokeInviteUrl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestRevokeInviteUrl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GroupPeer == nil {
				m.GroupPeer = &GroupOutPeer{}
			}
			if err := m.GroupPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestJoinGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestJoinGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestJoinGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v UpdateOptimization
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= UpdateOptimization(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Optimizations = append(m.Optimizations, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowGroups
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthGroups
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthGroups
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Optimizations) == 0 {
					m.Optimizations = make([]UpdateOptimization, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v UpdateOptimization
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowGroups
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= UpdateOptimization(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Optimizations = append(m.Optimizations, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Optimizations", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseJoinGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseJoinGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseJoinGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &Group{}
			}
			if err := m.Group.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserPeers = append(m.UserPeers, &UserOutPeer{})
			if err := m.UserPeers[len(m.UserPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestJoinGroupByPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestJoinGroupByPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestJoinGroupByPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Peer == nil {
				m.Peer = &GroupOutPeer{}
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestDeleteGroup) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestDeleteGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestDeleteGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupMemberInvited) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupMemberInvited: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupMemberInvited: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Member", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Member == nil {
				m.Member = &Member{}
			}
			if err := m.Member.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupInviteObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupInviteObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupInviteObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviteUid", wireType)
			}
			m.InviteUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviteUid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupUserInvitedObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupUserInvitedObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupUserInvitedObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviterUid", wireType)
			}
			m.InviterUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviterUid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rid", wireType)
			}
			m.Rid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Rid |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupUserLeaveObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupUserLeaveObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupUserLeaveObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupUserKickObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupUserKickObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupUserKickObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KickerUid", wireType)
			}
			m.KickerUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KickerUid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupMembersUpdateObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupMembersUpdateObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupMembersUpdateObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Members", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Members = append(m.Members, &Member{})
			if err := m.Members[len(m.Members)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupTitleChangedObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupTitleChangedObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupTitleChangedObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupAboutChangedObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupAboutChangedObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupAboutChangedObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.About == nil {
				m.About = &types.StringValue{}
			}
			if err := m.About.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupAvatarChangedObsolete) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupAvatarChangedObsolete: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupAvatarChangedObsolete: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Avatar", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Avatar == nil {
				m.Avatar = &Avatar{}
			}
			if err := m.Avatar.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mid", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Mid == nil {
				m.Mid = &UUIDValue{}
			}
			if err := m.Mid.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateGroupShortnameChanged) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateGroupShortnameChanged: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateGroupShortnameChanged: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			m.GroupId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shortname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthGroups
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthGroups
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shortname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			m.Uid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Uid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipGroups(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthGroups
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipGroups(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowGroups
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowGroups
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthGroups
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupGroups
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthGroups
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthGroups        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowGroups          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupGroups = fmt.Errorf("proto: unexpected end of group")
)
